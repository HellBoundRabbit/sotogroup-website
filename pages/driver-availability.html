<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SOTO Routes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="/manifest.json">
    <title>My Availability - SOTO Routes</title>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="../js/ui-dialogs.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit, where, updateDoc, doc, deleteDoc, getDoc, setDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.db = db;
        window.firestore = db;
        window.auth = auth;
        window.firebase = { functions, httpsCallable };
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseDoc = doc;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;
        window.serverTimestamp = serverTimestamp;
        
        // Make individual functions globally accessible
        window.query = query;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.updateDoc = updateDoc;
        window.where = where;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.signOut = signOut;
        
        console.log('Firebase initialized successfully!');

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initializeDriverAvailabilityApp();
        } else {
            document.addEventListener('DOMContentLoaded', initializeDriverAvailabilityApp);
        }
    </script>
    <style>
        .touch-target { min-height: 44px; min-width: 44px; }
        
        .day-card {
            transition: all 0.2s ease;
            background: rgb(0, 0, 0) !important; /* Black background for all days */
            color: white !important; /* White text */
            position: relative;
            isolation: isolate;
        }
        
        .day-card span {
            color: white !important;
            z-index: 2;
            position: relative;
        }
        
        /* Available (on) days - green and green animated border */
        .day-card.available:not(.pending-on)::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, #10b981, #059669, #10b981);
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        .day-card.available:not(.pending-on)::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(0, 0, 0);
            z-index: -1;
        }
        
        /* Unavailable (off) days - red and red animated border */
        .day-card.unavailable:not(.pending-off)::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, #ef4444, #dc2626, #ef4444);
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        .day-card.unavailable:not(.pending-off)::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(0, 0, 0);
            z-index: -1;
        }
        
        /* Pending change: newly selected off (red and black animated border) */
        .day-card.unavailable.pending-off::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, #ef4444, #000000, #ef4444);
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        .day-card.unavailable.pending-off::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(0, 0, 0);
            z-index: -1;
        }
        
        /* Pending change: changed from off to on (green and black animated border) */
        .day-card.available.pending-on::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, #10b981, #000000, #10b981);
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        .day-card.available.pending-on::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(0, 0, 0);
            z-index: -1;
        }
        
        /* Past days - black background with red line through */
        .day-card.opacity-50 {
            background: rgb(0, 0, 0) !important;
            position: relative;
        }
        .day-card.opacity-50::before {
            display: none; /* Hide animated border */
        }
        .day-card.opacity-50::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: #ef4444; /* Red line through */
            transform: translateY(-50%);
            z-index: 10;
            display: block;
        }
        
        @keyframes borderGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Calendar container with grey background and purple/cyan animated border */
        .calendar-container {
            position: relative;
            padding: 1.5rem;
            border-radius: 1rem;
            isolation: isolate;
        }
        /* Purple/cyan animated border - behind everything */
        .calendar-container::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(186, 66, 255), rgb(0, 225, 255), rgb(186, 66, 255));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: 0;
        }
        /* Grey background - in the middle */
        .calendar-container::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            background: rgb(36, 36, 36); /* Darker grey background */
            z-index: 1;
        }
        /* Calendar grid content - on top */
        .calendar-container > .grid {
            position: relative;
            z-index: 2;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 20, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        /* Calendar days container */
        #calendarDays {
            display: contents;
        }
        
        /* Loading spinner */
        .spinner-wrapper {
            width: 56px;
            height: 56px;
            position: relative;
        }
        .spinner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        .spinner-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            color: white;
            font-size: 1.5rem;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            filter: none !important;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Animated button for Save */
        .animated-button-save {
            position: relative;
            background: rgb(36, 36, 36);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            isolation: isolate;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 48px;
        }
        .animated-button-save::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(36, 36, 36);
            z-index: -1;
        }
        .animated-button-save::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, #10b981, #059669, #10b981);
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
    </style>
</head>
<body class="bg-black text-white min-h-screen">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="text-center">
            <div class="spinner-wrapper mx-auto mb-4">
                <div class="spinner"></div>
                <div class="spinner1"></div>
            </div>
            <p class="text-gray-400">Loading availability...</p>
        </div>
    </div>


    <!-- Top Navigation -->
    <div id="topNav" class="bg-black border-b border-gray-800 sticky top-0 z-50">
        <div class="flex items-center justify-between px-4 py-3">
            <button onclick="window.location.href='/pages/driver-portal.html'" class="touch-target">
                <div class="spinner-wrapper">
                    <div class="spinner"></div>
                    <div class="spinner1">
                        <span class="material-symbols-outlined spinner-icon">arrow_back</span>
                    </div>
                </div>
            </button>
            <h1 class="text-xl font-semibold flex-1 text-center">My Availability</h1>
            <div class="flex items-center gap-2">
                <div id="availabilityUploadStatusIndicator" class="hidden flex items-center gap-2 text-sm">
                    <span class="material-symbols-outlined animate-spin text-blue-400" style="font-size: 18px;">sync</span>
                    <span class="text-blue-400 text-xs" id="uploadStatusText">Syncing...</span>
                </div>
                <button id="saveChangesBtn" onclick="saveAllChanges()" class="hidden touch-target animated-button-save">
                    <span class="material-symbols-outlined text-white" style="font-size: 18px;">check</span>
                    <span class="text-white text-sm font-medium ml-2">Save</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent" class="container max-w-2xl mx-auto px-4 py-6">
        
        <!-- Instructions -->
        <div class="bg-blue-900 bg-opacity-20 border border-blue-500 rounded-lg p-4 mb-6">
            <div class="flex gap-3">
                <span class="material-symbols-outlined text-blue-400">info</span>
                <div class="flex-1">
                    <p class="text-sm text-blue-200">Tap a day to mark yourself as unavailable. Green days mean you're working, red days mean you're off.</p>
                </div>
            </div>
        </div>

        <!-- Month Selector -->
        <div class="bg-[#1a1f24] rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between">
                <button onclick="previousMonth()" class="touch-target p-2 hover:bg-[#283039] rounded-lg transition-colors">
                    <span class="material-symbols-outlined">chevron_left</span>
                </button>
                <h2 id="monthYear" class="text-xl font-semibold"></h2>
                <button onclick="nextMonth()" class="touch-target p-2 hover:bg-[#283039] rounded-lg transition-colors">
                    <span class="material-symbols-outlined">chevron_right</span>
                </button>
            </div>
        </div>

        <!-- Calendar -->
        <div class="calendar-container mb-6">
            <div class="grid grid-cols-5 gap-2">
                <!-- Day headers -->
                <div class="text-center text-sm text-gray-400 font-semibold py-2">Mon</div>
                <div class="text-center text-sm text-gray-400 font-semibold py-2">Tue</div>
                <div class="text-center text-sm text-gray-400 font-semibold py-2">Wed</div>
                <div class="text-center text-sm text-gray-400 font-semibold py-2">Thu</div>
                <div class="text-center text-sm text-gray-400 font-semibold py-2">Fri</div>
                
                <!-- Calendar days will be inserted here by renderCalendar() -->
            </div>
        </div>

        <!-- Legend -->
        <div class="bg-[#1a1f24] rounded-lg p-4">
            <h3 class="text-sm font-semibold mb-3 text-gray-400">LEGEND</h3>
            <div class="space-y-2">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-green-500 to-green-600 border-2 border-green-500"></div>
                    <span class="text-sm">Available / Working (Saved)</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-green-500 to-green-600 border-2 border-black"></div>
                    <span class="text-sm">Changed to Available (Not Saved)</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-red-500 to-red-600 border-2 border-red-500"></div>
                    <span class="text-sm">Unavailable / Day Off (Saved)</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-red-500 to-red-600 border-2 border-black"></div>
                    <span class="text-sm">Changed to Off (Not Saved)</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-[#283039] border-2 border-gray-700"></div>
                    <span class="text-sm">Past Day</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        let currentSession = null;
        let currentUser = null;
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        let availability = {}; // { 'YYYY-MM-DD': true/false }
        let pendingChanges = {}; // Track unsaved changes: { 'YYYY-MM-DD': true/false }
        let unseenChanges = {}; // Notifications currently unseen, keyed by date/driver
        let isSaving = false;
        const AVAILABILITY_QUEUE_KEY = 'driver_availability_queue_v1';
        const notifyError = (message, title = 'Error') => uiDialogs.showAlert({ title, message, tone: 'danger' });
        const notifyWarning = (message, title = 'Heads Up') => uiDialogs.showAlert({ title, message, tone: 'warning' });
        const notifySuccess = (message, title = 'Success') => uiDialogs.showAlert({ title, message, tone: 'success' });
        const notifyInfo = (message, title = 'Notice') => uiDialogs.showAlert({ title, message, tone: 'info' });

        const getCurrentOfficeId = () => currentSession?.officeId || currentUser?.officeId || null;
        const getCurrentDriverId = () => currentSession?.uid || currentUser?.uid || null;

        function loadAvailabilityQueue() {
            try {
                const raw = localStorage.getItem(AVAILABILITY_QUEUE_KEY);
                return raw ? JSON.parse(raw) : [];
            } catch (error) {
                console.error('Error reading availability queue:', error);
                return [];
            }
        }

        function saveAvailabilityQueue(queue) {
            try {
                localStorage.setItem(AVAILABILITY_QUEUE_KEY, JSON.stringify(queue));
            } catch (error) {
                console.error('Error saving availability queue:', error);
            }
        }

        function queueAvailabilityChanges(changes) {
            const driverId = getCurrentDriverId();
            const officeId = getCurrentOfficeId();
            if (!driverId || !officeId) {
                console.warn('No current user to queue availability changes.');
                return;
            }

            const queue = loadAvailabilityQueue();
            const driverContext = {
                driverId,
                driverName: currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim() || 'Unknown Driver',
                officeId,
                timestamp: Date.now()
            };

            Object.entries(changes).forEach(([dateString, newAvailability]) => {
                const existingIndex = queue.findIndex(
                    item => item.date === dateString && item.driverId === driverContext.driverId
                );

                const entry = {
                    ...driverContext,
                    date: dateString,
                    newAvailability
                };

                if (existingIndex >= 0) {
                    queue[existingIndex] = entry;
                } else {
                    queue.push(entry);
                }
            });

            saveAvailabilityQueue(queue);
            console.log('Queued availability changes for offline sync:', changes);
        }

        async function applyAvailabilityChange(dateString, newAvailability, context = {}) {
            const driverId = context.driverId || getCurrentDriverId();
            const driverName =
                context.driverName ||
                (currentUser && (currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim())) ||
                'Unknown Driver';
            const officeId = context.officeId || getCurrentOfficeId();

            if (!driverId || !officeId) {
                throw new Error('Missing driver or office context for availability change.');
            }

            const calendarRef = window.firebaseDoc(window.firestore, 'calendar', dateString);
            const calendarDoc = await window.firebaseGetDoc(calendarRef);

            let driversOff = [];
            if (calendarDoc.exists()) {
                driversOff = calendarDoc.data().driversOff || [];
            }

            if (newAvailability) {
                driversOff = driversOff.filter(id => id !== driverId);
            } else if (!driversOff.includes(driverId)) {
                driversOff.push(driverId);
            }

            await window.setDoc(
                calendarRef,
                {
                    date: dateString,
                    driversOff,
                    updatedAt: window.serverTimestamp(),
                    officeId: officeId
                },
                { merge: true }
            );

            await createAvailabilityChangeNotification(dateString, newAvailability, {
                driverId,
                driverName,
                officeId
            });
        }

        async function processAvailabilityQueue(options = {}) {
            const { showToast = true } = options;

            if (!navigator.onLine || !currentUser) {
                return;
            }

            const queue = loadAvailabilityQueue();
            if (!queue.length) {
                return;
            }

            console.log('Processing queued availability changes:', queue.length);
            const remaining = [];
            let processed = 0;

            for (const change of queue) {
                try {
                    await applyAvailabilityChange(change.date, change.newAvailability, change);
                    processed++;
                } catch (error) {
                    console.error('Error syncing queued availability change:', change, error);
                    remaining.push(change);
                }
            }

            saveAvailabilityQueue(remaining);

            if (processed > 0) {
                await loadAvailability();
                renderCalendar();
                if (showToast) {
                    notifySuccess(
                        `${processed} availability change${processed === 1 ? '' : 's'} synced.`,
                        'Back Online'
                    );
                }
                if (typeof window.loadUnseenChanges === 'function') {
                    await window.loadUnseenChanges();
                }
            }

            if (remaining.length > 0) {
                console.warn('Some availability changes could not be synced and remain queued.');
            }
        }

        window.processAvailabilityQueue = processAvailabilityQueue;
        window.addEventListener('online', () => {
            processAvailabilityQueue({ showToast: true });
        });

        // Check for unread messages
        async function checkForUnreadMessages() {
            try {
                if (!currentUser || !currentUser.officeId || !currentUser.uid) return false;
                
                const messagesQuery = window.query(
                    window.firebaseCollection(window.firestore, 'messages'),
                    window.where('officeId', '==', currentUser.officeId),
                    window.where('published', '==', true)
                );
                const snapshot = await window.firebaseGetDocs(messagesQuery);
                const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Get read messages from localStorage
                let readMessages = JSON.parse(localStorage.getItem('driver_read_messages') || '[]');
                
                // Also get read messages from Firebase (for persistence across devices/sessions)
                try {
                    const userDocRef = window.firebaseDoc(window.firestore, 'users', currentUser.uid);
                    const userDoc = await window.firebaseGetDoc(userDocRef);
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        const firebaseReadMessages = userData.readMessages || [];
                        // Merge Firebase read messages with localStorage (deduplicate)
                        readMessages = [...new Set([...readMessages, ...firebaseReadMessages])];
                        // Update localStorage with merged list
                        localStorage.setItem('driver_read_messages', JSON.stringify(readMessages));
                    }
                } catch (firebaseError) {
                    console.warn('Could not fetch read messages from Firebase, using localStorage only:', firebaseError);
                }
                
                const unreadMessages = messages.filter(msg => !readMessages.includes(msg.id));
                
                return unreadMessages.length > 0;
            } catch (error) {
                console.error('Error checking messages:', error);
                return false; // If check fails, allow access
            }
        }

        async function waitForFirebaseReady(maxAttempts = 20, delayMs = 150) {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                if (window.firestore && window.firebaseCollection) {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }
            console.error('Firebase did not become ready in time');
            return false;
        }

        // Initialize function
        async function initializeDriverAvailabilityApp() {
            console.log('Initializing driver availability app...');

            try {
                const session = await window.sotoSession.bootstrap(['driver']);
                if (!session) {
                    console.warn('Session bootstrap failed, redirecting to login.');
                window.location.href = '/pages/soto-routes-login.html';
                return;
            }

                currentSession = session;
                currentUser = { ...session };
            } catch (error) {
                console.error('Unable to establish session:', error);
                window.location.href = '/pages/soto-routes-login.html';
                return;
            }

            const ready = await waitForFirebaseReady();
            if (!ready) {
                notifyError('Firebase is unavailable. Please refresh and try again.');
                return;
            }

            try {
                const userDoc = await window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'users', currentSession.uid));
                if (!userDoc.exists()) {
                    console.log('Driver document not found');
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                currentUser = { ...currentUser, ...userDoc.data() };
                console.log('Current user:', currentUser);

                const hasUnreadMessages = await checkForUnreadMessages();
                if (hasUnreadMessages) {
                    notifyInfo('There are outstanding messages that need to be read before proceeding. Please read all messages first.', 'Unread Messages');
                    window.location.href = '/pages/driver-messages.html';
                    return;
                }

                await processAvailabilityQueue({ showToast: false });

                console.log('Loading availability...');
                await loadAvailability();
                renderCalendar();
                document.getElementById('loadingOverlay').style.display = 'none';
                console.log('Loading complete!');
            } catch (error) {
                console.error('Error loading user data:', error);
                notifyError('Error loading user data. Please try again.');
            }
        }

        // Load availability from Firebase
        async function loadAvailability() {
            try {
                pendingChanges = {}; // Clear any pending changes when loading
                updateSaveButtonVisibility(); // Hide save button
                
                // Load availability for this month and next month
                const startDate = new Date(currentYear, currentMonth, 1);
                const endDate = new Date(currentYear, currentMonth + 2, 0); // Last day of next month

                // Get all dates in range
            const dateStrings = [];
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                dateStrings.push(d.toISOString().split('T')[0]); // YYYY-MM-DD
                }

                // Batch read all documents at once
                const docPromises = dateStrings.map(dateStr => 
                    window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'calendar', dateStr))
                );
                const docSnapshots = await Promise.all(docPromises);

                // Process results
                dateStrings.forEach((dateString, index) => {
                    const doc = docSnapshots[index];
                    
                    if (doc.exists()) {
                        const data = doc.data();
                        const driversOff = data.driversOff || [];
                        
                        // Check if this driver is in the driversOff array
                        availability[dateString] = !driversOff.includes(currentUser.uid);
                    } else {
                        // No record means driver is available by default
                        availability[dateString] = true;
                    }
                });

                console.log('Loaded availability:', Object.keys(availability).length, 'dates');
            } catch (error) {
                console.error('Error loading availability:', error);
            }
        }

        async function loadUnseenChanges() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) return;

                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.where('officeId', '==', officeId)
                );
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);

                unseenChanges = {};
                notificationsSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    if (data.seen !== true && data.date && data.driverId) {
                        if (!unseenChanges[data.date]) {
                            unseenChanges[data.date] = {};
                        }
                        unseenChanges[data.date][data.driverId] = {
                            id: doc.id,
                            changeType: data.changeType || 'unavailable',
                        };
                    }
                });

                console.log('Loaded unseen changes:', unseenChanges);
            } catch (error) {
                console.error('Error loading unseen changes:', error);
            }
        }
        window.loadUnseenChanges = loadUnseenChanges;

        // Render calendar
        function renderCalendar() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            
            document.getElementById('monthYear').textContent = `${monthNames[currentMonth]} ${currentYear}`;

            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const calendarHTML = [];
            
            // Get the day of week for the first day (0=Sunday, 1=Monday, etc.)
            let firstDayOfWeek = firstDay.getDay();
            // Convert to Monday=0 format (Mon=0, Tue=1, Wed=2, Thu=3, Fri=4)
            firstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
            // Ensure it's a weekday (0-4)
            firstDayOfWeek = firstDayOfWeek > 4 ? 0 : firstDayOfWeek;
            
            // Add empty cells for days before the first weekday
            for (let i = 0; i < firstDayOfWeek; i++) {
                calendarHTML.push('<div></div>'); // Empty cell
            }
            
            // Generate calendar days (weekdays only)
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const cellDate = new Date(currentYear, currentMonth, day);
                const dayOfWeek = cellDate.getDay();
                
                // Skip weekends (Saturday = 6, Sunday = 0)
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    continue;
                }
                
                const dateString = cellDate.toISOString().split('T')[0];
                const isPast = cellDate < today;
                const hasPendingChange = pendingChanges.hasOwnProperty(dateString);
                
                // Get the current display state
                // If there's a pending change, use that value; otherwise use the saved availability
                const isAvailable = hasPendingChange 
                    ? pendingChanges[dateString] 
                    : (availability[dateString] !== false);
                
                // Check if date is within 7 days (locked)
                const daysFromToday = Math.floor((cellDate - today) / (1000 * 60 * 60 * 24));
                const isLocked = daysFromToday <= 7 && daysFromToday >= 0;

                let className = 'day-card aspect-square rounded-lg flex flex-col items-center justify-center cursor-pointer transition-all relative';
                
                if (isPast) {
                    className += ' cursor-not-allowed opacity-50';
                } else if (isLocked) {
                    className += isAvailable ? ' available locked' : ' unavailable locked';
                } else if (hasPendingChange) {
                    // Pending changes: show different border colors
                    if (isAvailable) {
                        // Changed to available (on) - green and black
                        className += ' available pending-on';
                    } else {
                        // Changed to unavailable (off) - red and black
                        className += ' unavailable pending-off';
                    }
                } else if (isAvailable) {
                    // Saved available (on) - green and green
                    className += ' available';
                } else {
                    // Saved unavailable (off) - red and red
                    className += ' unavailable';
                }

                const dayNumber = cellDate.getDate();
                const clickHandler = isPast || isLocked ? '' : `onclick="toggleAvailability('${dateString}')"`;

                calendarHTML.push(`
                    <div class="${className}" ${clickHandler}>
                        <span class="text-lg font-semibold text-white">${dayNumber}</span>
                        ${isLocked ? '<span class="material-symbols-outlined text-xs text-yellow-500 absolute top-1 right-1 z-10">lock</span>' : ''}
                    </div>
                `);
            }

            // Get the calendar grid container
            const calendarContainer = document.querySelector('.grid-cols-5');
            if (!calendarContainer) return;
            
            // Remove the old calendar days div if it exists
            const oldCalendarDays = document.getElementById('calendarDays');
            if (oldCalendarDays) {
                oldCalendarDays.remove();
            }
            
            // Create a new div for calendar days
            const calendarDaysDiv = document.createElement('div');
            calendarDaysDiv.id = 'calendarDays';
            calendarDaysDiv.className = 'contents'; // Use CSS Grid contents to make children participate in parent grid
            calendarDaysDiv.innerHTML = calendarHTML.join('');
            
            // Find where to insert it (after the day headers)
            const dayHeaders = calendarContainer.querySelectorAll('.text-center.text-sm.text-gray-400.font-semibold');
            if (dayHeaders.length > 0) {
                // Insert after the last day header
                dayHeaders[dayHeaders.length - 1].after(calendarDaysDiv);
            }
        }

        // Toggle availability for a specific day
        function toggleAvailability(dateString) {
            if (isSaving) return; // Don't allow changes while saving
            
            // Get the current saved state (not including pending changes)
            const savedAvailability = availability[dateString] !== false;
            
            // If there's already a pending change, toggle from the pending state
            // Otherwise, toggle from the saved state
            const currentDisplayState = pendingChanges.hasOwnProperty(dateString) 
                ? pendingChanges[dateString] 
                : savedAvailability;
            
            const newAvailability = !currentDisplayState;

            // Only update pendingChanges, don't update availability until saved
            pendingChanges[dateString] = newAvailability;
            
            // If toggling back to the saved state, remove from pending changes
            if (newAvailability === savedAvailability) {
                delete pendingChanges[dateString];
            }
            
            console.log('Toggle:', dateString, 'Saved:', savedAvailability, 'New:', newAvailability, 'Pending:', pendingChanges);
            renderCalendar();
            updateSaveButtonVisibility();
        }

        // Update save button visibility based on pending changes
        function updateSaveButtonVisibility() {
            const saveBtn = document.getElementById('saveChangesBtn');
            const hasPending = Object.keys(pendingChanges).length > 0;
            
            if (saveBtn) {
                if (hasPending && !isSaving) {
                    saveBtn.classList.remove('hidden');
                } else {
                    saveBtn.classList.add('hidden');
                }
            }
        }


        // Save all pending changes
        async function saveAllChanges() {
            if (isSaving || Object.keys(pendingChanges).length === 0) return;
            
            isSaving = true;
            const saveBtn = document.getElementById('saveChangesBtn');
            const statusIndicator = document.getElementById('availabilityUploadStatusIndicator');
            const statusText = document.getElementById('uploadStatusText');
            
            if (saveBtn) saveBtn.classList.add('hidden');
            if (statusIndicator) {
                statusIndicator.classList.remove('hidden');
                if (statusText) statusText.textContent = 'Saving...';
            }

            const changesToSave = { ...pendingChanges };
            const changeCount = Object.keys(changesToSave).length;
            pendingChanges = {};
            updateSaveButtonVisibility();
            renderCalendar(); // Update calendar to remove pending styles

            try {
                if (!navigator.onLine) {
                    queueAvailabilityChanges(changesToSave);
                    if (statusText) statusText.textContent = 'Saved offline';
                    setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                    notifyInfo('Changes saved offline. They will sync when you are back online.', 'Saved Offline');
                    return;
                }

                const failedChanges = {};
                let savedCount = 0;

                for (const [dateString, newAvailability] of Object.entries(changesToSave)) {
                    try {
                        await applyAvailabilityChange(dateString, newAvailability);
                        savedCount++;
                    } catch (error) {
                        console.error('Error saving availability change for', dateString, error);
                        failedChanges[dateString] = newAvailability;
                    }
                }

                if (Object.keys(failedChanges).length > 0) {
                    queueAvailabilityChanges(failedChanges);
                    if (statusText) statusText.textContent = 'Saved offline';
                    setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                    notifyWarning('Some changes could not be saved and were queued for offline sync.', 'Partial Save');
                } else {
                    if (statusText) statusText.textContent = 'Saved!';
                    setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                    
                    // Count changes for notification
                    let availableCount = 0;
                    let unavailableCount = 0;
                    Object.values(changesToSave).forEach(newAvailability => {
                        if (newAvailability) {
                            availableCount++;
                        } else {
                            unavailableCount++;
                        }
                    });
                    
                    const parts = [];
                    if (availableCount > 0) {
                        parts.push(`${availableCount} day${availableCount === 1 ? '' : 's'} marked as available`);
                    }
                    if (unavailableCount > 0) {
                        parts.push(`${unavailableCount} day${unavailableCount === 1 ? '' : 's'} marked as off`);
                    }
                    
                    const message = parts.length > 0 
                        ? `Availability updated: ${parts.join(' and ')}.`
                        : `Availability updated successfully.`;
                    
                    notifySuccess(message, 'Changes Saved');
                }
                
                // Update availability with saved changes
                Object.entries(changesToSave).forEach(([dateString, newAvailability]) => {
                    availability[dateString] = newAvailability;
                });
                
                // Reload availability to ensure sync
                await loadAvailability();
                renderCalendar();
            } catch (error) {
                console.error('Error saving changes:', error);
                queueAvailabilityChanges(changesToSave);
                if (statusText) statusText.textContent = 'Saved offline';
                setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                notifyWarning('Changes saved offline. They will sync when you are back online.', 'Saved Offline');
            } finally {
                isSaving = false;
                await processAvailabilityQueue({ showToast: false });
            }
        }

        // Make saveAllChanges globally available
        window.saveAllChanges = saveAllChanges;

        // Previous month
        async function previousMonth() {
            // Show loading overlay
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            currentMonth--;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            
            await loadAvailability();
            renderCalendar();
            
            // Hide loading overlay
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Next month
        async function nextMonth() {
            // Show loading overlay
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            currentMonth++;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            
            await loadAvailability();
            renderCalendar();
            
            // Hide loading overlay
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Go back to expenses
        function goToExpenses() {
            window.location.href = '/pages/driver-expenses.html';
        }

        // Create notification when driver changes availability
        async function createAvailabilityChangeNotification(dateString, isNowAvailable, context = {}) {
            try {
                const driverId = context.driverId || (currentUser && currentUser.uid);
                const officeId = context.officeId || (currentUser && currentUser.officeId);

                if (!driverId || !officeId) {
                    console.error('No user or officeId for notification');
                    return;
                }

                // Get driver information from drivers collection
                let driverName =
                    context.driverName ||
                    (currentUser && (currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim()));

                if (!driverName) {
                    const driversQuery = window.firebaseQuery(
                        window.firebaseCollection(window.firestore, 'drivers'),
                        window.where('uid', '==', driverId)
                    );
                    const driversSnapshot = await window.firebaseGetDocs(driversQuery);
                    if (driversSnapshot.docs.length > 0) {
                        const driverData = driversSnapshot.docs[0].data();
                        driverName = `${driverData.firstName || ''} ${driverData.lastName || ''}`.trim() || driverName;
                    }
                }

                // Format date for display
                const date = new Date(dateString);
                const formattedDate = date.toLocaleDateString('en-GB', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });

                // Check for existing unseen notifications for this driver/date
                const existingSnapshot = await window.firebaseGetDocs(
                    window.firebaseQuery(
                        window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                        window.where('officeId', '==', officeId),
                        window.where('driverId', '==', driverId),
                        window.where('date', '==', dateString),
                        window.where('seen', '==', false)
                    )
                );

                if (!existingSnapshot.empty) {
                    await Promise.all(existingSnapshot.docs.map(docSnap => window.firebaseDeleteDoc(docSnap.ref)));

                    // Keep local cache in sync so highlights disappear immediately
                    if (unseenChanges[dateString] && unseenChanges[dateString][driverId]) {
                        delete unseenChanges[dateString][driverId];
                        if (Object.keys(unseenChanges[dateString]).length === 0) {
                            delete unseenChanges[dateString];
                        }
                    }

                    if (isNowAvailable) {
                        console.log('ℹ️ Availability changed back to available before being reviewed; notification cleared.');
                        return;
                    }
                }

                // Create notification data
                const notificationData = {
                    type: 'availability_change',
                    driverId,
                    driverName: driverName,
                    date: dateString,
                    formattedDate: formattedDate,
                    officeId,
                    createdAt: new Date(),
                    seen: false, // Track if office has seen this specific change
                    changeType: isNowAvailable ? 'available' : 'unavailable', // 'available' = changed back to working, 'unavailable' = booked off
                    message: isNowAvailable 
                        ? `${driverName} has changed ${formattedDate} back to available`
                        : `${driverName} has booked ${formattedDate} off`
                };

                // Save notification to Firebase
                await window.firebaseAddDoc(window.firebaseCollection(window.firestore, 'availabilityNotifications'), notificationData);

                console.log('✅ Availability change notification created:', notificationData);
            } catch (error) {
                console.error('Error creating availability change notification:', error);
            }
        }
    </script>
</body>
</html>

