<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Availability - SOTO Routes</title>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="../js/ui-dialogs.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit, where, updateDoc, doc, deleteDoc, getDoc, setDoc, serverTimestamp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.db = db;
        window.firestore = db;
        window.auth = auth;
        window.firebase = { functions, httpsCallable };
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseDoc = doc;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;
        window.serverTimestamp = serverTimestamp;
        
        // Make individual functions globally accessible
        window.query = query;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.updateDoc = updateDoc;
        window.where = where;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.signOut = signOut;
        
        console.log('Firebase initialized successfully!');

        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            initializeDriverAvailabilityApp();
        } else {
            document.addEventListener('DOMContentLoaded', initializeDriverAvailabilityApp);
        }
    </script>
    <style>
        .touch-target { min-height: 44px; min-width: 44px; }
        
        .day-card {
            transition: all 0.2s ease;
        }
        
        .day-card.available {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-color: #10b981;
        }
        
        .day-card.unavailable {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            border-color: #ef4444;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 20, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        /* Calendar days container */
        #calendarDays {
            display: contents;
        }
    </style>
</head>
<body class="bg-[#0f1419] text-white min-h-screen">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="text-center">
            <div class="animate-spin rounded-full h-16 w-16 border-b-2 border-blue-500 mx-auto mb-4"></div>
            <p class="text-gray-400">Loading availability...</p>
        </div>
    </div>

    <!-- Upload Banner (shown when uploading) -->
    <div id="availabilityUploadBanner" class="hidden fixed top-0 left-0 right-0 bg-red-600 text-white z-[100] shadow-lg">
        <div class="flex items-center justify-center gap-3 px-4 py-3">
            <span class="material-symbols-outlined animate-pulse">cloud_upload</span>
            <div class="flex flex-col items-center">
                <span id="availabilityUploadBannerText" class="font-semibold text-sm">Marking availability...</span>
                <span class="text-xs opacity-90">DO NOT Leave this page</span>
            </div>
        </div>
    </div>

    <!-- Top Navigation -->
    <div id="topNav" class="bg-[#1a1f24] border-b border-gray-800 sticky top-0 z-50">
        <div class="flex items-center justify-between px-4 py-3">
            <button onclick="window.location.href='/pages/driver-portal.html'" class="touch-target flex items-center text-gray-400 hover:text-white transition-colors">
                <span class="material-symbols-outlined">arrow_back</span>
            </button>
            <h1 class="text-xl font-semibold flex-1 text-center">My Availability</h1>
            <div class="flex items-center gap-2">
                <div id="availabilityUploadStatusIndicator" class="hidden flex items-center gap-2 text-sm">
                    <span class="material-symbols-outlined animate-spin text-blue-400" style="font-size: 18px;">sync</span>
                    <span class="text-blue-400 text-xs" id="uploadStatusText">Syncing...</span>
                </div>
                <button id="saveChangesBtn" onclick="saveAllChanges()" class="hidden touch-target flex items-center gap-2 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors">
                    <span class="material-symbols-outlined" style="font-size: 18px;">check</span>
                    <span class="text-sm font-medium">Save</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent" class="container max-w-2xl mx-auto px-4 py-6">
        
        <!-- Instructions -->
        <div class="bg-blue-900 bg-opacity-20 border border-blue-500 rounded-lg p-4 mb-6">
            <div class="flex gap-3">
                <span class="material-symbols-outlined text-blue-400">info</span>
                <div class="flex-1">
                    <p class="text-sm text-blue-200">Tap a day to mark yourself as unavailable. Green days mean you're working, red days mean you're off.</p>
                </div>
            </div>
        </div>

        <!-- Month Selector -->
        <div class="bg-[#1a1f24] rounded-lg p-4 mb-6">
            <div class="flex items-center justify-between">
                <button onclick="previousMonth()" class="touch-target p-2 hover:bg-[#283039] rounded-lg transition-colors">
                    <span class="material-symbols-outlined">chevron_left</span>
                </button>
                <h2 id="monthYear" class="text-xl font-semibold"></h2>
                <button onclick="nextMonth()" class="touch-target p-2 hover:bg-[#283039] rounded-lg transition-colors">
                    <span class="material-symbols-outlined">chevron_right</span>
                </button>
            </div>
        </div>

        <!-- Calendar -->
        <div class="grid grid-cols-5 gap-2 mb-6">
            <!-- Day headers -->
            <div class="text-center text-sm text-gray-400 font-semibold py-2">Mon</div>
            <div class="text-center text-sm text-gray-400 font-semibold py-2">Tue</div>
            <div class="text-center text-sm text-gray-400 font-semibold py-2">Wed</div>
            <div class="text-center text-sm text-gray-400 font-semibold py-2">Thu</div>
            <div class="text-center text-sm text-gray-400 font-semibold py-2">Fri</div>
            
            <!-- Calendar days will be inserted here by renderCalendar() -->
        </div>

        <!-- Legend -->
        <div class="bg-[#1a1f24] rounded-lg p-4">
            <h3 class="text-sm font-semibold mb-3 text-gray-400">LEGEND</h3>
            <div class="space-y-2">
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-green-500 to-green-600 border-2 border-green-500"></div>
                    <span class="text-sm">Available / Working</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-gradient-to-br from-red-500 to-red-600 border-2 border-red-500"></div>
                    <span class="text-sm">Unavailable / Day Off</span>
                </div>
                <div class="flex items-center gap-3">
                    <div class="w-8 h-8 rounded-lg bg-[#283039] border-2 border-gray-700"></div>
                    <span class="text-sm">Past Day</span>
                </div>
            </div>
        </div>

    </div>

    <script>
        let currentSession = null;
        let currentUser = null;
        let currentMonth = new Date().getMonth();
        let currentYear = new Date().getFullYear();
        let availability = {}; // { 'YYYY-MM-DD': true/false }
        let pendingChanges = {}; // Track unsaved changes: { 'YYYY-MM-DD': true/false }
        let unseenChanges = {}; // Notifications currently unseen, keyed by date/driver
        let isSaving = false;
        const AVAILABILITY_QUEUE_KEY = 'driver_availability_queue_v1';
        const notifyError = (message, title = 'Error') => uiDialogs.showAlert({ title, message, tone: 'danger' });
        const notifyWarning = (message, title = 'Heads Up') => uiDialogs.showAlert({ title, message, tone: 'warning' });
        const notifySuccess = (message, title = 'Success') => uiDialogs.showAlert({ title, message, tone: 'success' });
        const notifyInfo = (message, title = 'Notice') => uiDialogs.showAlert({ title, message, tone: 'info' });

        const getCurrentOfficeId = () => currentSession?.officeId || currentUser?.officeId || null;
        const getCurrentDriverId = () => currentSession?.uid || currentUser?.uid || null;

        function loadAvailabilityQueue() {
            try {
                const raw = localStorage.getItem(AVAILABILITY_QUEUE_KEY);
                return raw ? JSON.parse(raw) : [];
            } catch (error) {
                console.error('Error reading availability queue:', error);
                return [];
            }
        }

        function saveAvailabilityQueue(queue) {
            try {
                localStorage.setItem(AVAILABILITY_QUEUE_KEY, JSON.stringify(queue));
            } catch (error) {
                console.error('Error saving availability queue:', error);
            }
        }

        function queueAvailabilityChanges(changes) {
            const driverId = getCurrentDriverId();
            const officeId = getCurrentOfficeId();
            if (!driverId || !officeId) {
                console.warn('No current user to queue availability changes.');
                return;
            }

            const queue = loadAvailabilityQueue();
            const driverContext = {
                driverId,
                driverName: currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim() || 'Unknown Driver',
                officeId,
                timestamp: Date.now()
            };

            Object.entries(changes).forEach(([dateString, newAvailability]) => {
                const existingIndex = queue.findIndex(
                    item => item.date === dateString && item.driverId === driverContext.driverId
                );

                const entry = {
                    ...driverContext,
                    date: dateString,
                    newAvailability
                };

                if (existingIndex >= 0) {
                    queue[existingIndex] = entry;
                } else {
                    queue.push(entry);
                }
            });

            saveAvailabilityQueue(queue);
            console.log('Queued availability changes for offline sync:', changes);
        }

        async function applyAvailabilityChange(dateString, newAvailability, context = {}) {
            const driverId = context.driverId || getCurrentDriverId();
            const driverName =
                context.driverName ||
                (currentUser && (currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim())) ||
                'Unknown Driver';
            const officeId = context.officeId || getCurrentOfficeId();

            if (!driverId || !officeId) {
                throw new Error('Missing driver or office context for availability change.');
            }

            const calendarRef = window.firebaseDoc(window.firestore, 'calendar', dateString);
            const calendarDoc = await window.firebaseGetDoc(calendarRef);

            let driversOff = [];
            if (calendarDoc.exists()) {
                driversOff = calendarDoc.data().driversOff || [];
            }

            if (newAvailability) {
                driversOff = driversOff.filter(id => id !== driverId);
            } else if (!driversOff.includes(driverId)) {
                driversOff.push(driverId);
            }

            await window.setDoc(
                calendarRef,
                {
                    date: dateString,
                    driversOff,
                    updatedAt: window.serverTimestamp(),
                    officeId: officeId
                },
                { merge: true }
            );

            await createAvailabilityChangeNotification(dateString, newAvailability, {
                driverId,
                driverName,
                officeId
            });
        }

        async function processAvailabilityQueue(options = {}) {
            const { showToast = true } = options;

            if (!navigator.onLine) {
                updateAvailabilityUploadBanner();
                return;
            }

            if (!currentUser) {
                updateAvailabilityUploadBanner();
                return;
            }

            const queue = loadAvailabilityQueue();
            if (!queue.length) {
                updateAvailabilityUploadBanner();
                return;
            }

            console.log('Processing queued availability changes:', queue.length);
            const remaining = [];
            let processed = 0;

            // Update banner before processing
            updateAvailabilityUploadBanner();

            for (const change of queue) {
                try {
                    await applyAvailabilityChange(change.date, change.newAvailability, change);
                    processed++;
                    // Update banner during processing
                    updateAvailabilityUploadBanner();
                } catch (error) {
                    console.error('Error syncing queued availability change:', change, error);
                    remaining.push(change);
                }
            }

            saveAvailabilityQueue(remaining);

            if (processed > 0) {
                await loadAvailability();
                renderCalendar();
                if (showToast) {
                    notifySuccess(
                        `${processed} availability change${processed === 1 ? '' : 's'} synced.`,
                        'Back Online'
                    );
                }
                if (typeof window.loadUnseenChanges === 'function') {
                    await window.loadUnseenChanges();
                }
            }

            if (remaining.length > 0) {
                console.warn('Some availability changes could not be synced and remain queued.');
            }

            // Update banner after processing
            updateAvailabilityUploadBanner();
        }

        window.processAvailabilityQueue = processAvailabilityQueue;
        window.addEventListener('online', () => {
            processAvailabilityQueue({ showToast: true });
            updateAvailabilityUploadBanner();
        });
        
        // Warn user if they try to leave while uploading
        window.addEventListener('beforeunload', (e) => {
            const banner = document.getElementById('availabilityUploadBanner');
            if (banner && !banner.classList.contains('hidden')) {
                e.preventDefault();
                e.returnValue = 'You have availability changes uploading. Are you sure you want to leave?';
                return e.returnValue;
            }
        });
        
        // Set up periodic status updates while uploading
        let availabilityStatusCheckInterval = null;
        function startAvailabilityStatusCheck() {
            if (availabilityStatusCheckInterval) {
                clearInterval(availabilityStatusCheckInterval);
            }
            availabilityStatusCheckInterval = setInterval(() => {
                updateAvailabilityUploadBanner();
                // Stop checking if nothing is uploading
                const queue = loadAvailabilityQueue();
                const hasPendingChanges = Object.keys(pendingChanges).length > 0;
                if (!isSaving && queue.length === 0 && !hasPendingChanges) {
                    clearInterval(availabilityStatusCheckInterval);
                    availabilityStatusCheckInterval = null;
                }
            }, 2000); // Check every 2 seconds
        }

        // Check for unread messages
        async function checkForUnreadMessages() {
            try {
                if (!currentUser || !currentUser.officeId || !currentUser.uid) return false;
                
                const messagesQuery = window.query(
                    window.firebaseCollection(window.firestore, 'messages'),
                    window.where('officeId', '==', currentUser.officeId),
                    window.where('published', '==', true)
                );
                const snapshot = await window.firebaseGetDocs(messagesQuery);
                const messages = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                // Get read messages from localStorage
                let readMessages = JSON.parse(localStorage.getItem('driver_read_messages') || '[]');
                
                // Also get read messages from Firebase (for persistence across devices/sessions)
                try {
                    const userDocRef = window.firebaseDoc(window.firestore, 'users', currentUser.uid);
                    const userDoc = await window.firebaseGetDoc(userDocRef);
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        const firebaseReadMessages = userData.readMessages || [];
                        // Merge Firebase read messages with localStorage (deduplicate)
                        readMessages = [...new Set([...readMessages, ...firebaseReadMessages])];
                        // Update localStorage with merged list
                        localStorage.setItem('driver_read_messages', JSON.stringify(readMessages));
                    }
                } catch (firebaseError) {
                    console.warn('Could not fetch read messages from Firebase, using localStorage only:', firebaseError);
                }
                
                const unreadMessages = messages.filter(msg => !readMessages.includes(msg.id));
                
                return unreadMessages.length > 0;
            } catch (error) {
                console.error('Error checking messages:', error);
                return false; // If check fails, allow access
            }
        }

        async function waitForFirebaseReady(maxAttempts = 20, delayMs = 150) {
            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                if (window.firestore && window.firebaseCollection) {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, delayMs));
            }
            console.error('Firebase did not become ready in time');
            return false;
        }

        // Initialize function
        async function initializeDriverAvailabilityApp() {
            console.log('Initializing driver availability app...');

            try {
                const session = await window.sotoSession.bootstrap(['driver']);
                if (!session) {
                    console.warn('Session bootstrap failed, redirecting to login.');
                window.location.href = '/pages/soto-routes-login.html';
                return;
            }

                currentSession = session;
                currentUser = { ...session };
            } catch (error) {
                console.error('Unable to establish session:', error);
                window.location.href = '/pages/soto-routes-login.html';
                return;
            }

            const ready = await waitForFirebaseReady();
            if (!ready) {
                notifyError('Firebase is unavailable. Please refresh and try again.');
                return;
            }

            try {
                const userDoc = await window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'users', currentSession.uid));
                if (!userDoc.exists()) {
                    console.log('Driver document not found');
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                currentUser = { ...currentUser, ...userDoc.data() };
                console.log('Current user:', currentUser);

                const hasUnreadMessages = await checkForUnreadMessages();
                if (hasUnreadMessages) {
                    notifyInfo('There are outstanding messages that need to be read before proceeding. Please read all messages first.', 'Unread Messages');
                    window.location.href = '/pages/driver-messages.html';
                    return;
                }

                await processAvailabilityQueue({ showToast: false });

                console.log('Loading availability...');
                await loadAvailability();
                renderCalendar();
                document.getElementById('loadingOverlay').style.display = 'none';
                console.log('Loading complete!');
                
                // Initialize banner status and start periodic checks
                updateAvailabilityUploadBanner();
                startAvailabilityStatusCheck();
            } catch (error) {
                console.error('Error loading user data:', error);
                notifyError('Error loading user data. Please try again.');
            }
        }

        // Load availability from Firebase
        async function loadAvailability() {
            try {
                pendingChanges = {}; // Clear any pending changes when loading
                updateSaveButtonVisibility(); // Hide save button
                
                // Load availability for this month and next month
                const startDate = new Date(currentYear, currentMonth, 1);
                const endDate = new Date(currentYear, currentMonth + 2, 0); // Last day of next month

                // Get all dates in range
            const dateStrings = [];
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                dateStrings.push(d.toISOString().split('T')[0]); // YYYY-MM-DD
                }

                // Batch read all documents at once
                const docPromises = dateStrings.map(dateStr => 
                    window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'calendar', dateStr))
                );
                const docSnapshots = await Promise.all(docPromises);

                // Process results
                dateStrings.forEach((dateString, index) => {
                    const doc = docSnapshots[index];
                    
                    if (doc.exists()) {
                        const data = doc.data();
                        const driversOff = data.driversOff || [];
                        
                        // Check if this driver is in the driversOff array
                        availability[dateString] = !driversOff.includes(currentUser.uid);
                    } else {
                        // No record means driver is available by default
                        availability[dateString] = true;
                    }
                });

                console.log('Loaded availability:', Object.keys(availability).length, 'dates');
            } catch (error) {
                console.error('Error loading availability:', error);
            }
        }

        async function loadUnseenChanges() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) return;

                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.where('officeId', '==', officeId)
                );
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);

                unseenChanges = {};
                notificationsSnapshot.docs.forEach((doc) => {
                    const data = doc.data();
                    if (data.seen !== true && data.date && data.driverId) {
                        if (!unseenChanges[data.date]) {
                            unseenChanges[data.date] = {};
                        }
                        unseenChanges[data.date][data.driverId] = {
                            id: doc.id,
                            changeType: data.changeType || 'unavailable',
                        };
                    }
                });

                console.log('Loaded unseen changes:', unseenChanges);
            } catch (error) {
                console.error('Error loading unseen changes:', error);
            }
        }
        window.loadUnseenChanges = loadUnseenChanges;

        // Render calendar
        function renderCalendar() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            
            document.getElementById('monthYear').textContent = `${monthNames[currentMonth]} ${currentYear}`;

            const firstDay = new Date(currentYear, currentMonth, 1);
            const lastDay = new Date(currentYear, currentMonth + 1, 0);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            const calendarHTML = [];
            
            // Get the day of week for the first day (0=Sunday, 1=Monday, etc.)
            let firstDayOfWeek = firstDay.getDay();
            // Convert to Monday=0 format (Mon=0, Tue=1, Wed=2, Thu=3, Fri=4)
            firstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
            // Ensure it's a weekday (0-4)
            firstDayOfWeek = firstDayOfWeek > 4 ? 0 : firstDayOfWeek;
            
            // Add empty cells for days before the first weekday
            for (let i = 0; i < firstDayOfWeek; i++) {
                calendarHTML.push('<div></div>'); // Empty cell
            }
            
            // Generate calendar days (weekdays only)
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const cellDate = new Date(currentYear, currentMonth, day);
                const dayOfWeek = cellDate.getDay();
                
                // Skip weekends (Saturday = 6, Sunday = 0)
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    continue;
                }
                
                const dateString = cellDate.toISOString().split('T')[0];
                const isPast = cellDate < today;
                const isAvailable = availability[dateString] !== false;
                
                // Check if date is within 7 days (locked)
                const daysFromToday = Math.floor((cellDate - today) / (1000 * 60 * 60 * 24));
                const isLocked = daysFromToday <= 7 && daysFromToday >= 0;

                let className = 'day-card aspect-square rounded-lg border-2 flex flex-col items-center justify-center cursor-pointer transition-all relative';
                
                if (isPast) {
                    className += ' bg-[#283039] border-gray-700 cursor-not-allowed opacity-50';
                } else if (isLocked) {
                    className += isAvailable ? ' available border-yellow-500' : ' unavailable border-yellow-500';
                } else if (isAvailable) {
                    className += ' available';
                } else {
                    className += ' unavailable';
                }

                const dayNumber = cellDate.getDate();
                const clickHandler = isPast || isLocked ? '' : `onclick="toggleAvailability('${dateString}')"`;

                calendarHTML.push(`
                    <div class="${className}" ${clickHandler}>
                        <span class="text-lg font-semibold">${dayNumber}</span>
                        ${isLocked ? '<span class="material-symbols-outlined text-xs text-yellow-500 absolute top-1 right-1">lock</span>' : ''}
                    </div>
                `);
            }

            // Get the calendar grid container
            const calendarContainer = document.querySelector('.grid-cols-5');
            if (!calendarContainer) return;
            
            // Remove the old calendar days div if it exists
            const oldCalendarDays = document.getElementById('calendarDays');
            if (oldCalendarDays) {
                oldCalendarDays.remove();
            }
            
            // Create a new div for calendar days
            const calendarDaysDiv = document.createElement('div');
            calendarDaysDiv.id = 'calendarDays';
            calendarDaysDiv.className = 'contents'; // Use CSS Grid contents to make children participate in parent grid
            calendarDaysDiv.innerHTML = calendarHTML.join('');
            
            // Find where to insert it (after the day headers)
            const dayHeaders = calendarContainer.querySelectorAll('.text-center.text-sm.text-gray-400.font-semibold');
            if (dayHeaders.length > 0) {
                // Insert after the last day header
                dayHeaders[dayHeaders.length - 1].after(calendarDaysDiv);
            }
        }

        // Toggle availability for a specific day
        function toggleAvailability(dateString) {
            if (isSaving) return; // Don't allow changes while saving
            
            const isCurrentlyAvailable = availability[dateString] !== false;
            const newAvailability = !isCurrentlyAvailable;

            // Update local state immediately for responsiveness
            availability[dateString] = newAvailability;
            pendingChanges[dateString] = newAvailability; // Track pending changes
            renderCalendar();
            updateSaveButtonVisibility();
            updateAvailabilityUploadBanner(); // Update banner when changes are made
            startAvailabilityStatusCheck(); // Start periodic status updates
        }

        // Update save button visibility based on pending changes
        function updateSaveButtonVisibility() {
            const saveBtn = document.getElementById('saveChangesBtn');
            const hasPending = Object.keys(pendingChanges).length > 0;
            
            if (saveBtn) {
                if (hasPending && !isSaving) {
                    saveBtn.classList.remove('hidden');
                } else {
                    saveBtn.classList.add('hidden');
                }
            }
        }

        // Update availability upload banner
        function updateAvailabilityUploadBanner() {
            const queue = loadAvailabilityQueue();
            const hasPendingChanges = Object.keys(pendingChanges).length > 0;
            const hasQueuedChanges = queue.length > 0;
            const isUploading = isSaving || hasQueuedChanges || hasPendingChanges;
            
            const banner = document.getElementById('availabilityUploadBanner');
            const bannerText = document.getElementById('availabilityUploadBannerText');
            const topNav = document.getElementById('topNav');
            const mainContent = document.getElementById('mainContent');
            
            if (isUploading) {
                // Count available vs unavailable days
                let availableCount = 0;
                let unavailableCount = 0;
                
                // Count from pending changes
                Object.values(pendingChanges).forEach(newAvailability => {
                    if (newAvailability) {
                        availableCount++;
                    } else {
                        unavailableCount++;
                    }
                });
                
                // Count from queue
                queue.forEach(change => {
                    if (change.newAvailability) {
                        availableCount++;
                    } else {
                        unavailableCount++;
                    }
                });
                
                // Show banner
                if (banner) {
                    banner.classList.remove('hidden');
                }
                
                // Adjust top nav and content to account for banner
                if (topNav) {
                    topNav.style.marginTop = '48px'; // Banner height
                }
                if (mainContent) {
                    mainContent.style.marginTop = '0';
                }
                
                // Update banner text
                if (bannerText) {
                    const parts = [];
                    if (availableCount > 0) {
                        parts.push(`${availableCount} day${availableCount === 1 ? '' : 's'} available`);
                    }
                    if (unavailableCount > 0) {
                        parts.push(`${unavailableCount} day${unavailableCount === 1 ? '' : 's'} off`);
                    }
                    
                    if (parts.length > 0) {
                        bannerText.textContent = `Marking ${parts.join(', and ')}`;
                    } else {
                        bannerText.textContent = 'Marking availability...';
                    }
                }
            } else {
                // Hide banner
                hideAvailabilityUploadBanner();
            }
        }
        
        function hideAvailabilityUploadBanner() {
            const banner = document.getElementById('availabilityUploadBanner');
            const topNav = document.getElementById('topNav');
            const mainContent = document.getElementById('mainContent');
            
            if (banner) {
                banner.classList.add('hidden');
            }
            if (topNav) {
                topNav.style.marginTop = '0';
            }
            if (mainContent) {
                mainContent.style.marginTop = '0';
            }
        }

        // Save all pending changes
        async function saveAllChanges() {
            if (isSaving || Object.keys(pendingChanges).length === 0) return;
            
            isSaving = true;
            const saveBtn = document.getElementById('saveChangesBtn');
            const statusIndicator = document.getElementById('availabilityUploadStatusIndicator');
            const statusText = document.getElementById('uploadStatusText');
            
            if (saveBtn) saveBtn.classList.add('hidden');
            if (statusIndicator) {
                statusIndicator.classList.remove('hidden');
                if (statusText) statusText.textContent = 'Syncing...';
            }

            const changesToSave = { ...pendingChanges };
            pendingChanges = {};
            updateSaveButtonVisibility();
            
            // Update banner immediately
            updateAvailabilityUploadBanner();

            try {
                if (!navigator.onLine) {
                    queueAvailabilityChanges(changesToSave);
                    if (statusText) statusText.textContent = 'Saved offline';
                    setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                    // Don't show dialog - banner will show status
                    updateAvailabilityUploadBanner();
                    return;
                }

                const failedChanges = {};

                for (const [dateString, newAvailability] of Object.entries(changesToSave)) {
                    try {
                        await applyAvailabilityChange(dateString, newAvailability);
                        // Update banner during save
                        updateAvailabilityUploadBanner();
                    } catch (error) {
                        console.error('Error saving availability change for', dateString, error);
                        failedChanges[dateString] = newAvailability;
                    }
                }

                if (Object.keys(failedChanges).length > 0) {
                    queueAvailabilityChanges(failedChanges);
                    if (statusText) statusText.textContent = 'Saved offline';
                    // Don't show dialog - banner will show status
                    updateAvailabilityUploadBanner();
                } else {
                    if (statusText) statusText.textContent = 'Saved!';
                    setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                    notifySuccess('Availability updated successfully.');
                    updateAvailabilityUploadBanner();
                }
            } catch (error) {
                console.error('Error saving changes:', error);
                queueAvailabilityChanges(changesToSave);
                if (statusText) statusText.textContent = 'Saved offline';
                setTimeout(() => statusIndicator && statusIndicator.classList.add('hidden'), 1500);
                // Don't show dialog - banner will show status
                updateAvailabilityUploadBanner();
            } finally {
                isSaving = false;
                await processAvailabilityQueue({ showToast: false });
                updateAvailabilityUploadBanner();
            }
        }

        // Make saveAllChanges globally available
        window.saveAllChanges = saveAllChanges;

        // Previous month
        async function previousMonth() {
            // Show loading overlay
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            currentMonth--;
            if (currentMonth < 0) {
                currentMonth = 11;
                currentYear--;
            }
            
            await loadAvailability();
            renderCalendar();
            
            // Hide loading overlay
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Next month
        async function nextMonth() {
            // Show loading overlay
            document.getElementById('loadingOverlay').style.display = 'flex';
            
            currentMonth++;
            if (currentMonth > 11) {
                currentMonth = 0;
                currentYear++;
            }
            
            await loadAvailability();
            renderCalendar();
            
            // Hide loading overlay
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        // Go back to expenses
        function goToExpenses() {
            window.location.href = '/pages/driver-expenses.html';
        }

        // Create notification when driver changes availability
        async function createAvailabilityChangeNotification(dateString, isNowAvailable, context = {}) {
            try {
                const driverId = context.driverId || (currentUser && currentUser.uid);
                const officeId = context.officeId || (currentUser && currentUser.officeId);

                if (!driverId || !officeId) {
                    console.error('No user or officeId for notification');
                    return;
                }

                // Get driver information from drivers collection
                let driverName =
                    context.driverName ||
                    (currentUser && (currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim()));

                if (!driverName) {
                    const driversQuery = window.firebaseQuery(
                        window.firebaseCollection(window.firestore, 'drivers'),
                        window.where('uid', '==', driverId)
                    );
                    const driversSnapshot = await window.firebaseGetDocs(driversQuery);
                    if (driversSnapshot.docs.length > 0) {
                        const driverData = driversSnapshot.docs[0].data();
                        driverName = `${driverData.firstName || ''} ${driverData.lastName || ''}`.trim() || driverName;
                    }
                }

                // Format date for display
                const date = new Date(dateString);
                const formattedDate = date.toLocaleDateString('en-GB', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });

                // Check for existing unseen notifications for this driver/date
                const existingSnapshot = await window.firebaseGetDocs(
                    window.firebaseQuery(
                        window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                        window.where('officeId', '==', officeId),
                        window.where('driverId', '==', driverId),
                        window.where('date', '==', dateString),
                        window.where('seen', '==', false)
                    )
                );

                if (!existingSnapshot.empty) {
                    await Promise.all(existingSnapshot.docs.map(docSnap => window.firebaseDeleteDoc(docSnap.ref)));

                    // Keep local cache in sync so highlights disappear immediately
                    if (unseenChanges[dateString] && unseenChanges[dateString][driverId]) {
                        delete unseenChanges[dateString][driverId];
                        if (Object.keys(unseenChanges[dateString]).length === 0) {
                            delete unseenChanges[dateString];
                        }
                    }

                    if (isNowAvailable) {
                        console.log('ℹ️ Availability changed back to available before being reviewed; notification cleared.');
                        return;
                    }
                }

                // Create notification data
                const notificationData = {
                    type: 'availability_change',
                    driverId,
                    driverName: driverName,
                    date: dateString,
                    formattedDate: formattedDate,
                    officeId,
                    createdAt: new Date(),
                    seen: false, // Track if office has seen this specific change
                    changeType: isNowAvailable ? 'available' : 'unavailable', // 'available' = changed back to working, 'unavailable' = booked off
                    message: isNowAvailable 
                        ? `${driverName} has changed ${formattedDate} back to available`
                        : `${driverName} has booked ${formattedDate} off`
                };

                // Save notification to Firebase
                await window.firebaseAddDoc(window.firebaseCollection(window.firestore, 'availabilityNotifications'), notificationData);

                console.log('✅ Availability change notification created:', notificationData);
            } catch (error) {
                console.error('Error creating availability change notification:', error);
            }
        }
    </script>
</body>
</html>

