<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="SOTO Routes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="/manifest.json">
    <title>My Expenses - SOTO Routes</title>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="../js/ui-dialogs.js"></script>
    <!-- PDF Generation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <!-- ZIP Creation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <!-- Expense batch schema (merged lines: trains, taxis, fuels, etc.) -->
    <script src="/js/expense-batch-schema.js"></script>
    <!-- Offline Storage & Upload Queue System -->
    <script src="/js/expense-offline-storage.js"></script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit, where, updateDoc, doc, deleteDoc, getDoc, getDocFromServer, setDoc, serverTimestamp, arrayUnion } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        const storage = getStorage(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.db = db;
        window.auth = auth;
        window.storage = storage;
        window.firebase = { functions, httpsCallable };
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseDoc = doc;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseGetDocFromServer = getDocFromServer;
        window.firebaseSetDoc = setDoc;
        window.serverTimestamp = serverTimestamp;
        window.arrayUnion = arrayUnion;
        
        // Make individual functions globally accessible
        window.query = query;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.updateDoc = updateDoc;
        window.where = where;
        window.orderBy = orderBy;
        window.limit = limit;
        window.doc = doc;
        window.getDoc = getDoc;
        window.getDocFromServer = getDocFromServer;
        window.setDoc = setDoc;
        window.deleteDoc = deleteDoc;
        window.signOut = signOut;
        window.ref = ref;
        window.uploadBytes = uploadBytes;
        window.getDownloadURL = getDownloadURL;
        window.deleteObject = deleteObject;
        
        console.log('Firebase initialized successfully!');
    </script>
    <script>
        // Helpers for photo display: only count/show valid image URLs (avoids wrong counts and black images)
        function getValidPhotoCount(exp) {
            if (!exp || !exp.photos || !Array.isArray(exp.photos)) return 0;
            const fn = window.isValidPhotoURL || (u => typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')));
            return exp.photos.filter(p => typeof p === 'string' && fn(p)).length;
        }
        /** Count for UI: valid URLs + File/Blob (so draft expenses with attached photos show "1 photo"). */
        function getDisplayPhotoCount(exp) {
            if (!exp || !exp.photos || !Array.isArray(exp.photos)) return 0;
            const fn = window.isValidPhotoURL || (u => typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')));
            const urlCount = exp.photos.filter(p => typeof p === 'string' && fn(p)).length;
            const fileCount = exp.photos.filter(p => p instanceof File || p instanceof Blob).length;
            return urlCount + fileCount;
        }
        function getValidPhotoURLs(exp) {
            if (!exp || !exp.photos || !Array.isArray(exp.photos)) return [];
            const fn = window.isValidPhotoURL || (u => typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')));
            return exp.photos.filter(p => typeof p === 'string' && fn(p));
        }

        // Register Service Worker for background uploads
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js');
                    console.log('[SW] Service Worker registered:', registration.scope);
                    
                    // Listen for Service Worker requests for auth token
                    navigator.serviceWorker.addEventListener('message', async (event) => {
                        const { type, blob, path, expenseDocId, batchId, lineKey } = event.data || {};
                        const ports = event.ports || [];
                        
                        if (type === 'get-auth-token' && ports.length > 0) {
                            try {
                                // Get Firebase Auth token
                                let authToken = null;
                                if (window.auth && window.auth.currentUser) {
                                    authToken = await window.auth.currentUser.getIdToken();
                                    console.log('[Main Thread] Sending auth token to Service Worker');
                                } else {
                                    console.warn('[Main Thread] No authenticated user, cannot provide auth token');
                                }
                                
                                // Send token back to Service Worker via the port
                                ports[0].postMessage({ authToken });
                            } catch (error) {
                                console.error('[Main Thread] Error getting auth token for Service Worker:', error);
                                if (ports[0]) {
                                    ports[0].postMessage({ authToken: null });
                                }
                            }
                        } else if (type === 'upload-photo-request' && ports.length > 0 && blob && path) {
                            // Service Worker requesting main thread to upload photo using Firebase SDK
                            try {
                                console.log('[Main Thread] Received upload request from Service Worker:', { path, expenseDocId });
                                
                                // Upload using Firebase SDK (same as successful uploads)
                                const photoRef = window.ref(window.storage, path);
                                await window.uploadBytes(photoRef, blob);
                                const downloadURL = await window.getDownloadURL(photoRef);
                                
                                console.log('[Main Thread] Upload successful:', downloadURL);
                                
                                // Send success back to Service Worker
                                ports[0].postMessage({ success: true, downloadURL });
                            } catch (error) {
                                console.error('[Main Thread] Upload failed:', error);
                                ports[0].postMessage({ success: false, error: error.message });
                            }
                        } else if (type === 'check-batch-line-photos' && ports.length > 0 && batchId && lineKey) {
                            try {
                                const batchRef = window.doc(window.db, 'expenseBatches', batchId);
                                const batchSnap = await window.getDoc(batchRef);
                                let photoURLs = [];
                                if (batchSnap.exists()) {
                                    const data = batchSnap.data();
                                    const lines = data.lines || {};
                                    const line = lines[lineKey];
                                    if (line && Array.isArray(line.photos)) {
                                        photoURLs = line.photos.filter(p => typeof p === 'string');
                                    }
                                }
                                ports[0].postMessage({ success: true, photoURLs });
                            } catch (error) {
                                console.error('[Main Thread] Error checking batch line photos:', error);
                                ports[0].postMessage({ success: false, photoURLs: [] });
                            }
                        }
                    });
                    
                    // Check for updates periodically
                    setInterval(() => {
                        registration.update();
                    }, 60000); // Check every minute
                } catch (error) {
                    console.warn('[SW] Service Worker registration failed:', error);
                }
            });
        }
    </script>
    <style>
        /* Mobile-optimized touch targets */
        .touch-target { min-height: 44px; min-width: 44px; }
        
        /* Status badge colors */
        .status-pending { background-color: #f59e0b; }
        .status-validated { background-color: #10b981; }
        .status-paid { background-color: #3b82f6; }
        .status-returned { background-color: #ef4444; }
        
        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 20, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        /* Smooth animations */
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* License plate style */
        .license-plate {
            background: #FFD500;
            color: #000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 2px;
            padding: 8px 16px;
            border-radius: 6px;
            border: 2px solid #000;
        }
        
        /* Flash animation for overdue items */
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .flash-red {
            animation: flash 1s infinite;
        }
        
        /* Animated border panel base */
        .animated-border-panel {
            position: relative;
            background: #1a1f24;
            border-radius: 0.5rem;
            padding: 1rem;
            isolation: isolate;
        }
        .animated-border-panel::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: #1a1f24;
            z-index: -1;
        }
        
        /* Draft: black and grey */
        .animated-border-draft::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(128, 128, 128), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Pending/Validated: solid glowing orange */
        .animated-border-pending::before,
        .animated-border-validated::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(255, 165, 0), rgb(255, 200, 50), rgb(255, 165, 0));
            box-shadow: 0 0 15px rgba(255, 165, 0, 0.6), 0 0 30px rgba(255, 165, 0, 0.4);
            z-index: -1;
        }
        
        /* Paid: solid glowing green */
        .animated-border-paid::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 255, 0), rgb(100, 255, 100), rgb(0, 255, 0));
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6), 0 0 30px rgba(0, 255, 0, 0.4);
            z-index: -1;
        }
        
        /* Returned: solid glowing red */
        .animated-border-returned::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(255, 0, 0), rgb(255, 100, 100), rgb(255, 0, 0));
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6), 0 0 30px rgba(255, 0, 0, 0.4);
            z-index: -1;
        }
        
        @keyframes borderGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Animated border modal */
        .animated-border-modal {
            position: relative;
            background: #1a1f24;
            border-radius: 1rem;
            isolation: isolate;
        }
        .animated-border-modal::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            background: #1a1f24;
            z-index: -1;
        }
        
        /* Draft modal: black and grey */
        .animated-border-modal-draft::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(128, 128, 128), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Pending/Validated modal: solid glowing orange */
        .animated-border-modal-pending::before,
        .animated-border-modal-validated::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(255, 165, 0), rgb(255, 200, 50), rgb(255, 165, 0));
            box-shadow: 0 0 15px rgba(255, 165, 0, 0.6), 0 0 30px rgba(255, 165, 0, 0.4);
            z-index: -1;
        }
        
        /* Paid modal: solid glowing green */
        .animated-border-modal-paid::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(0, 255, 0), rgb(100, 255, 100), rgb(0, 255, 0));
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.6), 0 0 30px rgba(0, 255, 0, 0.4);
            z-index: -1;
        }
        
        /* Returned modal: solid glowing red */
        .animated-border-modal-returned::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(255, 0, 0), rgb(255, 100, 100), rgb(255, 0, 0));
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.6), 0 0 30px rgba(255, 0, 0, 0.4);
            z-index: -1;
        }
        
        /* Animated button borders */
        .animated-button {
            position: relative;
            background: rgb(36, 36, 36);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            isolation: isolate;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 48px;
        }
        .animated-button::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(36, 36, 36);
            z-index: -1;
        }
        
        /* Add Expense: purple and cyan */
        .animated-button-add::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(186, 66, 255), rgb(0, 225, 255), rgb(186, 66, 255));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Save Draft: black and grey */
        .animated-button-draft::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(128, 128, 128), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Submit: black and green */
        .animated-button-submit::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(0, 255, 0), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Discard: red and black */
        .animated-button-discard::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(255, 0, 0), rgb(0, 0, 0), rgb(255, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Save Expense: green and black (same as submit) */
        .animated-button-save::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 255, 0), rgb(0, 0, 0), rgb(0, 255, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Expense Modal: purple and cyan */
        .animated-border-expense-modal {
            position: relative;
            background: #1a1f24;
            border-radius: 1rem;
            isolation: isolate;
        }
        .animated-border-expense-modal::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            background: #1a1f24;
            z-index: -1;
        }
        .animated-border-expense-modal::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(186, 66, 255), rgb(0, 225, 255), rgb(186, 66, 255));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Circular animated buttons */
        .spinner-wrapper {
            width: 56px;
            height: 56px;
            position: relative;
        }
        .spinner {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner-green {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner-green::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(0, 255, 0) 35%, rgb(0, 200, 0));
            box-shadow: 0px -5px 20px 0px rgb(0, 255, 0), 0px 5px 20px 0px rgb(0, 200, 0);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 44px;
            height: 44px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        .spinner-icon {
            position: relative;
            z-index: 3;
            color: white;
            font-size: 1.875rem;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            filter: none !important;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="bg-black text-white min-h-screen">

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black flex items-center justify-center z-[9999]">
        <div class="text-center">
            <div class="spinner-wrapper mx-auto mb-4">
                <div class="spinner"></div>
                <div class="spinner1"></div>
            </div>
            <p class="text-gray-400">Loading your expenses...</p>
        </div>
    </div>

    <!-- Upload Banner (shown when uploading) -->
    <div id="uploadBanner" class="hidden fixed top-0 left-0 right-0 bg-orange-600 text-white z-[100] shadow-lg">
        <div class="flex items-center justify-center gap-3 px-4 py-2">
            <span class="material-symbols-outlined animate-pulse">cloud_upload</span>
            <div class="flex flex-col items-center flex-1">
                <span id="uploadBannerText" class="font-semibold text-sm">Uploading expenses...</span>
                <span id="uploadBannerSubtitle" class="text-xs opacity-90">Uploading photos...</span>
                <!-- Progress bar -->
                <div id="uploadProgressBar" class="w-full max-w-xs mt-2 h-1.5 bg-white bg-opacity-20 rounded-full overflow-hidden">
                    <div id="uploadProgressFill" class="h-full bg-white transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Top Navigation -->
    <div id="topNav" class="bg-black border-b border-gray-800 sticky top-0 z-50 hidden">
        <div class="flex items-center justify-between px-4 py-3">
            <button onclick="goToPortal()" class="touch-target">
                <div class="spinner-wrapper">
                    <div class="spinner"></div>
                    <div class="spinner1">
                        <span class="material-symbols-outlined spinner-icon">arrow_back</span>
                    </div>
                </div>
            </button>
            <div class="flex items-center gap-3">
                <h1 class="text-xl font-semibold">My Expenses</h1>
            </div>
            <button onclick="window.location.href='/pages/driver-paid-expenses.html'" class="touch-target">
                <div class="spinner-wrapper">
                    <div class="spinner-green"></div>
                    <div class="spinner1">
                        <span class="material-symbols-outlined spinner-icon">task_alt</span>
                    </div>
                </div>
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <div id="mainContent" class="container max-w-2xl mx-auto px-4 py-6 pb-24 hidden">
        
        <!-- Empty State -->
        <div id="emptyState" class="hidden text-center py-16">
            <span class="material-symbols-outlined text-6xl text-gray-600 mb-4">receipt_long</span>
            <p class="text-gray-400 text-lg mb-6">No expense batches yet</p>
            <p class="text-gray-500 text-sm mb-8">Create your first expense batch to get started</p>
        </div>

        <!-- Returned Batches Section -->
        <div id="returnedSection" class="hidden mb-6">
            <h2 class="text-sm font-bold text-red-500 mb-3 px-1">RETURNED FOR REVIEW</h2>
            <div id="returnedBatches" class="space-y-3"></div>
        </div>

        <!-- Draft Batches Section -->
        <div id="draftSection" class="hidden mb-6">
            <h2 class="text-sm font-bold text-gray-500 mb-3 px-1">DRAFTS</h2>
            <div id="draftBatches" class="space-y-3"></div>
        </div>

        <!-- Pending Batches Section -->
        <div id="pendingSection" class="hidden mb-6">
            <h2 class="text-sm font-bold text-orange-500 mb-3 px-1">PENDING VALIDATION</h2>
            <div id="pendingBatches" class="space-y-3"></div>
        </div>

        <!-- Validated Batches Section -->
        <div id="validatedSection" class="hidden mb-6">
            <h2 class="text-sm font-bold text-green-500 mb-3 px-1">VALIDATED</h2>
            <div id="validatedBatches" class="space-y-3"></div>
        </div>

        <!-- Paid Batches Section -->
        <div id="paidSection" class="hidden mb-6">
            <h2 class="text-sm font-bold text-green-500 mb-3 px-1">PAID</h2>
            <div id="paidBatches" class="space-y-3"></div>
        </div>

    </div>

    <!-- Floating Add Button -->
    <button onclick="createNewBatch()" class="fixed bottom-6 right-6 z-40">
        <div class="spinner-wrapper">
            <div class="spinner"></div>
            <div class="spinner1">
                <span class="material-symbols-outlined spinner-icon">add</span>
            </div>
        </div>
    </button>

    <!-- Batch Detail Modal: a few mm below status bar, grey border, only modal scrolls (body locked) -->
    <div id="batchModal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 overflow-hidden">
        <div class="min-h-full min-h-screen px-4 flex items-start justify-center pt-[calc(env(safe-area-inset-top)+10px)] pb-6 sm:pt-[calc(env(safe-area-inset-top)+14px)] sm:pb-8">
            <div id="batchModalContent" class="bg-[#1a1f24] rounded-2xl w-full max-w-2xl transform transition-all animated-border-modal border border-gray-600 max-h-[calc(100vh-env(safe-area-inset-top)-2rem)] flex flex-col overflow-hidden">
                
                <!-- Modal Header -->
                <div class="sticky top-0 bg-[#1a1f24] border-b border-gray-800 rounded-t-2xl z-10">
                <div class="flex items-center justify-between px-6 py-4">
                <h2 id="modalTitle" class="text-lg font-semibold px-4 py-2 rounded-lg border">DRAFT</h2>
                <div class="flex gap-2">
                <button id="deleteBatchBtn" onclick="deleteBatch()" class="touch-target text-red-500 hover:text-red-400 transition-colors hidden">
                <span class="material-symbols-outlined">delete</span>
                </button>
                <button id="closeBatchModalBtn" onclick="closeBatchModal()" class="touch-target text-gray-400 hover:text-white transition-colors">
                <span class="material-symbols-outlined">close</span>
                </button>
                </div>
                </div>
                </div>

                <!-- Modal Content (scrolls when many expenses) -->
                <div class="p-6 pb-24 flex-1 min-h-0 overflow-y-auto">
                
                <!-- Registration Input -->
                <div class="mb-6">
                <label class="text-sm text-gray-400 mb-2 block">REGISTRATION</label>
                <input 
                type="text" 
                id="regInput" 
                placeholder="AB12 CDE"
                class="w-full bg-[#283039] text-white text-xl font-mono text-center uppercase px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none"
                maxlength="8"
                >
                </div>

                <!-- Communications Thread (if returned) -->
                <div id="communicationsSection" class="hidden mb-6">
                <label class="text-sm text-gray-400 mb-2 block">COMMUNICATIONS</label>
                <div id="communicationsList" class="space-y-3 rounded-lg border border-gray-700 p-4 bg-[#1a1f24]"></div>
                </div>

                <!-- Lines (merged: trains, taxis, fuels, etc.) -->
                <div class="mb-6">
                <div class="flex items-center justify-between mb-3">
                <label class="text-sm text-gray-400">EXPENSES</label>
                <span id="totalAmount" class="text-lg font-semibold text-green-500">¬£0.00</span>
                </div>
                <div id="linesContainer" class="space-y-4">
                <!-- Variable list of added expenses, rendered by renderLines() -->
                </div>
                <input type="file" id="linePhotoInput" accept="image/*" capture="environment" class="hidden" onchange="onLinePhotoSelected(event)">
                <div id="expensesList" class="hidden"></div>
                <button id="addExpenseBtn" onclick="addExpense()" class="hidden mt-3 w-full py-3 bg-[#283039] hover:bg-[#3a4552] text-white rounded-lg border border-dashed border-gray-600 flex items-center justify-center gap-2 touch-target transition-colors">
                <span class="material-symbols-outlined">add</span>
                <span>Add expense</span>
                </button>
                </div>

                <!-- Notes Section -->
                <div id="notesSection" class="mb-6">
                <label id="notesLabel" class="text-sm text-gray-400 mb-2 block">NOTES (Optional)</label>
                <textarea 
                id="notesInput" 
                placeholder="Add any additional notes..."
                class="w-full bg-[#283039] text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none resize-none"
                rows="3"
                ></textarea>
                </div>

                <!-- Action Buttons -->
                <div class="space-y-3" id="actionButtons">
                <button onclick="saveDraft()" class="w-full animated-button animated-button-draft touch-target">
                <span class="text-white font-semibold">Save as Draft</span>
                </button>
                <button id="submitBtn" onclick="submitBatch()" class="w-full animated-button animated-button-submit touch-target">
                <span class="text-white font-semibold">Submit for Processing</span>
                </button>
                </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Add Expense Modal -->
    <div id="expenseModal" class="hidden fixed inset-0 bg-black bg-opacity-95 z-50 overflow-y-auto">
        <div class="min-h-screen px-4 flex items-end sm:items-center justify-center">
            <div id="expenseModalContent" class="bg-[#1a1f24] rounded-2xl w-full max-w-lg transform transition-all">
                
                <!-- Modal Header -->
                <div class="sticky top-0 bg-[#1a1f24] border-b border-gray-800 rounded-t-2xl z-10">
                <div class="flex items-center justify-between px-6 py-4">
                <button onclick="closeExpenseModal()" class="touch-target text-gray-400 hover:text-white transition-colors">
                <span class="material-symbols-outlined">close</span>
                </button>
                <h2 class="text-lg font-semibold">Add Expense</h2>
                <div class="w-10"></div>
                </div>
                </div>

                <!-- Modal Content -->
                <div class="p-6 pb-24">
                
                <!-- Category Selection -->
                <div id="categorySection" class="mb-6">
                <label class="text-sm text-gray-400 mb-3 block">CATEGORY</label>
                <div class="grid grid-cols-2 gap-3">
                <button onclick="selectCategory('Fuel')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">‚õΩ</span>
                <span class="text-sm">Fuel</span>
                </button>
                <button onclick="selectCategory('Charge')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üîå</span>
                <span class="text-sm">Charge</span>
                </button>
                <button onclick="selectCategory('Train')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üöÇ</span>
                <span class="text-sm">Train</span>
                </button>
                <button onclick="selectCategory('Bus')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üöå</span>
                <span class="text-sm">Bus</span>
                </button>
                <button onclick="selectCategory('Taxi')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üöï</span>
                <span class="text-sm">Taxi</span>
                </button>
                <button onclick="selectCategory('Car Wash')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üßº</span>
                <span class="text-sm">Car Wash</span>
                </button>
                <button onclick="selectCategory('Tolls')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üõ£Ô∏è</span>
                <span class="text-sm">Tolls</span>
                </button>
                <button onclick="selectCategory('Other')" class="category-btn p-4 bg-[#283039] hover:bg-[#3a4552] rounded-lg transition-colors flex flex-col items-center gap-2">
                <span class="text-3xl">üìù</span>
                <span class="text-sm">Other</span>
                </button>
                </div>
                </div>

                <!-- Amount Input -->
                <div class="mb-6">
                <label class="text-sm text-gray-400 mb-2 block">AMOUNT (¬£)</label>
                <input 
                type="number" 
                id="amountInput" 
                placeholder="0.00"
                step="0.01"
                min="0"
                inputmode="decimal"
                pattern="[0-9]*"
                class="w-full bg-[#283039] text-white text-2xl text-center px-4 py-4 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none"
                >
                </div>

                <!-- Photo Upload -->
                <div class="mb-6">
                <label class="text-sm text-gray-400 mb-2 block">RECEIPT PHOTOS (Optional)</label>
                <!-- Hidden file inputs - one for camera, one for gallery -->
                <input 
                type="file" 
                id="photoInputCamera" 
                accept="image/*"
                multiple
                capture="environment"
                class="hidden"
                onchange="handlePhotoSelect(event)"
                >
                <input 
                type="file" 
                id="photoInputGallery" 
                accept="image/*"
                multiple
                class="hidden"
                onchange="handlePhotoSelect(event)"
                >
                <button onclick="openPhotoPicker()" class="w-full py-3 bg-[#283039] hover:bg-[#3a4552] text-white rounded-lg transition-colors flex items-center justify-center gap-2 touch-target border border-dashed border-gray-600">
                <span class="material-symbols-outlined">add_a_photo</span>
                Add Photos
                </button>
                <div id="photoPreview" class="mt-3 grid grid-cols-3 gap-2">
                    <!-- Photos will be rendered here with click-to-expand functionality -->
                </div>
                </div>

                <!-- Save Button -->
                <button id="saveExpenseBtn" onclick="saveExpense()" class="w-full animated-button animated-button-save touch-target">
                <span class="text-white font-semibold">Save Expense</span>
                </button>

                </div>
            </div>
        </div>
    </div>

    <!-- Thumbnail gallery modal (larger thumbs, click one ‚Üí fullscreen) -->
    <div id="linePhotoGalleryModal" class="hidden fixed inset-0 z-[60]" style="background: rgba(0,0,0,0.92);">
        <div class="w-full h-full flex flex-col">
            <div class="flex justify-end p-3">
                <button type="button" onclick="closeLinePhotoGallery()" class="text-white hover:text-gray-300 p-2 rounded-full hover:bg-white hover:bg-opacity-10 transition-colors" aria-label="Close">
                    <span class="material-symbols-outlined text-3xl">close</span>
                </button>
            </div>
            <div id="linePhotoGalleryThumbs" class="flex-1 overflow-y-auto p-4 flex flex-wrap gap-4 justify-center items-start content-start">
                <!-- Larger thumbnails; click opens fullscreen viewer -->
            </div>
        </div>
    </div>

    <!-- Photo Viewer Modal (fullscreen) -->
    <div id="photoViewerModal" class="hidden fixed inset-0 bg-black bg-opacity-90 z-50">
        <div class="w-full h-full flex flex-col">
            <!-- Header -->
            <div class="flex items-center justify-between px-4 py-3 bg-black bg-opacity-50">
                <button onclick="closePhotoViewer()" class="text-white hover:text-gray-300 transition-colors">
                <span class="material-symbols-outlined">close</span>
                </button>
                <h3 class="text-white font-semibold">View Photos</h3>
                <div class="w-8"></div>
            </div>
            
            <!-- Photo Grid -->
            <div id="photoViewerGrid" class="flex-1 overflow-y-auto p-4">
                <!-- Photos will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Debug Info (hidden by default) -->

    <script>
        // Global variables
        let currentUser = null;
        let currentBatch = null;
        let currentExpense = { category: null, amount: 0, photos: [] };
        let allBatches = [];
        let submissionQueueRetryTimer = null;
        /** Batch IDs that stay greyed out until uploads complete (stops flashing during save/submit). */
        let batchIdsGreyedUntilUploadDone = new Set();

        // Helper function to safely escape HTML for display
        function escapeHtml(s) {
            if (s == null) return '';
            return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        const fallbackDialogs = {
            showAlert({ title, message }) {
                console.warn(`[Dialog:${title}] ${message}`);
            },
            async showConfirmation({ title, message, confirmText }) {
                return window.confirm(`${title || 'Confirm'}\n\n${message || ''}\n\n${confirmText || 'OK'}?`);
            },
        };
        const dialogApi = window.uiDialogs || fallbackDialogs;
        const notifyError = (message, title = 'Error') => dialogApi.showAlert({ title, message, tone: 'danger' });
        const notifyWarning = (message, title = 'Heads Up') => dialogApi.showAlert({ title, message, tone: 'warning' });
        const notifySuccess = (message, title = 'Success') => dialogApi.showAlert({ title, message, tone: 'success' });
        const notifyInfo = (message, title = 'Notice') => dialogApi.showAlert({ title, message, tone: 'info' });
        const EXPENSE_SUBMISSION_QUEUE_KEY = 'expense_submission_queue_v1';
        const MAX_PHOTOS_PER_EXPENSE = 4;

        // Prevent concurrent sync for the same batch (button + processSubmissionQueue race)
        const expenseSyncLocks = new Set();

        function loadSubmissionQueue() {
            try {
                const raw = localStorage.getItem(EXPENSE_SUBMISSION_QUEUE_KEY);
                return raw ? JSON.parse(raw) : [];
            } catch (error) {
                console.error('Error reading expense submission queue:', error);
                return [];
            }
        }

        function saveSubmissionQueue(queue) {
            try {
                localStorage.setItem(EXPENSE_SUBMISSION_QUEUE_KEY, JSON.stringify(queue));
            } catch (error) {
                console.error('Error saving expense submission queue:', error);
            }
        }

        function removeSubmissionQueueEntry(localId) {
            if (!localId) return;
            const queue = loadSubmissionQueue();
            const filtered = queue.filter(entry => entry.localId !== localId);
            if (filtered.length !== queue.length) {
                saveSubmissionQueue(filtered);
            }
        }

        window.getExpenseSubmissionQueueInfo = function() {
            const queue = loadSubmissionQueue();
            return {
                pending: Array.isArray(queue) ? queue.length : 0,
            };
        };

        function ensureSubmissionQueueRetryScheduled() {
            if (submissionQueueRetryTimer) {
                return;
            }
            submissionQueueRetryTimer = setInterval(async () => {
                try {
                const info = window.getExpenseSubmissionQueueInfo ? window.getExpenseSubmissionQueueInfo() : { pending: 0 };
                if (!info || info.pending === 0) {
                clearInterval(submissionQueueRetryTimer);
                submissionQueueRetryTimer = null;
                return;
                }
                if (!navigator.onLine || !currentUser) {
                return;
                }
                console.log('[Expenses] Retrying queued submissions (pending:', info.pending, ')');
                await processSubmissionQueue({ showToast: false });
                } catch (error) {
                console.warn('Error while retrying submission queue:', error);
                }
            }, 8000);
        }

        // Build a sanitized snapshot of the batch for queue storage (supports lines and legacy expenses)
        function buildBatchSnapshot(batch) {
            if (!batch) {
                console.warn('[buildBatchSnapshot] No batch provided');
                return null;
            }
            const hasLines = batch.lines && typeof batch.lines === 'object';
            const lineKeys = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.LINE_KEYS) ? EXPENSE_BATCH_SCHEMA.LINE_KEYS : [];
            const lineCount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(batch) : 0;
            console.log('[buildBatchSnapshot] Building snapshot for batch', { localId: batch.localId, id: batch.id, registration: batch.registration, lineCount });
            
            try {
                const snapshot = {
                    localId: batch.localId,
                    id: batch.id || null,
                    registration: batch.registration || null,
                    driverId: batch.driverId || null,
                    driverEmail: batch.driverEmail || null,
                    driverName: batch.driverName || null,
                    officeId: batch.officeId || null,
                    status: batch.status || 'draft',
                    notes: batch.notes || '',
                    totalAmount: batch.totalAmount || 0,
                    createdAt: batch.createdAt ? (typeof batch.createdAt.toDate === 'function' ? batch.createdAt.toDate().getTime() : batch.createdAt) : null,
                    updatedAt: batch.updatedAt ? (typeof batch.updatedAt.toDate === 'function' ? batch.updatedAt.toDate().getTime() : batch.updatedAt) : Date.now(),
                    submittedAt: batch.submittedAt ? (typeof batch.submittedAt.toDate === 'function' ? batch.submittedAt.toDate().getTime() : batch.submittedAt) : null
                };
                if (hasLines && lineKeys.length) {
                    snapshot.lines = {};
                    lineKeys.forEach(k => {
                        const line = batch.lines[k];
                        if (line) {
                            snapshot.lines[k] = {
                                amount: typeof line.amount === 'number' ? line.amount : 0,
                                photos: (line.photos || []).filter(p => typeof p === 'string')
                            };
                        }
                    });
                }
                console.log('[buildBatchSnapshot] Snapshot created', { lineKeys: snapshot.lines ? Object.keys(snapshot.lines).length : 0 });
                return snapshot;
            } catch (error) {
                console.error('[buildBatchSnapshot] Error building snapshot:', error);
                return null;
            }
        }

        async function queueExpenseAction(targetStatus) {
            if (!currentBatch) {
                console.warn('[queueExpenseAction] No currentBatch available');
                return null;
            }
            const usedCount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(currentBatch) : 0;
            console.log('[queueExpenseAction] Queueing batch for', targetStatus, { localId: currentBatch.localId, usedCount });
            
            currentBatch.status = targetStatus;
            if (window.autoSaveDraft) {
                await window.autoSaveDraft();
            }
            const localId = currentBatch.localId;
            if (!localId) {
                console.warn('[queueExpenseAction] Unable to queue expense action: missing localId.');
                return null;
            }
            const queue = loadSubmissionQueue();
            const entry = {
                localId,
                status: targetStatus,
                timestamp: Date.now(),
                registration: currentBatch.registration ? currentBatch.registration : null,
                snapshot: null
            };
            try {
                const snapshot = buildBatchSnapshot(currentBatch);
                if (snapshot) {
                entry.snapshot = JSON.stringify(snapshot);
                console.log('[queueExpenseAction] Snapshot serialized', snapshot.lines ? { lines: Object.keys(snapshot.lines).length } : {});
                } else {
                console.warn('[queueExpenseAction] Failed to build snapshot');
                }
            } catch (error) {
                console.error('[queueExpenseAction] Unable to serialize batch snapshot for queue entry:', error);
            }
            const existingIndex = queue.findIndex(item => item.localId === localId);
            if (existingIndex >= 0) {
                queue[existingIndex] = entry;
            } else {
                queue.push(entry);
            }
            saveSubmissionQueue(queue);
            console.log(`Queued expense batch ${localId} for ${targetStatus} sync when online.`);

            // Update upload status using new ExpenseUploadQueue
            if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                try {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
                } catch (error) {
                console.warn('Unable to refresh upload indicator after queue update:', error);
                }
            }

            ensureSubmissionQueueRetryScheduled();

            return localId;
        }

        /**
         * Update only batch document to 'pending' (no saveExpenses).
         * Use when batch and expenses were just created in same flow (e.g. submit without draft first).
         */
        async function updateBatchStatusToPending(batchId, draft) {
            if (!batchId || !draft) {
                throw new Error('Batch ID and draft required to update status.');
            }
            const totalAmount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getTotalFromLines && draft.lines) ? EXPENSE_BATCH_SCHEMA.getTotalFromLines(draft.lines) : 0;
            const updateData = {
                status: 'pending',
                submittedAt: window.serverTimestamp(),
                updatedAt: window.serverTimestamp(),
                totalAmount,
                notes: draft.notes || ''
            };
            await window.updateDoc(window.doc(window.db, 'expenseBatches', batchId), updateData);
            draft.status = 'pending';
            draft.submittedAt = Date.now();
            draft.totalAmount = totalAmount;
            draft.updatedAt = Date.now();
            try {
                await window.expenseDraftDB.saveDraft(draft);
            } catch (e) {
                console.warn('Unable to store draft snapshot locally:', e);
            }
            removeSubmissionQueueEntry(draft.localId);
        }

        async function syncDraftToFirestore(draft, targetStatus) {
            const usedLineCount = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLineCount && draft?.lines) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(draft) : 0;
            console.log('[syncDraftToFirestore] Starting sync', { targetStatus, hasDraft: !!draft, draftId: draft?.id, localId: draft?.localId, usedLineCount });
            
            if (!draft) {
                throw new Error('No draft provided for sync.');
            }
            const syncKey = draft.localId || draft.id || 'unknown';
            if (expenseSyncLocks.has(syncKey)) {
                console.warn('[syncDraftToFirestore] Sync already in progress for', syncKey, '- skipping to prevent duplicate expenses.');
                throw new Error('Sync already in progress for this batch. Please wait.');
            }
            expenseSyncLocks.add(syncKey);
            try {
                return await syncDraftToFirestoreImpl(draft, targetStatus);
            } finally {
                expenseSyncLocks.delete(syncKey);
            }
        }

        async function syncDraftToFirestoreImpl(draft, targetStatus) {
            const driverId = draft.driverId || (currentUser && currentUser.uid);
            const officeId = draft.officeId || (currentUser && currentUser.officeId);
            if (!driverId || !officeId) {
                throw new Error('Missing driver or office context for expense sync.');
            }

            let registration = (draft.registration || '').trim().toUpperCase();
            if (!registration) {
                throw new Error('Registration is required to sync.');
            }

            // CRITICAL FIX: Check if batch with this localId already exists to prevent duplicates
            // Store localId in batch document to track duplicates of the SAME draft
            let batchId = draft.id;
            let existingBatch = null;
            
            if (!batchId && draft.localId) {
                // Check if a batch with this localId already exists (prevent duplicate creation)
                const batchesQuery = window.query(
                    window.collection(window.db, 'expenseBatches'),
                    window.where('officeId', '==', officeId),
                    window.where('driverId', '==', driverId),
                    window.orderBy('updatedAt', 'desc'),
                    window.limit(50)
                );
                const batchesSnapshot = await window.getDocs(batchesQuery);
                
                // Look for batch with matching localId (stored in batch document)
                for (const doc of batchesSnapshot.docs) {
                    const data = doc.data();
                    // Check if this batch was created from the same localId (same draft)
                    if (data.localId === draft.localId) {
                        console.log('[syncDraftToFirestore] Found existing batch with same localId:', doc.id);
                        existingBatch = { id: doc.id, ...data };
                        batchId = doc.id;
                        draft.id = batchId;
                        break;
                    }
                }
            }

            // Only check for unique registration when creating NEW batches (no ID and no existing batch found)
            // For existing batches (has ID), just normalize the registration
            if (!batchId) {
                registration = await getUniqueReg(registration);
            } else {
                // Existing batch - just normalize, don't change to add "!"
                registration = normalizeReg(registration);
            }

            draft.registration = registration;
            
            const LINE_KEYS = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.LINE_KEYS) ? EXPENSE_BATCH_SCHEMA.LINE_KEYS : [];
            const getTotalFromLines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getTotalFromLines) ? EXPENSE_BATCH_SCHEMA.getTotalFromLines : (() => 0);
            const getUsedLineCount = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount : (() => 0);
            const hasLineContent = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.hasLineContent) ? EXPENSE_BATCH_SCHEMA.hasLineContent : (() => false);
            const normalizeLines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.normalizeLines) ? EXPENSE_BATCH_SCHEMA.normalizeLines : (l) => l || {};

            if (!draft.lines || typeof draft.lines !== 'object') {
                draft.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
            }
            // Collect photo blobs per line BEFORE normalizeLines (normalizeLines strips blobs and keeps only URL strings)
            const photoBlobsByLineKey = {};
            LINE_KEYS.forEach(k => {
                const line = draft.lines[k];
                if (!line || !hasLineContent(line)) return;
                const blobs = (line.photos || []).filter(p => p instanceof File || p instanceof Blob);
                if (blobs.length > 0) photoBlobsByLineKey[k] = blobs;
            });
            draft.lines = normalizeLines(draft.lines);
            if (targetStatus === 'pending' && getUsedLineCount(draft) === 0) {
                throw new Error('Cannot submit batch with no expenses. Add at least one expense.');
            }

            const totalAmount = getTotalFromLines(draft.lines);
            console.log('[syncDraftToFirestore] totalAmount:', totalAmount, '(from lines)');
            const driverName =
                draft.driverName ||
                currentUser?.name ||
                `${currentUser?.firstName || ''} ${currentUser?.lastName || ''}`.trim() ||
                'Unknown Driver';
            const driverEmail = draft.driverEmail || currentUser?.email || '';

            const batchData = {
                driverId,
                driverEmail,
                driverName,
                officeId,
                registration,
                status: targetStatus,
                totalAmount,
                notes: draft.notes || '',
                updatedAt: window.serverTimestamp()
            };
            if (draft.localId) batchData.localId = draft.localId;
            if (targetStatus === 'pending' && !draft.submittedAt) {
                batchData.submittedAt = window.serverTimestamp();
                draft.submittedAt = Date.now();
            }
            // Communications thread: driver first notes (new batch) or appeal message (existing batch)
            // Use client timestamp: serverTimestamp() is not allowed inside arrayUnion()
            if (targetStatus === 'pending' && (draft.notes || '').trim()) {
                const commEntry = { from: 'driver', authorName: driverName, message: (draft.notes || '').trim(), createdAt: Date.now() };
                if (!batchId) {
                    batchData.communications = [commEntry];
                } else {
                    batchData.communications = window.arrayUnion(commEntry);
                }
            }

            // Single structure: batch doc contains lines only (no separate expenses collection)
            if (!draft.lines || typeof draft.lines !== 'object') {
                draft.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
            }
            const linesForFirestore = {};
            LINE_KEYS.forEach(k => {
                const line = draft.lines[k];
                if (!line) return;
                const urls = (line.photos || []).filter(p => typeof p === 'string');
                const hasBlobsPending = !!(photoBlobsByLineKey[k] && photoBlobsByLineKey[k].length > 0);
                linesForFirestore[k] = { amount: typeof line.amount === 'number' ? line.amount : 0, photos: urls, photosUploading: hasBlobsPending };
            });
            batchData.lines = linesForFirestore;
            if (!batchId) {
                batchData.createdAt = window.serverTimestamp();
                const batchRef = await window.addDoc(window.collection(window.db, 'expenseBatches'), batchData);
                batchId = batchRef.id;
                draft.id = batchId;
                console.log('[syncDraftToFirestore] Created batch with lines:', batchId);
            } else {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', batchId), batchData);
                console.log('[syncDraftToFirestore] Updated batch with lines:', batchId);
            }
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            if (!isLocalhost && window.expenseUploadQueue) {
                const reg = (draft.registration || '').trim();
                const submissionDate = targetStatus === 'pending' ? (() => {
                    const d = draft.submittedAt ? new Date(typeof draft.submittedAt.toDate === 'function' ? draft.submittedAt.toDate() : draft.submittedAt) : new Date();
                    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
                })() : null;
                for (const k of LINE_KEYS) {
                    const photoBlobs = photoBlobsByLineKey[k];
                    if (!photoBlobs || photoBlobs.length === 0) continue;
                    const line = draft.lines[k];
                    const amount = line && typeof line.amount === 'number' ? line.amount : 0;
                    try {
                        await window.expenseUploadQueue.enqueueExpenseUpload(batchId, k, { amount, registration: reg, targetStatus, submissionDate }, photoBlobs);
                    } catch (e) {
                        console.error('[syncDraftToFirestore] Failed to enqueue photo upload for line', k, e);
                    }
                }
                if (typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                    await window.expenseUploadQueue.updateGlobalUploadStatus();
                }
                // Trigger Service Worker to process uploads immediately (otherwise they only run on 30s timer or page load)
                if (navigator.onLine && typeof window.expenseUploadQueue.getAuthTokenAndProcessQueue === 'function') {
                    await window.expenseUploadQueue.getAuthTokenAndProcessQueue();
                }
            }

            draft.status = targetStatus;
            draft.driverId = driverId;
            draft.officeId = officeId;
            draft.driverName = driverName;
            draft.driverEmail = driverEmail;
            draft.totalAmount = totalAmount;
            draft.updatedAt = Date.now();
            if (draft.submittedAt && typeof draft.submittedAt.toDate === 'function') {
                draft.submittedAt = draft.submittedAt.toDate().getTime();
            }
            try {
                await window.expenseDraftDB.saveDraft(draft);
            } catch (storageError) {
                console.warn('Unable to store draft snapshot locally:', storageError);
            }

            removeSubmissionQueueEntry(draft.localId);

            return draft;
        }

        async function processSubmissionQueue(options = {}) {
            const { showToast = true } = options;
            if (processSubmissionQueue.isRunning) {
                return;
            }
            processSubmissionQueue.isRunning = true;
            try {
                if (!navigator.onLine || !currentUser) {
                return;
                }
                const queue = loadSubmissionQueue();
                if (!queue.length) {
                return;
                }
                console.log('Processing queued expense submissions:', queue.length);
                const remaining = [];
                let processed = 0;
                let registrationErrorNotified = false;

                for (const entry of queue) {
                try {
                // CRITICAL FIX: Check if this entry is already being processed or was already processed
                // Prevent duplicate processing of the same localId
                const processingKey = `processing_${entry.localId}`;
                if (sessionStorage.getItem(processingKey)) {
                    console.log('[processSubmissionQueue] Entry already being processed, skipping:', entry.localId);
                    remaining.push(entry); // Keep in queue but skip for now
                    continue;
                }
                
                // Mark as processing
                sessionStorage.setItem(processingKey, Date.now().toString());
                
                let draft = null;
                let draftFromIndexedDB = false;
                try {
                draft = await window.expenseDraftDB.getDraft(entry.localId);
                if (draft) draftFromIndexedDB = true;
                } catch (dbError) {
                console.warn('Failed to read draft from IndexedDB, falling back to snapshot:', dbError);
                }

                let snapshot = null;
                if (entry.snapshot) {
                try {
                snapshot = JSON.parse(entry.snapshot);
                } catch (parseError) {
                console.warn('Failed to parse queued snapshot:', parseError);
                }
                }

                if (!draft && snapshot) {
                console.log('[processSubmissionQueue] Using snapshot as draft (IndexedDB draft not found)');
                draft = snapshot;
                }

                if (!draft) {
                console.warn('[processSubmissionQueue] Draft not found for queued submission:', entry.localId);
                sessionStorage.removeItem(processingKey); // Clear processing flag
                continue;
                }

                draft.localId = draft.localId || entry.localId;
                draft.registration = draft.registration || snapshot?.registration || entry.registration || null;
                draft.driverId = draft.driverId || snapshot?.driverId || currentUser?.uid || null;
                draft.officeId = draft.officeId || snapshot?.officeId || currentUser?.officeId || null;
                draft.notes = draft.notes || snapshot?.notes || '';
                draft.totalAmount = draft.totalAmount != null ? Number(draft.totalAmount) : (snapshot?.totalAmount != null ? Number(snapshot.totalAmount) : null);

                // Only use snapshot.lines when we have no IndexedDB draft (snapshot has no photo blobs).
                // When draftFromIndexedDB, draft.lines already has blobs ‚Äî do NOT overwrite or we lose photos for upload.
                if (snapshot?.lines && typeof snapshot.lines === 'object' && !draftFromIndexedDB) {
                    draft.lines = snapshot.lines;
                    if (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.normalizeLines) draft.lines = EXPENSE_BATCH_SCHEMA.normalizeLines(draft.lines);
                }
                if (!draft.lines || typeof draft.lines !== 'object') {
                    draft.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
                }
                // Do not normalize draft.lines when from IndexedDB ‚Äî it would strip photo blobs; syncDraftToFirestore handles shape

                if ((!draft.registration || draft.registration.trim() === '') && entry.registration) {
                    draft.registration = entry.registration;
                }

                const usedLineCount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(draft) : 0;
                if (entry.status === 'pending' && usedLineCount === 0) {
                    console.warn('[processSubmissionQueue] Skipping submit: draft has no used lines', entry.localId);
                    sessionStorage.removeItem(processingKey);
                    remaining.push(entry);
                    continue;
                }

                console.log('[processSubmissionQueue] Persisting draft to Firestore', { registration: draft.registration, status: draft.status, usedLineCount });

                await syncDraftToFirestore(draft, entry.status);
                console.log('[processSubmissionQueue] Successfully synced draft', entry.localId);
                processed++;
                // Clear processing flag on success
                sessionStorage.removeItem(processingKey);
                } catch (error) {
                console.error('Error syncing queued expense submission:', entry, error);
                // Clear processing flag on error so it can be retried (use entry.localId ‚Äî processingKey is try-scoped)
                if (entry && entry.localId) {
                    sessionStorage.removeItem(`processing_${entry.localId}`);
                }
                const needsRegistration = error && typeof error.message === 'string' && error.message.includes('Registration is required');
                if (needsRegistration && (!entry.registration || entry.registration.trim() === '')) {
                console.warn('Discarding queued submission with no registration. User must re-open and save the draft.', entry);
                if (!registrationErrorNotified) {
                notifyWarning('One queued expense was missing its registration and could not upload. Please open the draft, confirm the registration, and save again.', 'Action needed');
                registrationErrorNotified = true;
                }
                continue;
                }
                remaining.push(entry);
                }
                }

                saveSubmissionQueue(remaining);

                if (processed > 0) {
                await loadExpenseBatches();
                if (showToast) {
                notifySuccess(
                `${processed} expense batch${processed === 1 ? '' : 'es'} synced successfully.`,
                'Back Online'
                );
                }
                }

                if (remaining.length > 0) {
                console.warn('Some expense submissions could not sync and remain queued.');
                }

                // Update upload status using new ExpenseUploadQueue
                if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
                }

                const info = window.getExpenseSubmissionQueueInfo ? window.getExpenseSubmissionQueueInfo() : { pending: 0 };
                if (!info || info.pending === 0) {
                if (submissionQueueRetryTimer) {
                clearInterval(submissionQueueRetryTimer);
                submissionQueueRetryTimer = null;
                }
                
                // If queue is empty and uploads are complete, refresh the list
                // Small delay to ensure Firestore has propagated
                setTimeout(async () => {
                    try {
                        await loadExpenseBatches();
                    } catch (error) {
                        console.error('Error refreshing expense list after queue completion:', error);
                    }
                }, 500);
                } else {
                ensureSubmissionQueueRetryScheduled();
                }
            } finally {
                processSubmissionQueue.isRunning = false;
            }
        }

        window.processExpenseSubmissionQueue = processSubmissionQueue;
        window.addEventListener('online', () => processSubmissionQueue({ showToast: true }));
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && navigator.onLine) {
                processSubmissionQueue({ showToast: false });
            }
        });

        // Initialize function
        async function initializeDriverExpensesApp() {
            console.log('Initializing driver expenses app...');
            const overlay = document.getElementById('loadingOverlay');
            try {
                const session = await window.sotoSession.bootstrap(['driver']);
                if (!session) {
                window.location.href = '/pages/soto-routes-login.html';
                return;
                }

                currentUser = { uid: session.uid, ...session };
                window.currentUser = currentUser;
                window.__driverExpensesDebug = { step: 'session-loaded', currentUser };
                if (overlay) {
                overlay.setAttribute('data-step', 'session-loaded');
                }
            } catch (error) {
                console.error('Unable to establish session for driver expenses:', error);
                window.location.href = '/pages/soto-routes-login.html';
                return;
                }

             console.log('Loading user data for:', currentUser.uid);
                try {
                const userDoc = await window.getDoc(window.doc(window.db, 'users', currentUser.uid));
                if (!userDoc.exists()) {
                console.error('User document not found. Signing out and redirecting.');
                await window.signOut(window.auth);
                window.location.href = '/pages/soto-routes-login.html';
                return;
                }

                currentUser = { ...currentUser, ...userDoc.data() };
                window.currentUser = currentUser;

                console.log('Loading expense batches...');
                window.__driverExpensesDebug.step = 'before-load-batches';
                if (overlay) {
                overlay.setAttribute('data-step', 'before-load-batches');
                }
                await loadExpenseBatches();
                
                // Hide loading overlay and show content
                const loadingOverlay = document.getElementById('loadingOverlay');
                const topNav = document.getElementById('topNav');
                const mainContent = document.getElementById('mainContent');
                
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                if (topNav) {
                    topNav.classList.remove('hidden');
                }
                if (mainContent) {
                    mainContent.classList.remove('hidden');
                }
                
                console.log('Loading complete!');
                window.__driverExpensesDebug.step = 'after-load-batches';
                if (overlay) {
                overlay.setAttribute('data-step', 'after-load-batches');
                }
                
                // Service Worker handles uploads in background - just update status
                if (window.expenseUploadQueue) {
                    await window.expenseUploadQueue.updateGlobalUploadStatus();
                    
                    // Trigger Service Worker to process any pending uploads
                    if (navigator.onLine) {
                        await window.expenseUploadQueue.getAuthTokenAndProcessQueue();
                    }
                
                // Set up periodic status updates while uploading (only when not typing)
                    // Note: Service Worker handles actual uploads, this just updates UI
                if (window.uploadStatusCheckInterval) {
                    clearInterval(window.uploadStatusCheckInterval);
                }
                window.uploadStatusCheckInterval = setInterval(async () => {
                    // Skip update if user is actively typing to prevent keyboard from closing
                        if (!window.isUserTyping && window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                            await window.expenseUploadQueue.updateGlobalUploadStatus();
                    }
                }, 3000); // Check every 3 seconds (less frequent to avoid interference)
                }
                } catch (error) {
                console.error('Error loading user data:', error);
                notifyError('Error loading user data. Please try again.');
                
                // Still show content even if there's an error
                const loadingOverlay = document.getElementById('loadingOverlay');
                const topNav = document.getElementById('topNav');
                const mainContent = document.getElementById('mainContent');
                
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
                if (topNav) {
                    topNav.classList.remove('hidden');
                }
                if (mainContent) {
                    mainContent.classList.remove('hidden');
                }
                }
        }

        console.log('Driver expenses script loaded');
        console.log('Document readyState:', document.readyState);
        console.log('sotoSession available:', typeof window.sotoSession !== 'undefined');
        
        // Track if user is actively typing to prevent keyboard from closing
        window.isUserTyping = false;
        let typingTimeout = null;
        
        // Monitor all input fields for typing activity
        document.addEventListener('focusin', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                window.isUserTyping = true;
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    window.isUserTyping = false;
                }, 2000); // Consider typing stopped after 2 seconds of inactivity
            }
        });
        
        document.addEventListener('focusout', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    window.isUserTyping = false;
                }, 500); // Small delay to allow for tabbing between fields
            }
        });
        
        // Also track keydown events
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                window.isUserTyping = true;
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    window.isUserTyping = false;
                }, 2000);
            }
        });
        
        // Also track input events (for mobile)
        document.addEventListener('input', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                window.isUserTyping = true;
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    window.isUserTyping = false;
                }, 2000);
            }
        });
        
        const debugInit = (label, error) => {
            const overlay = document.getElementById('loadingOverlay');
            if (overlay) {
                overlay.setAttribute('data-step', label);
            }
            // Debug info removed - check console for details
        };

        const runDriverExpensesInit = () => {
            console.log('runDriverExpensesInit called');
            if (!window.sotoSession) {
                console.warn('sotoSession not available yet, waiting...');
                setTimeout(() => {
                if (window.sotoSession) {
                console.log('sotoSession now available, initializing...');
                runDriverExpensesInit();
                } else {
                console.error('sotoSession still not available after wait');
                debugInit('init-failed', 'session-manager.js not loaded');
                }
                }, 500);
                return;
            }
            console.log('Starting initializeDriverExpensesApp...');
            initializeDriverExpensesApp()
                .then(() => {
                console.log('initializeDriverExpensesApp completed successfully');
                debugInit('init-complete');
                })
                .catch((error) => {
                console.error('Failed to initialize driver expenses:', error);
                console.error('Error stack:', error.stack);
                notifyError('Unable to load expenses. Please refresh.');
                window.__driverExpensesDebug = { step: 'init-failed', error: error?.message || error };
                debugInit('init-failed', error?.message || error);
                });
        };

        console.log('Setting up initialization...');
        if (document.readyState === 'loading') {
            console.log('DOM still loading, waiting for DOMContentLoaded...');
            window.addEventListener('DOMContentLoaded', () => {
                console.log('DOMContentLoaded fired, calling runDriverExpensesInit');
                runDriverExpensesInit();
            }, { once: true });
        } else {
            console.log('DOM already loaded, calling runDriverExpensesInit immediately');
            runDriverExpensesInit();
        }

        window.addEventListener('load', () => {
            if (!window.__driverExpensesDebug || window.__driverExpensesDebug.step !== 'after-load-batches') {
                debugInit('init-load-fallback');
                runDriverExpensesInit();
            }
        }, { once: true });

        // Listen for Service Worker upload completion messages.
        // CRITICAL: Serialize all Firestore updates so they run one-after-another. On iOS/slow devices, concurrent
        // getDoc+updateDoc caused one write to overwrite another ‚Äî one photo URL never made it into the doc.
        // ROOT CAUSE of "some photos missing": we used to fall back to getDoc(cache) when getDocFromServer failed.
        // Cache can be stale (from before a previous handler's write), so we merged into stale data and overwrote
        // other lines' URLs. Fix: only read from server (with retries); never use cache for this merge.
        if ('BroadcastChannel' in window) {
            var uploadCompleteUpdateChain = Promise.resolve();
            function getBatchFromServerWithRetry(batchRef, maxAttempts) {
                maxAttempts = maxAttempts || 3;
                var attempt = 0;
                function tryGet() {
                    attempt++;
                    return window.getDocFromServer(batchRef).catch(function(e) {
                        if (attempt < maxAttempts && e && (e.code === 'unavailable' || (e.message && (e.message.indexOf('network') !== -1 || e.message.indexOf('unavailable') !== -1)))) {
                            return new Promise(function(resolve) { setTimeout(resolve, 400); }).then(tryGet);
                        }
                        throw e;
                    });
                }
                return tryGet();
            }
            const uploadChannel = new BroadcastChannel('expense-upload-channel');
            uploadChannel.addEventListener('message', function(event) {
                const { type, uploadId, expenseDocId, batchId, lineKey, downloadURLs } = event.data || {};
                if (type !== 'upload-complete' || !downloadURLs || downloadURLs.length === 0 || !lineKey || !batchId) return;
                // Always persist every URL we receive so we keep the storage path; refresh on open fixes broken/revoked tokens.
                var isValidPhotoURL = window.isValidPhotoURL || (function(u) { return typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')); });
                var storagePathKey = function(url) { return (url || '').replace(/\&token=[^&]*/i, '').trim(); };
                var hasSameFile = function(existingList, url) { return existingList.some(function(ex) { return storagePathKey(ex) === storagePathKey(url); }); };
                var payload = { batchId: batchId, lineKey: lineKey, downloadURLs: downloadURLs };
                uploadCompleteUpdateChain = uploadCompleteUpdateChain.then(function() {
                    return (function() {
                        var batchRef = window.doc(window.db, 'expenseBatches', payload.batchId);
                        var readPromise = typeof window.getDocFromServer === 'function'
                            ? getBatchFromServerWithRetry(batchRef)
                            : window.getDoc(batchRef);
                        return readPromise.then(function(batchSnap) {
                            if (!batchSnap.exists()) return;
                            var data = batchSnap.data();
                            var lines = {};
                            var key;
                            for (key in (data.lines || {})) { if (Object.prototype.hasOwnProperty.call(data.lines, key)) lines[key] = { ...data.lines[key] }; }
                            var line = lines[payload.lineKey] || { amount: 0, photos: [] };
                            var existingPhotos = Array.isArray(line.photos) ? line.photos.filter(function(p) { return typeof p === 'string' && isValidPhotoURL(p); }) : [];
                            var allPhotoURLs = existingPhotos.slice();
                            for (var i = 0; i < payload.downloadURLs.length; i++) {
                                var u = payload.downloadURLs[i];
                                if (isValidPhotoURL(u) && !hasSameFile(allPhotoURLs, u)) allPhotoURLs.push(u);
                            }
                            var deduped = (window.dedupePhotoURLsByPath && window.dedupePhotoURLsByPath(allPhotoURLs)) || allPhotoURLs;
                            lines[payload.lineKey] = { ...line, photos: deduped, photosUploading: false };
                            return window.updateDoc(batchRef, {
                                lines: lines,
                                updatedAt: window.serverTimestamp ? window.serverTimestamp() : new Date()
                            }).then(function() {
                                if (typeof console !== 'undefined' && console.log) console.log('[Main Thread] Updated batch line with photo URLs:', payload.batchId, payload.lineKey);
                                if (window.currentBatch && window.currentBatch.id === payload.batchId && window.currentBatch.lines && window.currentBatch.lines[payload.lineKey]) {
                                    window.currentBatch.lines[payload.lineKey].photos = deduped;
                                    window.currentBatch.lines[payload.lineKey].photosUploading = false;
                                }
                                var batchInList = typeof allBatches !== 'undefined' && allBatches && allBatches.find(function(b) { return b.id === payload.batchId; });
                                if (batchInList && batchInList.lines && batchInList.lines[payload.lineKey]) {
                                    batchInList.lines[payload.lineKey] = { ...batchInList.lines[payload.lineKey], photos: deduped, photosUploading: false };
                                    batchInList.hasPendingUploads = Object.keys(batchInList.lines).some(function(k) { var l = batchInList.lines[k]; return l && l.photosUploading === true; });
                                    if (!batchInList.hasPendingUploads && typeof batchIdsGreyedUntilUploadDone !== 'undefined') batchIdsGreyedUntilUploadDone.delete(payload.batchId);
                                    if (typeof displayBatches === 'function') displayBatches();
                                }
                            });
                        });
                    })();
                }).catch(function(error) {
                    console.error('[Main Thread] Error updating batch line with photo URLs:', error);
                });
                uploadCompleteUpdateChain.then(function() {
                    if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') return window.expenseUploadQueue.updateGlobalUploadStatus();
                }).catch(function() {});
                if (typeof window.loadExpenseBatches === 'function') {
                    if (window._uploadCompleteRefreshTimer) clearTimeout(window._uploadCompleteRefreshTimer);
                    window._uploadCompleteRefreshTimer = setTimeout(function() {
                        window._uploadCompleteRefreshTimer = null;
                        window.loadExpenseBatches().catch(function() {});
                    }, 1500);
                }
            });
        }

        // Warn user if they try to leave while uploading (only after a user gesture to avoid browser intervention)
        let userHasInteracted = false;
        const markUserInteracted = () => { userHasInteracted = true; };
        document.addEventListener('click', markUserInteracted, { once: true });
        document.addEventListener('keydown', markUserInteracted, { once: true });
        document.addEventListener('touchstart', markUserInteracted, { once: true });
        window.addEventListener('beforeunload', (e) => {
            if (!userHasInteracted) return;
            const banner = document.getElementById('uploadBanner');
            if (banner && !banner.classList.contains('hidden')) {
                e.preventDefault();
                e.returnValue = 'You have expenses uploading. Are you sure you want to leave?';
                return e.returnValue;
            }
        });
 
        // Load all expense batches for this driver
        // Make loadExpenseBatches globally available for upload queue
        window.loadExpenseBatches = async function loadExpenseBatches() {
            const loadToken = Date.now();
            loadExpenseBatches.latestToken = loadToken;
            try {
                console.log('Loading expense batches for driverId:', currentUser.uid);
                const officeId = currentUser.officeId;
                if (!officeId) {
                throw new Error('Office ID is missing in user profile.');
                }

                const batchesQuery = window.query(
                window.collection(window.db, 'expenseBatches'),
                window.where('driverId', '==', currentUser.uid),
                window.where('officeId', '==', officeId)
                );

                const batchesSnapshot = await window.getDocs(batchesQuery);
                console.log('Found batches:', batchesSnapshot.docs.length);
                
                const batchMap = new Map();

                for (const doc of batchesSnapshot.docs) {
                const batchData = { id: doc.id, ...doc.data() };
                if (!batchData.officeId) {
                try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', doc.id), { officeId });
                batchData.officeId = officeId;
                } catch (error) {
                console.warn(`Failed to backfill officeId for batch ${doc.id}:`, error);
                }
                } else if (batchData.officeId !== officeId) {
                console.warn(`Skipping batch ${doc.id} due to mismatched officeId.`);
                continue;
                }
                
                if (!batchData.lines || typeof batchData.lines !== 'object') {
                    batchData.lines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
                }
                batchData.hasPendingUploads = Object.values(batchData.lines).some(line => line && line.photosUploading === true);
                
                batchMap.set(batchData.id || `local_${batchData.localId || Math.random()}`, batchData);
                }

                if (loadExpenseBatches.latestToken !== loadToken) {
                console.warn('Discarding stale expense batch load (superseded by a newer refresh).');
                return;
                }

                const previousBatches = allBatches;
                allBatches = Array.from(batchMap.values());
                // Keep batches that are still "greyed until done" but missing from fetch (avoids card disappearing/reappearing)
                if (batchIdsGreyedUntilUploadDone.size > 0 && previousBatches.length > 0) {
                    const loadedIds = new Set(allBatches.map(b => b.id));
                    for (const id of batchIdsGreyedUntilUploadDone) {
                        if (!loadedIds.has(id)) {
                            const kept = previousBatches.find(b => b.id === id);
                            if (kept) { allBatches.push(kept); loadedIds.add(id); }
                        }
                    }
                }

                // Sort by updatedAt descending (client-side)
                allBatches.sort((a, b) => {
                const aTime = a.updatedAt?.toDate ? a.updatedAt.toDate().getTime() : 0;
                const bTime = b.updatedAt?.toDate ? b.updatedAt.toDate().getTime() : 0;
                return bTime - aTime; // Descending order
                });

                console.log('Total batches loaded:', allBatches.length);
                if (allBatches.length) {
                const statusCounts = allBatches.reduce((acc, batch) => {
                const status = batch.status || 'unknown';
                acc[status] = (acc[status] || 0) + 1;
                return acc;
                }, {});
                console.log('Batch status counts:', statusCounts);
                }
                displayBatches();
            } catch (error) {
                console.error('Error loading batches:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
                notifyError('Error loading expense batches: ' + error.message);
            }
        }

        // Display batches by status
        function displayBatches() {
            const returned = allBatches.filter(b => b.status === 'returned');
            const pending = allBatches.filter(b => b.status === 'pending');
            const draft = allBatches.filter(b => b.status === 'draft');
            const validated = allBatches.filter(b => b.status === 'validated');
            const paid = allBatches.filter(b => b.status === 'paid');

            // Show/hide sections - in order: returned, draft, pending, validated, paid
            document.getElementById('returnedSection').classList.toggle('hidden', returned.length === 0);
            document.getElementById('draftSection').classList.toggle('hidden', draft.length === 0);
            document.getElementById('pendingSection').classList.toggle('hidden', pending.length === 0);
            document.getElementById('validatedSection').classList.toggle('hidden', validated.length === 0);
            document.getElementById('paidSection').classList.toggle('hidden', paid.length === 0);
            document.getElementById('emptyState').classList.toggle('hidden', allBatches.length > 0);

            // Render batches - in order: returned, draft, pending, validated, paid
            if (returned.length > 0) renderBatchList(returned, 'returnedBatches');
            if (draft.length > 0) renderBatchList(draft, 'draftBatches');
            if (pending.length > 0) renderBatchList(pending, 'pendingBatches');
            if (validated.length > 0) renderBatchList(validated, 'validatedBatches');
            if (paid.length > 0) renderPaidBatchList(paid, 'paidBatches');
        }

        // Calculate working hours between two dates (8am-5pm Mon-Fri only)
        function calculateWorkingHours(startDate, endDate) {
            let currentDate = new Date(startDate);
            let workingHours = 0;
            
            while (currentDate < endDate) {
                const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
                const hour = currentDate.getHours();
                
                // Check if it's a weekday (Monday = 1 to Friday = 5)
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                // Check if it's within working hours (8am to 5pm)
                if (hour >= 8 && hour < 17) {
                workingHours += 1;
                }
                }
                
                // Move to next hour
                currentDate.setHours(currentDate.getHours() + 1);
            }
            
            return workingHours;
        }
        
        // Get timer color based on working hours
        function getTimerColor(hours) {
            if (hours <= 6) return 'text-green-500';
            if (hours <= 18) return 'text-orange-500';
            return 'text-red-500';
        }
        
        // Get timer class based on working hours (for flashing)
        function getTimerClass(hours) {
            if (hours > 18) return 'flash-red';
            return '';
        }

        // Render batch list
        function renderBatchList(batches, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = batches.map(batch => {
                const statusColors = {
                draft: 'bg-gray-600',
                pending: 'bg-orange-500',
                validated: 'bg-green-500',
                paid: 'bg-green-500',
                returned: 'bg-red-500'
                };
                const statusColor = statusColors[batch.status] || 'bg-gray-600';
                
                // Calculate working hours for pending and validated batches
                let timerHTML = '';
                if (batch.status === 'pending' || batch.status === 'validated') {
                const submittedAt = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                if (submittedAt) {
                const workingHours = calculateWorkingHours(submittedAt, new Date());
                const color = getTimerColor(workingHours);
                const flashClass = getTimerClass(workingHours);
                timerHTML = `<div class="text-xs ${color} ${flashClass} font-semibold mt-2">${workingHours}h since submission</div>`;
                }
                }
                
                // Get border class based on status
                let borderClass = 'animated-border-panel';
                if (batch.status === 'draft') {
                    borderClass = 'animated-border-panel animated-border-draft';
                } else if (batch.status === 'pending') {
                    borderClass = 'animated-border-panel animated-border-pending';
                } else if (batch.status === 'validated') {
                    borderClass = 'animated-border-panel animated-border-validated';
                } else if (batch.status === 'paid') {
                    borderClass = 'animated-border-panel animated-border-paid';
                } else if (batch.status === 'returned') {
                    borderClass = 'animated-border-panel animated-border-returned';
                }
                
                const forceGreyed = batch.id && batchIdsGreyedUntilUploadDone.has(batch.id);
                const hasPendingUploads = forceGreyed || batch.hasPendingUploads || (batch.lines && typeof batch.lines === 'object' && Object.values(batch.lines).some(line => line && line.photosUploading === true));
                // Also check if batch is in submission queue (offline or processing)
                let isInQueue = false;
                if (batch.localId && typeof loadSubmissionQueue === 'function') {
                    try {
                        const queue = loadSubmissionQueue();
                        isInQueue = queue.some(entry => entry.localId === batch.localId);
                    } catch (e) {
                        // Ignore errors
                    }
                }
                const greyedOut = (hasPendingUploads || isInQueue) ? 'opacity-50 cursor-not-allowed' : '';
                const uploadIndicator = hasPendingUploads ? `
                <div class="mt-2 text-orange-400 text-xs flex items-center gap-1">
                <span class="material-symbols-outlined text-sm animate-pulse">cloud_upload</span>
                Uploading photos...
                </div>
                ` : '';
                
                return `
                <div onclick="${hasPendingUploads ? '' : `openBatch('${batch.id}')`}" class="${borderClass} cursor-pointer fade-in ${greyedOut}">
                <div class="flex items-start justify-between mb-2">
                <div class="license-plate">${batch.registration}</div>
                <span class="${statusColor} px-3 py-1 rounded-full text-xs font-semibold uppercase">${batch.status}</span>
                </div>
                <div class="flex items-center justify-between mt-3">
                <span class="text-gray-400 text-sm">${(typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLineCount ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(batch) : 0) || 0} Expense${((EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLineCount ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(batch) : 0) !== 1 ? 's' : '')}</span>
                <span class="text-green-500 font-semibold text-lg">¬£${(batch.totalAmount != null ? batch.totalAmount : 0).toFixed(2)}</span>
                </div>
                ${timerHTML}
                ${uploadIndicator}
                ${batch.status === 'returned' ? `
                <div class="mt-2 text-red-400 text-sm">
                <span class="material-symbols-outlined text-sm">error</span>
                Action required
                </div>
                ` : ''}
                </div>
                `;
            }).join('');
        }

        // Set modal title with status styling
        function setStatusTitle(status) {
            const modalTitle = document.getElementById('modalTitle');
            const statusColors = {
                draft: 'bg-gray-600 border-gray-600 text-white',
                pending: 'bg-orange-500 border-orange-500 text-white',
                validated: 'bg-green-500 border-green-500 text-white',
                paid: 'bg-green-500 border-green-500 text-white',
                returned: 'bg-red-500 border-red-500 text-white'
            };
            
            modalTitle.textContent = status.toUpperCase();
            modalTitle.className = `text-lg font-semibold px-4 py-2 rounded-lg border ${statusColors[status] || statusColors.draft}`;
        }

        // Create new batch (merged model: lines only)
        async function createNewBatch() {
            const emptyLines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
            currentBatch = {
                id: null,
                localId: null,
                registration: '',
                status: 'draft',
                lines: emptyLines,
                totalAmount: 0
            };
            window.currentBatch = currentBatch;
            setStatusTitle('draft');
            document.getElementById('regInput').value = '';
            document.getElementById('regInput').disabled = false;
            const notesSection = document.getElementById('notesSection');
            notesSection.classList.remove('hidden');
            const notesLabel = document.getElementById('notesLabel');
            if (notesLabel) notesLabel.textContent = 'NOTES (Optional)';
            const notesInput = document.getElementById('notesInput');
            notesInput.value = '';
            notesInput.placeholder = 'Add any additional notes...';
            notesInput.disabled = false;
            const commsSection = document.getElementById('communicationsSection');
            if (commsSection) commsSection.classList.add('hidden');
            document.getElementById('deleteBatchBtn').classList.add('hidden');
            const addExpenseBtn = document.getElementById('addExpenseBtn');
            if (addExpenseBtn) addExpenseBtn.classList.remove('hidden');
            const expensesListEl = document.getElementById('expensesList');
            if (expensesListEl) { expensesListEl.classList.add('hidden'); expensesListEl.innerHTML = ''; }
            const linesContainer = document.getElementById('linesContainer');
            if (linesContainer) { linesContainer.classList.remove('hidden'); renderLines(); }
            const actionButtons = document.getElementById('actionButtons');
            actionButtons.innerHTML = `
                <button onclick="saveDraft()" class="w-full animated-button animated-button-draft touch-target">
                <span class="text-white font-semibold">Save as Draft</span>
                </button>
                <button onclick="submitBatch()" class="w-full animated-button animated-button-submit touch-target">
                <span class="text-white font-semibold">Submit for Processing</span>
                </button>
            `;
            const totalEl = document.getElementById('totalAmount');
            if (totalEl) totalEl.textContent = '¬£0.00';
            if (window.isUploadingExpense) {
                notifyWarning('Please wait for the current upload to complete before creating a new batch.', 'Upload in Progress');
                return;
            }
            document.getElementById('batchModal').classList.remove('hidden');
            document.body.style.overflow = 'hidden';
        }

        // Open existing batch (supports merged .lines and legacy .expenses)
        async function openBatch(batchId) {
            if (window.isUploadingExpense) {
                notifyWarning('Please wait for the current upload to complete before opening this batch.', 'Upload in Progress');
                return;
            }
            let batch = allBatches.find(b => b.id === batchId);
            if (!batch) return;

            try {
                const batchRef = window.doc(window.db, 'expenseBatches', batchId);
                // Force server read so we get latest photo URLs (avoids stale cache where only first line had URLs)
                var batchSnap;
                try {
                    if (typeof window.getDocFromServer === 'function') {
                        batchSnap = await window.getDocFromServer(batchRef);
                        if (typeof console !== 'undefined' && console.log) console.log('[openBatch] Fetched batch from server:', batchId);
                    } else {
                        batchSnap = await window.getDoc(batchRef);
                        if (typeof console !== 'undefined' && console.log) console.log('[openBatch] Fetched batch from cache (getDocFromServer not available):', batchId);
                    }
                } catch (serverErr) {
                    var isOffline = serverErr && (serverErr.code === 'unavailable' || (serverErr.message && (serverErr.message.indexOf('network') !== -1 || serverErr.message.indexOf('unavailable') !== -1)));
                    if (isOffline) {
                        batchSnap = await window.getDoc(batchRef);
                        if (typeof console !== 'undefined' && console.log) console.log('[openBatch] Offline, using cached batch:', batchId);
                    } else {
                        throw serverErr;
                    }
                }
                if (batchSnap.exists()) {
                    batch = { id: batchSnap.id, ...batchSnap.data() };
                    if (batch.lines && typeof batch.lines === 'object') {
                        batch.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.normalizeLines) ? EXPENSE_BATCH_SCHEMA.normalizeLines(batch.lines) : batch.lines;
                    } else {
                        batch.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
                    }
                    const index = allBatches.findIndex(b => b.id === batchId);
                    if (index >= 0) allBatches[index] = batch;
                }
            } catch (error) {
                console.warn('Failed to fetch batch', batchId, error);
                if (batch.localId && window.expenseDraftDB) {
                    try {
                        const draft = await window.expenseDraftDB.getDraft(batch.localId);
                        if (draft) {
                            if (draft.notes != null) batch.notes = draft.notes;
                            if (draft.lines && typeof draft.lines === 'object' && (!batch.lines || Object.keys(batch.lines).length === 0)) batch.lines = draft.lines;
                        }
                    } catch (dbError) {
                        console.warn('Failed to load draft from IndexedDB:', dbError);
                    }
                }
            }

            if (!batch.lines || typeof batch.lines !== 'object') {
                batch.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
            }

            // Reopened draft = 100% from Firebase. When batch has a Firestore id (saved to server), use only the fetched data ‚Äî do not merge IndexedDB so we never overwrite server photo URLs with stale local data.
            // Only use IndexedDB when fetch failed (catch block already applied) or we have no batch.id (e.g. offline draft never synced).
            if (!batch.id && batch.localId && window.expenseDraftDB) {
                var hasLines = batch.lines && typeof batch.lines === 'object' && Object.keys(batch.lines).length > 0;
                if (!hasLines) {
                    try {
                        var draft = await window.expenseDraftDB.getDraft(batch.localId);
                        if (draft && draft.lines && typeof draft.lines === 'object') {
                            batch.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.normalizeLines) ? EXPENSE_BATCH_SCHEMA.normalizeLines(draft.lines) : draft.lines;
                        }
                    } catch (e) {
                        console.warn('Failed to rehydrate draft from IndexedDB:', e);
                    }
                }
            }

            // If this is a saved draft and any used line has amount but no photo URLs, refetch once from server (catches race where we opened before all upload-complete writes had propagated)
            if (batch.id && batch.lines && typeof batch.lines === 'object' && typeof window.getDocFromServer === 'function') {
                var getUsedLines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLines) ? EXPENSE_BATCH_SCHEMA.getUsedLines : function() { return []; };
                var usedKeys = getUsedLines(batch);
                var anyMissingPhotos = false;
                for (var ui = 0; ui < usedKeys.length; ui++) {
                    var l = batch.lines[usedKeys[ui]];
                    if (l && typeof l.amount === 'number' && l.amount > 0) {
                        var urls = (l.photos && Array.isArray(l.photos)) ? l.photos.filter(function(p) { return typeof p === 'string'; }) : [];
                        if (urls.length === 0) { anyMissingPhotos = true; break; }
                    }
                }
                if (anyMissingPhotos) {
                    try {
                        var refetchSnap = await window.getDocFromServer(window.doc(window.db, 'expenseBatches', batch.id));
                        if (refetchSnap.exists()) {
                            var refetchData = refetchSnap.data();
                            if (refetchData.lines && typeof refetchData.lines === 'object') {
                                batch.lines = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.normalizeLines) ? EXPENSE_BATCH_SCHEMA.normalizeLines(refetchData.lines) : refetchData.lines;
                                if (typeof console !== 'undefined' && console.log) console.log('[openBatch] Refetched batch from server (some lines were missing photos):', batch.id);
                            }
                        }
                    } catch (refetchErr) {
                        // ignore
                    }
                }
            }

            currentBatch = batch;
            
            // Update global reference for offline storage
            window.currentBatch = currentBatch;
            
            // Apply animated border to modal based on status
            const modalContent = document.getElementById('batchModalContent');
            if (modalContent) {
                // Remove all border classes
                modalContent.classList.remove(
                    'animated-border-modal-draft',
                    'animated-border-modal-pending',
                    'animated-border-modal-validated',
                    'animated-border-modal-paid',
                    'animated-border-modal-returned'
                );
                
                // Add appropriate border class
                if (batch.status === 'draft') {
                    modalContent.classList.add('animated-border-modal-draft');
                } else if (batch.status === 'pending' || batch.status === 'validated') {
                    modalContent.classList.add('animated-border-modal-pending');
                } else if (batch.status === 'paid') {
                    modalContent.classList.add('animated-border-modal-paid');
                } else if (batch.status === 'returned') {
                    modalContent.classList.add('animated-border-modal-returned');
                }
            }
            
            // Set title to status with styling
            setStatusTitle(batch.status);
            document.getElementById('regInput').value = batch.registration;
            document.getElementById('regInput').disabled = batch.status !== 'draft' && batch.status !== 'returned';
            
            // Show communications thread for returned batches
            const commsSection = document.getElementById('communicationsSection');
            const commsList = document.getElementById('communicationsList');
            if (batch.status === 'returned' && Array.isArray(batch.communications) && batch.communications.length > 0) {
                commsSection.classList.remove('hidden');
                const entries = batch.communications.map(c => ({
                    from: c.from || 'driver',
                    authorName: c.authorName || (c.from === 'office' ? 'Office' : (batch.driverName || 'Driver')),
                    message: c.message || '',
                    createdAt: c.createdAt
                }));
                commsList.innerHTML = entries.map(e => {
                    const dateStr = e.createdAt && (e.createdAt.toDate ? e.createdAt.toDate() : e.createdAt) ? new Date(e.createdAt.toDate ? e.createdAt.toDate() : e.createdAt).toLocaleString() : '';
                    const namePart = `<strong>${escapeHtml(e.authorName)}</strong>`;
                    const label = dateStr ? namePart + ' ¬∑ ' + escapeHtml(dateStr) : namePart;
                    return `<div class="border-l-2 pl-3 ${e.from === 'office' ? 'border-red-500' : 'border-blue-500'}"><p class="text-sm font-medium text-gray-300 mb-1">${label}</p><p class="text-white whitespace-pre-wrap text-sm">${escapeHtml(e.message)}</p></div>`;
                }).join('');
            } else {
                commsSection.classList.add('hidden');
            }

            // Show/hide notes section based on status
            const notesSection = document.getElementById('notesSection');
            const notesLabel = document.getElementById('notesLabel');
            const notesInput = document.getElementById('notesInput');
            if (batch.status === 'draft') {
                notesSection.classList.remove('hidden');
                notesLabel.textContent = 'NOTES (Optional)';
                notesInput.placeholder = 'Add any additional notes...';
                if (batch.notes) {
                    notesInput.value = batch.notes;
                } else {
                    notesInput.value = '';
                }
                notesInput.disabled = false;
            } else if (batch.status === 'returned') {
                notesSection.classList.remove('hidden');
                notesLabel.textContent = 'APPEAL NOTES';
                notesInput.placeholder = 'Add notes to explain changes or dispute the return...';
                // Clear the notes field for appeal (don't show old notes)
                notesInput.value = '';
                notesInput.disabled = false;
            } else {
                // Hide notes section for pending, validated, paid
                notesSection.classList.add('hidden');
            }

            // Show delete button only for drafts
            document.getElementById('deleteBatchBtn').classList.toggle('hidden', batch.status !== 'draft');

            // Update photo input to allow gallery selection for returned batches (not just camera)
            const linePhotoInput = document.getElementById('linePhotoInput');
            if (linePhotoInput) {
                if (batch.status === 'returned') {
                    linePhotoInput.removeAttribute('capture');
                } else {
                    linePhotoInput.setAttribute('capture', 'environment');
                }
            }

            const addExpenseBtn = document.getElementById('addExpenseBtn');
            const linesContainerEl = document.getElementById('linesContainer');
            const expensesListEl = document.getElementById('expensesList');
            if (linesContainerEl) { linesContainerEl.classList.remove('hidden'); renderLines(); }
            if (expensesListEl) { expensesListEl.classList.add('hidden'); expensesListEl.innerHTML = ''; }
            if (addExpenseBtn) addExpenseBtn.classList.toggle('hidden', batch.status !== 'draft');
            const totalEl = document.getElementById('totalAmount');
            if (totalEl && typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getTotalFromLines) {
                totalEl.textContent = '¬£' + (EXPENSE_BATCH_SCHEMA.getTotalFromLines(batch.lines) || 0).toFixed(2);
            }

            // Show/hide action buttons based on status
            const actionButtons = document.getElementById('actionButtons');
            const submitBtn = document.getElementById('submitBtn');
            
            if (batch.status === 'returned') {
                // For returned batches, only show resubmit and discard buttons
                actionButtons.innerHTML = `
                <button onclick="submitBatch()" class="w-full animated-button animated-button-submit touch-target">
                <span class="text-white font-semibold">Resubmit for Processing</span>
                </button>
                <button onclick="discardReturnedBatch()" class="w-full animated-button animated-button-discard touch-target">
                <span class="text-white font-semibold">Discard Expense</span>
                </button>
                `;
            } else if (batch.status === 'draft') {
                // For drafts, show normal buttons
                actionButtons.innerHTML = `
                <button onclick="saveDraft()" class="w-full animated-button animated-button-draft touch-target">
                <span class="text-white font-semibold">Save as Draft</span>
                </button>
                <button onclick="submitBatch()" class="w-full animated-button animated-button-submit touch-target">
                <span class="text-white font-semibold">Submit for Processing</span>
                </button>
                `;
            } else if (batch.status === 'pending' || batch.status === 'validated') {
                // For submitted batches, show "Add Additional Expenses" button
                actionButtons.innerHTML = `
                <button onclick="addAdditionalExpenses()" class="w-full animated-button animated-button-add touch-target">
                <span class="text-white font-semibold">Add Additional Expenses</span>
                </button>
                `;
            } else {
                // For other statuses (paid, etc), no action buttons
                actionButtons.innerHTML = '';
            }

            document.getElementById('batchModal').classList.remove('hidden');
            document.body.style.overflow = 'hidden';
            // Fallback: refresh Firebase Storage URLs in background (e.g. if a token was revoked). Root cause fix above should mean all URLs are already in the doc.
            if (typeof refreshFirebasePhotoURLs === 'function') refreshFirebasePhotoURLs(currentBatch);
        }

        // Single workflow: batch modal always uses lines; renderExpenses just delegates to renderLines
        function renderExpenses() {
            if (window.isUserTyping) {
                clearTimeout(renderExpenses.deferTimer);
                renderExpenses.deferTimer = setTimeout(renderExpenses, 1500);
                return;
            }
            if (currentBatch && currentBatch.lines) renderLines();
        }

        // Same category emoji map as renderExpenses (by category key for lines)
        var categoryEmojisLines = { train: 'üöÇ', taxi: 'üöï', fuel: '‚õΩ', charge: 'üîå', bus: 'üöå', carWash: 'üßº', toll: 'üõ£Ô∏è', other: 'üìù' };
        function getDisplayPhotoCountForLine(line) {
            if (!line || !line.photos || !Array.isArray(line.photos)) return 0;
            var fn = window.isValidPhotoURL || (function(u) { return typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')); });
            var urlCount = line.photos.filter(function(p) { return typeof p === 'string' && fn(p); }).length;
            var fileCount = line.photos.filter(function(p) { return p instanceof File || p instanceof Blob; }).length;
            return urlCount + fileCount;
        }
        function getThumbnailSourcesForLine(line) {
            if (!line || !line.photos || !Array.isArray(line.photos)) return [];
            var fn = window.isValidPhotoURL || (function(u) { return typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')); });
            return line.photos.map(function(p) {
                if (typeof p === 'string' && fn(p)) return p;
                if (p instanceof File || p instanceof Blob) return URL.createObjectURL(p);
                return null;
            }).filter(Boolean);
        }
        function addNextLinePhoto(lineKey) {
            var line = currentBatch && currentBatch.lines && currentBatch.lines[lineKey];
            var photos = line && Array.isArray(line.photos) ? line.photos : [];
            var MAX_PHOTOS = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.MAX_PHOTOS_PER_LINE) || 4;
            for (var i = 0; i < MAX_PHOTOS; i++) {
                var p = photos[i];
                if (!p || (typeof p !== 'string' && !(p instanceof File) && !(p instanceof Blob))) {
                    addLinePhoto(lineKey, i);
                    return;
                }
            }
            addLinePhoto(lineKey, MAX_PHOTOS - 1);
        }
        async function clearLine(lineKey) {
            if (!currentBatch || !currentBatch.lines) return;
            var label = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getCategoryLabel) ? EXPENSE_BATCH_SCHEMA.getCategoryLabel(lineKey) : lineKey;
            var confirmed = (typeof dialogApi !== 'undefined' && dialogApi.showConfirmation)
                ? await dialogApi.showConfirmation({
                    title: 'Remove expense',
                    message: 'Remove "' + label + '" and its photos from this batch?',
                    confirmText: 'Remove',
                    cancelText: 'Cancel',
                    tone: 'danger'
                })
                : window.confirm('Remove "' + label + '" and its photos from this batch?');
            if (!confirmed) return;
            currentBatch.lines[lineKey] = { amount: 0, photos: [] };
            renderLines();
            if (window.scheduleAutoSave) window.scheduleAutoSave();
        }
        function openLinePhotoGallery(lineKey) {
            var line = currentBatch && currentBatch.lines && currentBatch.lines[lineKey];
            var photos = line && Array.isArray(line.photos) ? line.photos : [];
            var filePhotos = photos.filter(function(p) { return p instanceof File || p instanceof Blob; });
            var fn = window.isValidPhotoURL || (function(u) { return typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')); });
            var validURLs = photos.filter(function(p) { return typeof p === 'string' && fn(p); });
            if (filePhotos.length === 0 && validURLs.length === 0) return;
            var container = document.getElementById('linePhotoGalleryThumbs');
            var modal = document.getElementById('linePhotoGalleryModal');
            if (!container || !modal) return;
            var urls = filePhotos.length > 0
                ? filePhotos.map(function(f) { return URL.createObjectURL(f); })
                : validURLs;
            container.innerHTML = urls.map(function(src, index) {
                var safe = (src || '').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
                return '<button type="button" onclick="closeLinePhotoGallery(); viewLinePhotos(\'' + lineKey + '\')" class="w-28 h-28 rounded-lg overflow-hidden border-2 border-gray-600 hover:border-blue-400 flex-shrink-0 hover:opacity-95"><img src="' + safe + '" alt="" class="w-full h-full object-cover"></button>';
            }).join('');
            modal.classList.remove('hidden');
        }
        function closeLinePhotoGallery() {
            var modal = document.getElementById('linePhotoGalleryModal');
            if (modal) modal.classList.add('hidden');
        }
        function viewLinePhotos(lineKey) {
            var line = currentBatch && currentBatch.lines && currentBatch.lines[lineKey];
            var photos = line && Array.isArray(line.photos) ? line.photos : [];
            var filePhotos = photos.filter(function(p) { return p instanceof File || p instanceof Blob; });
            var fn = window.isValidPhotoURL || (function(u) { return typeof u === 'string' && u.trim().length > 0 && (u.startsWith('http://') || u.startsWith('https://')); });
            var validURLs = photos.filter(function(p) { return typeof p === 'string' && fn(p); });
            if (filePhotos.length === 0 && validURLs.length === 0) return;
            var grid = document.getElementById('photoViewerGrid');
            if (!grid) return;
            if (filePhotos.length > 0) {
                grid.innerHTML = filePhotos.map(function(file) {
                    return '<div class="mb-4"><img src="' + (URL.createObjectURL(file)) + '" class="w-full rounded-lg"></div>';
                }).join('');
            } else {
                grid.innerHTML = validURLs.map(function(url, index) {
                    return '<div class="mb-4"><img src="' + url + '" class="w-full rounded-lg" alt="Photo ' + (index + 1) + '"></div>';
                }).join('');
            }
            document.getElementById('photoViewerModal').classList.remove('hidden');
        }
        function renderLines() {
            if (!currentBatch || !currentBatch.lines || typeof EXPENSE_BATCH_SCHEMA === 'undefined') return;
            var container = document.getElementById('linesContainer');
            if (!container) return;
            var getUsedLines = EXPENSE_BATCH_SCHEMA.getUsedLines || (function() { return []; });
            var usedKeys = getUsedLines(currentBatch);
            var getCategoryLabel = EXPENSE_BATCH_SCHEMA.getCategoryLabel || (function(k) { return k; });
            var getCategoryGroup = EXPENSE_BATCH_SCHEMA.getCategoryGroup || (function(k) { return (k || '').replace(/\d+$/, ''); });
            var canEdit = currentBatch.status === 'draft' || currentBatch.status === 'returned';
            var html = '';
            usedKeys.forEach(function(lineKey) {
                var line = currentBatch.lines[lineKey] || { amount: 0, photos: [] };
                var amount = typeof line.amount === 'number' ? line.amount : 0;
                var photoCount = getDisplayPhotoCountForLine(line);
                var prefix = getCategoryGroup(lineKey) || 'other';
                var emoji = categoryEmojisLines[prefix] || 'üìù';
                var label = getCategoryLabel(lineKey);
                html += '<div class="bg-[#283039] rounded-lg p-3 flex items-center justify-between gap-2" data-line-key="' + lineKey + '">';
                html += '<div class="flex items-center gap-3 min-w-0 flex-shrink-0">';
                html += '<span class="text-2xl flex-shrink-0">' + emoji + '</span>';
                html += '<div class="min-w-0">';
                html += '<div class="font-medium capitalize">' + label + '</div>';
                if (photoCount === 0 && canEdit && currentBatch.status === 'draft') {
                    html += '<button type="button" onclick="addNextLinePhoto(\'' + lineKey + '\')" class="text-xs text-blue-400 hover:text-blue-300 transition-colors flex items-center gap-1">';
                    html += '<span class="material-symbols-outlined text-xs">photo_camera</span> Add photos</button>';
                }
                html += '</div></div>';
                html += '<div class="flex items-center gap-3 flex-shrink-0">';
                // Amount is read-only: to change value, delete the line and add expense again
                html += '<span class="font-semibold text-green-500">¬£' + (amount ? parseFloat(amount).toFixed(2) : '0.00') + '</span>';
                if (photoCount > 0) {
                    var count = Math.min(photoCount, 4);
                    html += '<button type="button" onclick="openLinePhotoGallery(\'' + lineKey + '\')" class="w-9 h-9 rounded-lg border border-gray-600 flex-shrink-0 flex items-center justify-center bg-[#1e252b] hover:bg-[#283039] focus:outline-none focus:ring-2 focus:ring-blue-400 relative" title="' + count + ' photo' + (count !== 1 ? 's' : '') + '">';
                    html += '<span class="material-symbols-outlined text-gray-400 text-xl">photo_camera</span>';
                    html += '<span class="absolute -top-0.5 -right-0.5 min-w-[14px] h-[14px] rounded-full bg-blue-500 text-white text-[10px] font-semibold flex items-center justify-center">' + count + '</span>';
                    html += '</button>';
                }
                if (currentBatch.status === 'returned') {
                    html += '<button type="button" onclick="addNextLinePhoto(\'' + lineKey + '\')" class="text-blue-500 hover:text-blue-400 transition-colors" title="Add Photos"><span class="material-symbols-outlined">add_a_photo</span></button>';
                    html += '<button type="button" onclick="clearLine(\'' + lineKey + '\')" class="text-red-500 hover:text-red-400 transition-colors" title="Clear line"><span class="material-symbols-outlined">delete</span></button>';
                } else if (currentBatch.status === 'draft') {
                    html += '<button type="button" onclick="clearLine(\'' + lineKey + '\')" class="text-red-500 hover:text-red-400 transition-colors" title="Clear line"><span class="material-symbols-outlined">delete</span></button>';
                }
                html += '</div></div>';
            });
            if (html === '') {
                container.innerHTML = '<p class="text-gray-500 text-center py-4">No expenses added yet</p>';
            } else {
                container.innerHTML = html;
            }
            var total = EXPENSE_BATCH_SCHEMA.getTotalFromLines ? EXPENSE_BATCH_SCHEMA.getTotalFromLines(currentBatch.lines) : 0;
            currentBatch.totalAmount = total;
            var totalEl = document.getElementById('totalAmount');
            if (totalEl) totalEl.textContent = '¬£' + total.toFixed(2);
        }

        function updateLineAmount(lineKey, value) {
            if (!currentBatch || !currentBatch.lines) return;
            const num = parseFloat(value);
            if (!currentBatch.lines[lineKey]) currentBatch.lines[lineKey] = { amount: 0, photos: [] };
            currentBatch.lines[lineKey].amount = isNaN(num) ? 0 : num;
            renderLines();
            if (window.scheduleAutoSave) window.scheduleAutoSave();
        }

        // Compress image for faster upload: max dimension 1600px, JPEG quality 0.88. Keeps quality, reduces size.
        function compressImageForUpload(fileOrBlob) {
            return new Promise(function(resolve) {
                if (!fileOrBlob || !(fileOrBlob instanceof File || fileOrBlob instanceof Blob)) {
                    resolve(fileOrBlob);
                    return;
                }
                var url = URL.createObjectURL(fileOrBlob);
                var img = new Image();
                img.onerror = function() {
                    URL.revokeObjectURL(url);
                    resolve(fileOrBlob);
                };
                img.onload = function() {
                    URL.revokeObjectURL(url);
                    var maxDim = 1600;
                    var w = img.naturalWidth || img.width;
                    var h = img.naturalHeight || img.height;
                    if (!w || !h) { resolve(fileOrBlob); return; }
                    var scale = Math.min(1, maxDim / Math.max(w, h));
                    var cw = Math.round(w * scale);
                    var ch = Math.round(h * scale);
                    if (scale >= 1 && fileOrBlob.size && fileOrBlob.size < 300000) {
                        resolve(fileOrBlob);
                        return;
                    }
                    var canvas = document.createElement('canvas');
                    canvas.width = cw;
                    canvas.height = ch;
                    var ctx = canvas.getContext('2d');
                    if (!ctx) { resolve(fileOrBlob); return; }
                    ctx.drawImage(img, 0, 0, cw, ch);
                    canvas.toBlob(function(blob) {
                        if (blob) resolve(blob);
                        else resolve(fileOrBlob);
                    }, 'image/jpeg', 0.88);
                };
                img.src = url;
            });
        }
        if (typeof window !== 'undefined') window.compressImageForUpload = compressImageForUpload;

        function addLinePhoto(lineKey, photoIndex) {
            if (!currentBatch || !currentBatch.lines) return;
            window._pendingLinePhoto = { lineKey, photoIndex };
            var input = document.getElementById('linePhotoInput');
            if (input) input.click();
        }

        async function onLinePhotoSelected(event) {
            var f = event.target && event.target.files && event.target.files[0];
            if (!f || !window._pendingLinePhoto) return;
            var pending = window._pendingLinePhoto;
            window._pendingLinePhoto = null;
            event.target.value = '';
            if (!currentBatch.lines[pending.lineKey]) currentBatch.lines[pending.lineKey] = { amount: 0, photos: [] };
            var photos = currentBatch.lines[pending.lineKey].photos || [];
            while (photos.length <= pending.photoIndex) photos.push(null);
            try {
                var compressed = await compressImageForUpload(f);
                photos[pending.photoIndex] = compressed;
            } catch (e) {
                photos[pending.photoIndex] = f;
            }
            currentBatch.lines[pending.lineKey].photos = photos.filter(Boolean);
            renderLines();
            if (window.scheduleAutoSave) window.scheduleAutoSave();
        }

        // Helper function to ensure expense modal has no border classes
        function clearExpenseModalBorders() {
            const expenseModalContent = document.getElementById('expenseModalContent');
            if (expenseModalContent) {
                // Remove ALL possible border animation classes (more aggressive clearing)
                const borderClasses = [
                    'animated-border-modal',
                    'animated-border-modal-draft',
                    'animated-border-modal-pending',
                    'animated-border-modal-validated',
                    'animated-border-modal-paid',
                    'animated-border-modal-returned',
                    'animated-border-expense-modal'
                ];
                
                // Remove each class individually and check if it exists
                borderClasses.forEach(className => {
                    if (expenseModalContent.classList.contains(className)) {
                        expenseModalContent.classList.remove(className);
                        console.log(`[clearExpenseModalBorders] Removed ${className} from expense modal`);
                    }
                });
            }
        }

        // Add expense button
        function addExpense() {
            // Only allow adding expenses if batch is draft (not returned)
            if (currentBatch.status !== 'draft') {
            notifyWarning('Cannot add new expenses to this batch. For returned batches, you can only add photos to existing expenses.', 'Action Not Allowed');
                return;
            }

            currentExpense = {
                category: null,
                amount: 0,
                photos: []
            };
            
            document.getElementById('amountInput').value = '';
            document.getElementById('photoPreview').innerHTML = '';
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('ring-2', 'ring-blue-500'));
            
            // CRITICAL: Clear any border classes BEFORE showing modal
            // This ensures no border color from batch modal carries over
            clearExpenseModalBorders();
            
            // Get modal and show it
            const expenseModal = document.getElementById('expenseModal');
            if (expenseModal) {
            expenseModal.classList.remove('hidden');
            // Reset scroll position to top when opening modal
            expenseModal.scrollTop = 0;
            }
            
            // Clear borders immediately after showing modal
            clearExpenseModalBorders();
            
            // Clear borders again after a short delay to catch any async class additions
            setTimeout(() => {
                clearExpenseModalBorders();
            }, 50);
        }

        // Select category
        function selectCategory(category) {
            currentExpense.category = category;
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('ring-2', 'ring-blue-500'));
            event.target.closest('.category-btn').classList.add('ring-2', 'ring-blue-500');
        }

        // Show system photo picker
        function openPhotoPicker() {
            const galleryInput = document.getElementById('photoInputGallery');
            if (galleryInput) {
                galleryInput.value = '';
                galleryInput.click();
            }
        }
        
        // Handle photo selection (works with both camera and gallery inputs). Compresses for faster upload.
        async function handlePhotoSelect(event) {
            const files = Array.from(event.target.files || []);
            if (files.length === 0) return;

            if (!currentExpense.photos) {
                currentExpense.photos = [];
            }

            const remainingSlots = MAX_PHOTOS_PER_EXPENSE - currentExpense.photos.length;
            if (remainingSlots <= 0) {
                notifyWarning(`Each expense can include up to ${MAX_PHOTOS_PER_EXPENSE} photos. Remove one to add another.`, 'Photo Limit Reached');
                event.target.value = '';
                const cameraInput = document.getElementById('photoInputCamera');
                const galleryInput = document.getElementById('photoInputGallery');
                if (cameraInput) cameraInput.value = '';
                if (galleryInput) galleryInput.value = '';
                return;
            }

            let filesToAdd = files;
            if (files.length > remainingSlots) {
                filesToAdd = files.slice(0, remainingSlots);
                notifyWarning(`Only the first ${remainingSlots} photo${remainingSlots === 1 ? '' : 's'} were added. Each expense can include up to ${MAX_PHOTOS_PER_EXPENSE} photos.`, 'Photo Limit Reached');
            }

            var compressed = [];
            for (var i = 0; i < filesToAdd.length; i++) {
                try {
                    var c = await (window.compressImageForUpload || (function(f) { return Promise.resolve(f); }))(filesToAdd[i]);
                    compressed.push(c);
                } catch (e) {
                    compressed.push(filesToAdd[i]);
                }
            }
            currentExpense.photos = currentExpense.photos.concat(compressed);
            
            // Update preview
            const preview = document.getElementById('photoPreview');
            preview.innerHTML = currentExpense.photos.map((photo, index) => {
                if (photo instanceof File || photo instanceof Blob) {
                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${index})">
                <img src="${URL.createObjectURL(photo)}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <button onclick="event.stopPropagation(); removePhoto(${index})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10 hover:bg-red-600">
                √ó
                </button>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
                }

                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${index})">
                <img src="${photo}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <span class="absolute top-1 right-1 bg-gray-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10">‚úì</span>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
            }).join('');
            
            // Reset both inputs so same file can be selected again if needed
            const cameraInput = document.getElementById('photoInputCamera');
            const galleryInput = document.getElementById('photoInputGallery');
            if (cameraInput) cameraInput.value = '';
            if (galleryInput) galleryInput.value = '';
            
            // Trigger auto-save if we're editing a batch
            if (currentBatch && window.scheduleAutoSave) {
                window.scheduleAutoSave();
            }
        }

        // Remove photo
        function removePhoto(index) {
            currentExpense.photos.splice(index, 1);
            
            // Update preview
            const preview = document.getElementById('photoPreview');
            if (currentExpense.photos.length === 0) {
                preview.innerHTML = '';
            } else {
                preview.innerHTML = currentExpense.photos.map((file, idx) => {
                // Check if it's a File/Blob or URL
                if (file instanceof File || file instanceof Blob) {
                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${idx})">
                <img src="${URL.createObjectURL(file)}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <button onclick="event.stopPropagation(); removePhoto(${idx})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10 hover:bg-red-600">
                √ó
                </button>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
                } else {
                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${idx})">
                <img src="${file}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <span class="absolute top-1 right-1 bg-gray-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10">‚úì</span>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
                }
                }).join('');
            }
        }
        
        // Add photos to an existing expense (for returned batches)
        function addPhotosToExpense(expenseIndex) {
            if (currentBatch.status !== 'returned') {
            notifyWarning('This feature is only available for returned batches.', 'Unavailable Action');
                return;
            }
            
            // Store which expense we're editing
            window.editingExpenseIndex = expenseIndex;
            const expense = currentBatch.expenses[expenseIndex];
            
            // Initialize currentExpense with existing photos (if any)
            currentExpense = {
                category: expense.category,
                amount: expense.amount,
                photos: expense.photos ? [...expense.photos] : []
            };
            
            // Clear and show photo preview
            document.getElementById('photoPreview').innerHTML = '';
            if (currentExpense.photos && currentExpense.photos.length > 0) {
                const preview = document.getElementById('photoPreview');
                preview.innerHTML = currentExpense.photos.map((photo, idx) => {
                // Check if it's a URL or File object
                if (photo instanceof File) {
                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${idx})">
                <img src="${URL.createObjectURL(photo)}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <button onclick="event.stopPropagation(); removePhoto(${idx})" class="absolute top-1 right-1 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10 hover:bg-red-600">
                √ó
                </button>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
                } else {
                return `
                <div class="relative cursor-pointer group" onclick="viewCurrentExpensePhotos(${idx})">
                <img src="${photo}" class="w-full h-24 object-cover rounded-lg transition-opacity group-hover:opacity-80">
                <span class="absolute top-1 right-1 bg-gray-600 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs z-10">‚úì</span>
                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity bg-black bg-opacity-20 rounded-lg">
                <span class="material-symbols-outlined text-white text-2xl">zoom_in</span>
                </div>
                </div>
                `;
                }
                }).join('');
            }
            
            // Hide category selector and amount input, show only photo section
            const categorySection = document.getElementById('categorySection');
            const amountInputParent = document.getElementById('amountInput')?.parentElement;
            const saveBtn = document.getElementById('saveExpenseBtn');
            
            if (categorySection) {
                categorySection.classList.add('hidden');
            }
            if (amountInputParent) {
                amountInputParent.classList.add('hidden');
            }
            if (saveBtn) {
                saveBtn.innerHTML = '<span class="text-white font-semibold">Add Photos</span>';
                saveBtn.onclick = savePhotosToExpense;
            }
            
            // CRITICAL: Clear any border classes before showing modal
            // This ensures no border color from batch modal carries over
            clearExpenseModalBorders();
            
            // Get modal and show it
            const expenseModal = document.getElementById('expenseModal');
            if (expenseModal) {
                expenseModal.classList.remove('hidden');
            }
            
            // Clear borders immediately after showing modal
            clearExpenseModalBorders();
            
            // Clear borders again after a short delay to catch any async class additions
            setTimeout(() => {
                clearExpenseModalBorders();
            }, 50);
        }
        
        // Save photos to existing expense
        async function savePhotosToExpense() {
            // Block saving photos when offline to avoid losing them
            if (!navigator.onLine) {
        notifyError('You are currently offline. Photo uploads require an internet connection. Please try again when you are back online.', 'Offline Photo Upload Not Allowed');
                return;
            }
            if (window.editingExpenseIndex === undefined) {
        notifyError('No expense selected for editing.', 'Selection Required');
                return;
            }
            
            if (!currentExpense.photos || currentExpense.photos.length === 0) {
        notifyWarning('Please add at least one photo.', 'Photo Required');
                return;
            }
            
            const expense = currentBatch.expenses[window.editingExpenseIndex];
            
            // Get existing photos (URLs from Firebase)
            const existingPhotos = expense.photos ? expense.photos.filter(p => typeof p === 'string') : [];
            if (existingPhotos.length > MAX_PHOTOS_PER_EXPENSE) {
                notifyWarning(`This expense already has more than ${MAX_PHOTOS_PER_EXPENSE} photos. Please contact support.`, 'Photo Limit Reached');
                return;
            }
            
            // Get new photos (File objects)
            const newPhotos = currentExpense.photos.filter(p => p instanceof File);
            const totalPhotos = existingPhotos.length + newPhotos.length;
            if (totalPhotos > MAX_PHOTOS_PER_EXPENSE) {
                notifyWarning(`Each expense can include up to ${MAX_PHOTOS_PER_EXPENSE} photos. Remove some existing photos before adding new ones.`, 'Photo Limit Reached');
                return;
            }
            
            // CRITICAL: Ensure batch ID exists before uploading photos
            // If batch doesn't have an ID yet, save as draft first to create it
            if (!currentBatch.id) {
                console.log('[savePhotosToExpense] Batch ID missing, saving as draft first...');
                try {
                    await syncDraftToFirestore(currentBatch, 'draft');
                    console.log('[savePhotosToExpense] Batch saved as draft, batch ID:', currentBatch.id);
                } catch (error) {
                    console.error('[savePhotosToExpense] Failed to save batch as draft:', error);
                    notifyError('Cannot add photos: batch needs to be saved first. Please save as draft, then try again.', 'Batch Not Saved');
                    return;
                }
            }
            
            // Upload new photos and get URLs
            if (newPhotos.length > 0) {
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                
                if (isLocalhost) {
                notifyInfo('Photo upload is disabled on localhost. Please test on production.', 'Upload Disabled');
                return;
                }
                
                const batchId = currentBatch.id;
                if (!batchId) {
                    console.error('[savePhotosToExpense] Batch ID is still missing after draft save attempt');
                    notifyError('Cannot add photos: batch ID is missing. Please save as draft first, then try again.', 'Missing Batch ID');
                    return;
                }
                
                const expenseId = expense.id || window.editingExpenseIndex;
                
                const storageFolder = sanitizeRegForStoragePath(currentBatch.registration) || batchId;
                const uploadPromises = newPhotos.map(async (photoFile, index) => {
                try {
                const timestamp = Date.now();
                const filename = `expenses/${storageFolder}/${expense.category}_${timestamp}_${index}.jpg`;
                const photoRef = window.ref(window.storage, filename);
                await window.uploadBytes(photoRef, photoFile);
                const downloadURL = await window.getDownloadURL(photoRef);
                return downloadURL;
                } catch (error) {
                console.error(`Error uploading photo ${index + 1}:`, error);
                return null;
                }
                });
                
                const newPhotoURLs = (await Promise.all(uploadPromises)).filter(url => url !== null);
                expense.photos = [...existingPhotos, ...newPhotoURLs];
            } else {
                // No new photos, keep existing ones
                expense.photos = existingPhotos;
            }
            
            // Update expense in Firebase - need to find the expense document
            try {
                let expenseDocId = expense.serverId || expense.id;
                let expenseDocRef = expenseDocId ? window.doc(window.db, 'expenses', expenseDocId) : null;

                if (!expenseDocRef) {
                const expensesQuery = window.query(
                window.collection(window.db, 'expenses'),
                window.where('batchId', '==', currentBatch.id)
                );
                const expensesSnapshot = await window.getDocs(expensesQuery);
                const expenseDocs = expensesSnapshot.docs;
                const expenseDoc = expenseDocs[window.editingExpenseIndex];
                if (expenseDoc) {
                expenseDocRef = expenseDoc.ref;
                expenseDocId = expenseDoc.id;
                }
                }

                if (expenseDocRef) {
                await window.updateDoc(expenseDocRef, {
                photos: expense.photos,
                updatedAt: window.serverTimestamp()
                });
                expense.serverId = expenseDocId;
                expense.id = expenseDocId;
                }
            } catch (error) {
                console.error('Error updating expense photos:', error);
            notifyError('Error saving photos. Please try again.');
                return;
            }
            
            // Update the batch in Firebase
            await window.updateDoc(window.doc(window.db, 'expenseBatches', currentBatch.id), {
                updatedAt: window.serverTimestamp()
            });
            
            // Update local batch
            currentBatch.expenses[window.editingExpenseIndex] = expense;
            
        notifySuccess('Photos added successfully!', 'Photos Added');
            
            // Close modal and refresh display
            document.getElementById('expenseModal').classList.add('hidden');
            
            // Reset modal state
            document.getElementById('categorySection').classList.remove('hidden');
            document.getElementById('amountInput').parentElement.classList.remove('hidden');
            const saveBtn = document.getElementById('saveExpenseBtn');
            saveBtn.textContent = 'Save Expense';
            saveBtn.onclick = saveExpense;
            
            renderExpenses();
            
            // Clean up
            window.editingExpenseIndex = undefined;
            currentExpense = { category: null, amount: 0, photos: [] };
        }

        // Save expense
        function saveExpense() {
            if (!currentExpense.category) {
        notifyWarning('Please select a category.', 'Missing Category');
                return;
            }
            
            const amountInput = document.getElementById('amountInput');
            if (!amountInput) {
                console.error('amountInput element not found');
                return;
            }
            
            const amount = parseFloat(amountInput.value);
            if (isNaN(amount) || amount <= 0) {
        notifyWarning('Please enter a valid amount.', 'Invalid Amount');
                return;
            }
            
            currentExpense.amount = amount;
            
            // If offline and photos are attached, block the save so we never lose photos
            if (!navigator.onLine && currentExpense.photos && currentExpense.photos.length > 0) {
        notifyError('You are offline. To ensure your receipt photos are not lost, expenses with photos can only be saved when you have an internet connection.', 'Photos Require Internet');
                return;
            }

            if (currentExpense.photos && currentExpense.photos.length > MAX_PHOTOS_PER_EXPENSE) {
                notifyWarning(`Each expense can include up to ${MAX_PHOTOS_PER_EXPENSE} photos. Remove some before saving.`, 'Photo Limit Reached');
                return;
            }
            
            // Assign to first empty slot for this category (e.g. train1..train4). If user deletes train1, next Train added goes to train1, not train3.
            if (currentBatch.lines && typeof EXPENSE_BATCH_SCHEMA !== 'undefined') {
                if (!currentExpense.photos || currentExpense.photos.length === 0) {
                    notifyWarning('Please add at least one receipt photo.', 'Photo Required');
                    return;
                }
                var catMap = { fuel: 'fuel', charge: 'charge', train: 'train', bus: 'bus', taxi: 'taxi', 'car wash': 'carWash', tolls: 'toll', toll: 'toll', other: 'other' };
                var norm = (currentExpense.category || '').trim().toLowerCase().replace(/\s+/g, ' ');
                var prefix = catMap[norm] || catMap[norm.replace(/\s+/g, '')] || 'other';
                var LINE_KEYS = EXPENSE_BATCH_SCHEMA.LINE_KEYS || [];
                var getCategoryGroup = EXPENSE_BATCH_SCHEMA.getCategoryGroup || (function(k) { return (k || '').replace(/\d+$/, ''); });
                var hasLineContent = EXPENSE_BATCH_SCHEMA.hasLineContent || (function() { return false; });
                var slots = LINE_KEYS.filter(function(k) { return getCategoryGroup(k) === prefix; });
                var lineKey = null; // first slot in category order that has no value (amount or photos)
                for (var s = 0; s < slots.length; s++) {
                    if (!hasLineContent(currentBatch.lines[slots[s]])) {
                        lineKey = slots[s];
                        break;
                    }
                }
                if (!lineKey) {
                    notifyWarning('You have hit your limit of 4 expenses for that category.', 'Limit Reached');
                    return;
                }
                currentBatch.lines[lineKey] = {
                    amount: currentExpense.amount,
                    photos: (currentExpense.photos && currentExpense.photos.length) ? currentExpense.photos.slice() : []
                };
                window.currentBatch = currentBatch;
                window.isUserTyping = false;
                closeExpenseModal();
                renderLines();
                if (window.scheduleAutoSave) window.scheduleAutoSave();
                return;
            }

        }

        // Delete expense
        async function deleteExpense(index) {
            const confirmed = await dialogApi.showConfirmation ? dialogApi.showConfirmation({
                title: 'Delete Expense',
                message: 'Delete this expense? This action cannot be undone.',
                confirmText: 'Delete Expense',
                cancelText: 'Cancel',
                tone: 'danger'
            }) : window.confirm('Delete this expense? This action cannot be undone.');
            if (!confirmed) {
                return;
            }
            
            const expense = currentBatch.expenses[index];
            
            // If batch exists in Firebase and expense has an ID, delete from Firebase
            if (currentBatch.id && expense.id) {
                try {
                await window.deleteDoc(window.doc(window.db, 'expenses', expense.id));
                console.log('Expense deleted from Firebase:', expense.id);
                } catch (error) {
                console.error('Error deleting expense from Firebase:', error);
                notifyWarning('Error deleting expense from the database. It has been removed locally but may still appear until refreshed.', 'Partial Deletion');
                }
            }
            
            // Remove from local array
            currentBatch.expenses.splice(index, 1);
            
            // Update batch total
            const total = currentBatch.expenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
            currentBatch.totalAmount = total;
            
            // If batch exists in Firebase, update the total
            if (currentBatch.id) {
                try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', currentBatch.id), {
                totalAmount: total,
                updatedAt: window.serverTimestamp()
                });
                } catch (error) {
                console.error('Error updating batch total:', error);
                }
            }
            
            // Re-render expenses (will defer if user is typing)
            renderExpenses();
        }

        // Save as draft
        // Helper function to normalize registration (remove spaces)
        function normalizeReg(reg) {
            return reg.replace(/\s+/g, '');
        }

        // Helper function to check if a registration exists and add ! suffix if needed
        async function getUniqueReg(baseReg, excludeBatchId = null) {
            const normalizedReg = normalizeReg(baseReg);
            
            // Limit to recent batches only ‚Äî avoid loading thousands and blocking save/submit
            const batchesQuery = window.query(
                window.collection(window.db, 'expenseBatches'),
                window.where('officeId', '==', currentUser.officeId),
                window.orderBy('updatedAt', 'desc'),
                window.limit(300)
            );
            const batchesSnapshot = await window.getDocs(batchesQuery);
            
            const existingRegs = new Set();
            batchesSnapshot.docs.forEach(doc => {
                // Skip the current batch if updating
                if (excludeBatchId && doc.id === excludeBatchId) {
                return;
                }
                const data = doc.data();
                if (data.registration) {
                const reg = normalizeReg(data.registration);
                existingRegs.add(reg);
                }
            });
            
            // If the exact reg doesn't exist, return it
            if (!existingRegs.has(normalizedReg)) {
                return normalizedReg;
            }
            
            // Otherwise, add ! (and incrementing exclamation marks if needed)
            // Format: REG, REG!, REG!!, REG!!!, etc.
            let exclamationCount = 1;
            while (true) {
                const suffix = '!'.repeat(exclamationCount);
                const newReg = `${normalizedReg}${suffix}`;
                if (!existingRegs.has(newReg)) {
                return newReg;
                }
                exclamationCount++;
                
                // Safety limit to prevent infinite loop
                if (exclamationCount > 100) {
                    console.error('Too many duplicate registrations, using timestamp suffix');
                    return `${normalizedReg}!${Date.now()}`;
                }
            }
        }

        async function saveDraft() {
            let registration = document.getElementById('regInput').value.trim().toUpperCase();
            if (!registration) {
                notifyWarning('Please enter a registration number.', 'Missing Registration');
                return;
            }
            // Allow draft with no expenses (user may add later); submit still requires ‚â•1 expense

            // Confirmation dialog
            const confirmed = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Save Draft',
                message: 'Are you sure you want to save this draft?',
                confirmText: 'Save Draft',
                cancelText: 'Cancel',
                tone: 'info'
            }) : window.confirm('Are you sure you want to save this draft?');
            if (!confirmed) {
                return;
            }

            // Disable buttons to prevent double submission
            const saveBtn = document.querySelector('button[onclick="saveDraft()"]');
            const submitBtn = document.querySelector('button[onclick="submitBatch()"]');
            if (saveBtn) saveBtn.disabled = true;
            if (submitBtn) submitBtn.disabled = true;

            // Close modal immediately after confirmation
            document.getElementById('batchModal').classList.add('hidden');
            document.body.style.overflow = '';
            // Prevent modal from being reopened during upload
            window.isUploadingExpense = true;

            // Photos will be uploaded synchronously in saveExpenses before expenses are saved
            // No need to check for pending uploads here

            // Prepare batch details prior to queueing so the offline copy is complete
            currentBatch.registration = registration;
            currentBatch.driverId = currentUser.uid;
            currentBatch.driverEmail = currentUser.email;
            currentBatch.driverName =
                currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim() || 'Unknown Driver';
            currentBatch.officeId = currentUser.officeId;
            currentBatch.status = 'draft';
            const notes = document.getElementById('notesInput').value.trim();
            currentBatch.notes = notes || '';

            // Update upload status immediately to show banner
            if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
            }

            let queuedLocalId = null;
            try {
                queuedLocalId = await queueExpenseAction('draft');
            } catch (error) {
                console.error('Error queueing draft for upload:', error);
            }

            // Update upload status again after queueing
            if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
            }

            // CRITICAL: Add batch to local list immediately so it shows greyed out
            if (currentBatch && currentBatch.localId) {
                const totalAmount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getTotalFromLines && currentBatch.lines) ? EXPENSE_BATCH_SCHEMA.getTotalFromLines(currentBatch.lines) : 0;
                const localBatch = {
                    id: currentBatch.id || `temp_${currentBatch.localId}`,
                    localId: currentBatch.localId,
                    registration: currentBatch.registration,
                    status: 'draft',
                    totalAmount,
                    lines: currentBatch.lines || {},
                    hasPendingUploads: true,
                    driverId: currentBatch.driverId,
                    officeId: currentBatch.officeId,
                    notes: currentBatch.notes,
                    createdAt: new Date(),
                    updatedAt: new Date()
                };
                
                // Add to allBatches if not already there
                const existingIndex = allBatches.findIndex(b => b.localId === currentBatch.localId);
                if (existingIndex >= 0) {
                    allBatches[existingIndex] = { ...allBatches[existingIndex], ...localBatch };
                } else {
                    allBatches.unshift(localBatch); // Add to beginning
                }
                batchIdsGreyedUntilUploadDone.add(localBatch.id);
                // Refresh display immediately (stays greyed)
                displayBatches();
            }

            // CRITICAL FIX: In PWA mode (especially iOS), navigator.onLine can be unreliable
            // Always try to sync first, and only queue if sync actually fails
            // This ensures PWA mode works correctly even when navigator.onLine reports false
            
            try {
                const savedBatch = await syncDraftToFirestore(currentBatch, 'draft');
                
                // Ensure currentBatch.id is updated from syncDraftToFirestore
                if (savedBatch && savedBatch.id) {
                    currentBatch.id = savedBatch.id;
                    window.currentBatch = currentBatch;
                    batchIdsGreyedUntilUploadDone.delete(`temp_${currentBatch.localId}`);
                    batchIdsGreyedUntilUploadDone.add(savedBatch.id);
                    // Update local batch with real ID
                    const localIndex = allBatches.findIndex(b => b.localId === currentBatch.localId);
                    if (localIndex >= 0) {
                        allBatches[localIndex].id = savedBatch.id;
                    }
                }

                if (queuedLocalId) {
                removeSubmissionQueueEntry(queuedLocalId);
                // Update upload status using new ExpenseUploadQueue
                if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
                }
                }

                // Don't refetch immediately - keeps card solid greyed until upload-complete un-greys it
                setTimeout(async () => {
                    if (typeof window.loadExpenseBatches === 'function') await window.loadExpenseBatches().catch(() => {});
                }, 3000);

                // No success message - banner is enough
                currentBatch = null;
                window.currentBatch = null;
                window.isUploadingExpense = false;
                if (saveBtn) saveBtn.disabled = false;
                if (submitBtn) submitBtn.disabled = false;
            } catch (error) {
                console.error('Error syncing draft:', error);
                
                const isNetworkError = error.message && (
                    error.message.includes('network') || 
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('offline') ||
                    !navigator.onLine
                );
                
                if (!isNetworkError) {
                    notifyError(error.message || 'Failed to save draft.', 'Save Failed');
                }
                if (isNetworkError && queuedLocalId) {
                    console.log('[saveDraft] Network error, batch queued for later sync:', queuedLocalId);
                } else if (!queuedLocalId) {
                    console.warn('[saveDraft] Sync failed and not queued, attempting to queue now');
                    try {
                        await queueExpenseAction('draft');
                    } catch (queueError) {
                        console.error('[saveDraft] Failed to queue after sync error:', queueError);
                    }
                }
                
                currentBatch = null;
                window.currentBatch = null;
                window.isUploadingExpense = false;
                if (saveBtn) saveBtn.disabled = false;
                if (submitBtn) submitBtn.disabled = false;
            }
        }

        // Submit batch for review
        async function submitBatch() {
            let registration = document.getElementById('regInput').value.trim().toUpperCase();
            if (!registration) {
                notifyWarning('Please enter a registration number.', 'Missing Registration');
                return;
            }

            const usedCount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(currentBatch) : 0;
            if (usedCount === 0) {
                notifyWarning('Please add at least one expense (amount or photo).', 'No Expenses Added');
                return;
            }

            // Photos will be uploaded synchronously in saveExpenses before expenses are saved
            // No need to check for pending uploads here

            const confirmed = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Submit Expense Batch',
                message: 'Are you sure you want to submit this expense?',
                confirmText: 'Submit',
                cancelText: 'Cancel',
                tone: 'info'
            }) : window.confirm('Are you sure you want to submit this expense?');
            if (!confirmed) {
                return;
            }

            // Disable buttons to prevent double submission
            const saveBtn = document.querySelector('button[onclick="saveDraft()"]');
            const submitBtn = document.querySelector('button[onclick="submitBatch()"]');
            if (saveBtn) saveBtn.disabled = true;
            if (submitBtn) submitBtn.disabled = true;

            // Close modal immediately after confirmation
            document.getElementById('batchModal').classList.add('hidden');
            document.body.style.overflow = '';
            // Prevent modal from being reopened during upload
            window.isUploadingExpense = true;

            // Prepare batch for queueing
            const isAppeal = currentBatch.status === 'returned';
            currentBatch.registration = registration;
            currentBatch.driverId = currentUser.uid;
            currentBatch.driverEmail = currentUser.email;
            currentBatch.driverName =
                currentUser.name || `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim() || 'Unknown Driver';
            currentBatch.officeId = currentUser.officeId;
            const notes = document.getElementById('notesInput').value.trim();
            
            // If this is an appeal (resubmitting a returned batch), append appeal notes to communications
            if (isAppeal) {
                if (notes) {
                    if (!Array.isArray(currentBatch.communications)) {
                        currentBatch.communications = [];
                    }
                    currentBatch.communications.push({
                        from: 'driver',
                        authorName: currentBatch.driverName,
                        message: notes,
                        createdAt: Date.now()
                    });
                }
                // Clear notes field for appeals (communications is the source of truth)
                currentBatch.notes = '';
            } else {
                // For new submissions, store notes normally
                currentBatch.notes = notes || '';
            }
            
            currentBatch.status = 'pending';

            // Update upload status immediately to show banner
            if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
            }

            let queuedLocalId = null;
            try {
                queuedLocalId = await queueExpenseAction('pending');
            } catch (error) {
                console.error('Error queueing submission for upload:', error);
            }

            // Update upload status again after queueing
            if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                await window.expenseUploadQueue.updateGlobalUploadStatus();
            }

            // CRITICAL: Add/update batch in local list immediately so it shows greyed out
            // This ensures user sees the expense appear right away (works for both new submissions and appeals)
            const targetStatus = 'pending';
            
            if (currentBatch && (currentBatch.id || currentBatch.localId)) {
                const totalAmount = (EXPENSE_BATCH_SCHEMA && EXPENSE_BATCH_SCHEMA.getTotalFromLines && currentBatch.lines) ? EXPENSE_BATCH_SCHEMA.getTotalFromLines(currentBatch.lines) : 0;
                const localBatch = {
                    id: currentBatch.id || `temp_${currentBatch.localId}`,
                    localId: currentBatch.localId,
                    registration: currentBatch.registration,
                    status: targetStatus,
                    totalAmount,
                    lines: currentBatch.lines || {},
                    hasPendingUploads: true,
                    driverId: currentBatch.driverId,
                    officeId: currentBatch.officeId,
                    notes: currentBatch.notes,
                    submittedAt: isAppeal ? currentBatch.submittedAt : new Date(),
                    updatedAt: new Date()
                };
                
                // Update or add to allBatches
                const existingIndex = currentBatch.id 
                    ? allBatches.findIndex(b => b.id === currentBatch.id)
                    : allBatches.findIndex(b => b.localId === currentBatch.localId);
                    
                if (existingIndex >= 0) {
                    // Update existing batch (for appeals, move from returned to pending)
                    allBatches[existingIndex] = { ...allBatches[existingIndex], ...localBatch };
                } else {
                    // Add new batch
                    allBatches.unshift(localBatch);
                }
                if (localBatch.id) batchIdsGreyedUntilUploadDone.add(localBatch.id);
                // Refresh display immediately (stays greyed via batchIdsGreyedUntilUploadDone)
                displayBatches();
            }

            // CRITICAL FIX: In PWA mode (especially iOS), navigator.onLine can be unreliable
            // Always try to sync first, and only queue if sync actually fails
            // This ensures PWA mode works correctly even when navigator.onLine reports false
            
            try {
                // Ensure currentBatch.id is set before syncing
                // If missing, save as draft first to create the batch ID
                // This is especially important when expenses have photos that need uploading
                const hadNoBatchId = !currentBatch.id;
                if (!currentBatch.id) {
                    console.log('[submitBatch] Batch ID missing, saving as draft first to create batch ID...');
                    try {
                        await syncDraftToFirestore(currentBatch, 'draft');
                        console.log('[submitBatch] Batch saved as draft, batch ID:', currentBatch.id);
                        
                        // Update local batch with real ID
                        const localIndex = allBatches.findIndex(b => b.localId === currentBatch.localId);
                        if (localIndex >= 0) {
                            allBatches[localIndex].id = currentBatch.id;
                        }
                    } catch (error) {
                        console.error('[submitBatch] Failed to save batch as draft:', error);
                        notifyError('Cannot submit: failed to create batch. Please try saving as draft first, then submit.', 'Batch Creation Failed');
                        currentBatch = null;
                        window.currentBatch = null;
                        window.isUploadingExpense = false;
                        if (saveBtn) saveBtn.disabled = false;
                        if (submitBtn) submitBtn.disabled = false;
                        return;
                    }
                }
                
                const batchId = currentBatch.id;
                if (!batchId) {
                    console.error('[submitBatch] Batch ID is still missing after draft save attempt');
                    notifyError('Cannot submit: batch ID is missing. Please save as draft first, then try submitting again.', 'Missing Batch ID');
                    currentBatch = null;
                    window.currentBatch = null;
                    window.isUploadingExpense = false;
                    if (saveBtn) saveBtn.disabled = false;
                    if (submitBtn) submitBtn.disabled = false;
                    return;
                }
                
                // Leakproof: if we just created the batch in this flow, only update status to pending
                // (do NOT call saveExpenses again ‚Äî would delete/recreate expenses and duplicate photo uploads)
                if (hadNoBatchId) {
                    await updateBatchStatusToPending(batchId, currentBatch);
                } else {
                    await syncDraftToFirestore(currentBatch, 'pending');
                }

                if (queuedLocalId) {
                removeSubmissionQueueEntry(queuedLocalId);
                }

                // Update upload status to ensure banner shows
                if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                    await window.expenseUploadQueue.updateGlobalUploadStatus();
                }

                // Update local batch with real data from Firestore
                const localIndex = allBatches.findIndex(b => b.id === batchId || b.localId === currentBatch.localId);
                if (localIndex >= 0) {
                    allBatches[localIndex].id = batchId;
                    allBatches[localIndex].status = 'pending';
                    batchIdsGreyedUntilUploadDone.add(batchId);
                }
                // Refresh display once (stays greyed until upload-complete removes from set)
                displayBatches();

                // Defer refetch so card stays solid greyed until uploads finish
                setTimeout(async () => {
                    if (typeof window.loadExpenseBatches === 'function') await window.loadExpenseBatches().catch(() => {});
                    if (window.expenseUploadQueue && typeof window.expenseUploadQueue.updateGlobalUploadStatus === 'function') {
                        await window.expenseUploadQueue.updateGlobalUploadStatus();
                    }
                }, 2500);

                // No success message - banner is enough
                // Note: isUploadingExpense will be set to false after all uploads complete
                // (handled by upload queue when banner is hidden)
                // Close modal and return to list
                document.getElementById('batchModal').classList.add('hidden');
                document.body.style.overflow = '';
                currentBatch = null;
                window.currentBatch = null;
                if (saveBtn) saveBtn.disabled = false;
                if (submitBtn) submitBtn.disabled = false;
            } catch (error) {
                console.error('Error submitting batch:', error);
                
                const isNetworkError = error.message && (
                    error.message.includes('network') || 
                    error.message.includes('Failed to fetch') ||
                    error.message.includes('offline') ||
                    !navigator.onLine
                );
                
                if (!isNetworkError) {
                    notifyError(error.message || 'Failed to submit batch.', 'Submit Failed');
                }
                if (isNetworkError && queuedLocalId) {
                    console.log('[submitBatch] Network error, batch queued for later sync:', queuedLocalId);
                } else if (!queuedLocalId) {
                    console.warn('[submitBatch] Sync failed and not queued, attempting to queue now');
                    try {
                        await queueExpenseAction('pending');
                    } catch (queueError) {
                        console.error('[submitBatch] Failed to queue after sync error:', queueError);
                    }
                }
                
                document.getElementById('batchModal').classList.add('hidden');
                document.body.style.overflow = '';
                currentBatch = null;
                window.currentBatch = null;
                window.isUploadingExpense = false;
                if (saveBtn) saveBtn.disabled = false;
                if (submitBtn) submitBtn.disabled = false;
            }
        }

        // Sanitize registration for Firebase Storage path (no / or \ in folder names)
        function sanitizeRegForStoragePath(reg) {
            if (!reg || typeof reg !== 'string') return '';
            return reg.replace(/[/\\]/g, '_').trim() || '';
        }

        // Helper function to extract storage path from Firebase Storage download URL
        function extractStoragePathFromURL(downloadURL) {
            try {
                // Firebase Storage URLs format: https://firebasestorage.googleapis.com/v0/b/{bucket}/o/{encodedPath}?alt=media&token={token}
                const url = new URL(downloadURL);
                const pathMatch = url.pathname.match(/\/o\/(.+)/);
                if (pathMatch) {
                    // Decode the encoded path (URL encoding)
                    return decodeURIComponent(pathMatch[1]);
                }
                return null;
            } catch (error) {
                console.warn('[deleteBatch] Failed to extract storage path from URL:', downloadURL, error);
                return null;
            }
        }

        const FIREBASE_STORAGE_URL_PREFIX = 'https://firebasestorage.googleapis.com/v0/b/soto-routes.firebasestorage.app/';
        // Refresh Firebase Storage photo URLs (getDownloadURL gives fresh token). Needed because tokens can be revoked in Firebase Console; we also only persist URLs with token in upload-complete.
        async function refreshFirebasePhotoURLs(batch) {
            if (!batch || !batch.lines || !window.storage || typeof window.ref !== 'function' || typeof window.getDownloadURL !== 'function') return;
            var updated = false;
            for (var lineKey in batch.lines) {
                var line = batch.lines[lineKey];
                if (!line || !Array.isArray(line.photos)) continue;
                for (var i = 0; i < line.photos.length; i++) {
                    var p = line.photos[i];
                    if (typeof p !== 'string' || p.indexOf(FIREBASE_STORAGE_URL_PREFIX) !== 0) continue;
                    var path = extractStoragePathFromURL(p);
                    if (!path) continue;
                    try {
                        var photoRef = window.ref(window.storage, path);
                        var freshURL = await window.getDownloadURL(photoRef);
                        if (freshURL && freshURL !== p) {
                            line.photos[i] = freshURL;
                            updated = true;
                        }
                    } catch (err) {
                        console.warn('[refreshFirebasePhotoURLs] Failed to refresh URL for', path, err);
                    }
                }
            }
            if (updated && currentBatch === batch && typeof renderLines === 'function') renderLines();
        }

        // Delete batch
        async function deleteBatch() {
             const confirmed = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Delete Expense Batch',
                message: 'Delete this expense batch? This cannot be undone.',
                confirmText: 'Delete Batch',
                cancelText: 'Cancel',
                tone: 'danger'
             }) : window.confirm('Delete this expense batch? This cannot be undone.');
             if (!confirmed) {
                return;
             }
 
             try {
                const deletedId = currentBatch?.id || null;
                const deletedLocalId = currentBatch?.localId || null;
                const localCopy = currentBatch;
                const photoDeletePromises = [];

                for (const line of Object.values(currentBatch.lines || {})) {
                    if (line && Array.isArray(line.photos)) {
                        for (const photoURL of line.photos) {
                            if (typeof photoURL === 'string' && photoURL.startsWith('http')) {
                                try {
                                    const storagePath = extractStoragePathFromURL(photoURL);
                                    if (storagePath) {
                                        const photoRef = window.ref(window.storage, storagePath);
                                        photoDeletePromises.push(window.deleteObject(photoRef).catch(err => { console.warn('[deleteBatch] Photo delete failed', err); }));
                                    }
                                } catch (e) { console.warn('[deleteBatch] URL parse failed', e); }
                            }
                        }
                    }
                }

                await Promise.allSettled(photoDeletePromises);
                await window.deleteDoc(window.doc(window.db, 'expenseBatches', currentBatch.id));

                // Clean up upload queue for this batch
                if (window.expenseUploadQueue && deletedId) {
                    try {
                        await window.expenseUploadQueue.cleanupBatchUploads(deletedId);
                        console.log('[deleteDraft] Cleaned up upload queue for batch:', deletedId);
                    } catch (error) {
                        console.warn('[deleteDraft] Failed to cleanup upload queue:', error);
                    }
                }
 
                if (deletedLocalId) {
                removeSubmissionQueueEntry(deletedLocalId);
                }
                if (window.expenseDraftDB && deletedLocalId) {
                try {
                await window.expenseDraftDB.deleteDraft(deletedLocalId);
                } catch (error) {
                console.warn('Unable to remove draft from offline storage:', error);
                }
                }
                if (localCopy) {
                allBatches = allBatches.filter((batch) => {
                if (deletedId && batch.id) {
                return batch.id !== deletedId;
                }
                if (deletedLocalId && batch.localId) {
                return batch.localId !== deletedLocalId;
                }
                return batch.id !== localCopy.id;
                });
                displayBatches();
                }
 
                notifySuccess('Batch deleted successfully.', 'Batch Deleted');
                closeBatchModal();
                await loadExpenseBatches();
             } catch (error) {
                console.error('Error deleting batch:', error);
             notifyError('Error deleting batch. Please try again.');
            }
        }

        // Discard returned batch
        async function discardReturnedBatch() {
             const confirmed = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Discard Returned Expense',
                message: 'Discard this returned expense? This will permanently delete it and cannot be undone.',
                confirmText: 'Discard Expense',
                cancelText: 'Cancel',
                tone: 'danger'
             }) : window.confirm('Discard this returned expense? This cannot be undone.');
             if (!confirmed) {
                return;
             }
 
             try {
                const deletedId = currentBatch?.id || null;
                const deletedLocalId = currentBatch?.localId || null;
                const localCopy = currentBatch;
 
                const photoDeletePromises = [];
                for (const line of Object.values(currentBatch.lines || {})) {
                    if (line && Array.isArray(line.photos)) {
                        for (const photoURL of line.photos) {
                            if (typeof photoURL === 'string' && photoURL.startsWith('http')) {
                                try {
                                    const storagePath = extractStoragePathFromURL(photoURL);
                                    if (storagePath) {
                                        const photoRef = window.ref(window.storage, storagePath);
                                        photoDeletePromises.push(window.deleteObject(photoRef).catch(error => {
                                            console.warn(`[discardReturnedBatch] Failed to delete photo: ${photoURL}`, error);
                                        }));
                                    }
                                } catch (error) {
                                    console.warn(`[discardReturnedBatch] Error processing photo URL: ${photoURL}`, error);
                                }
                            }
                        }
                    }
                }
                await Promise.allSettled(photoDeletePromises);

                // Delete the batch
                await window.deleteDoc(window.doc(window.db, 'expenseBatches', currentBatch.id));
 
                if (deletedLocalId) {
                removeSubmissionQueueEntry(deletedLocalId);
                }
                if (window.expenseDraftDB && deletedLocalId) {
                try {
                await window.expenseDraftDB.deleteDraft(deletedLocalId);
                } catch (error) {
                console.warn('Unable to remove draft from offline storage:', error);
                }
                }
                if (localCopy) {
                allBatches = allBatches.filter((batch) => {
                if (deletedId && batch.id) {
                return batch.id !== deletedId;
                }
                if (deletedLocalId && batch.localId) {
                return batch.localId !== deletedLocalId;
                }
                return batch.id !== localCopy.id;
                });
                displayBatches();
                }
 
                notifySuccess('Expense discarded successfully.', 'Expense Discarded');
                closeBatchModal();
                await loadExpenseBatches();
             } catch (error) {
                console.error('Error discarding batch:', error);
             notifyError('Error discarding expense. Please try again.');
            }
        }

        // Add additional expenses (creates new batch with same reg + *)
        async function addAdditionalExpenses() {
            const confirmed = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Add Additional Expenses',
                message: 'Create a new expense batch with the same registration? This will allow you to add additional expenses.',
                confirmText: 'Create New Batch',
                cancelText: 'Cancel',
                tone: 'info'
            }) : window.confirm('Create a new expense batch with the same registration?');
            if (!confirmed) {
                return;
            }

            try {
                // Get the base registration (remove asterisk if present)
                let baseReg = normalizeReg(currentBatch.registration);
                baseReg = baseReg.replace(/[*!]\d*$/, ''); // Remove trailing suffix if present
                
                // Get unique reg (will add ! if needed)
                const newReg = await getUniqueReg(baseReg);

                const emptyLines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.emptyLines) ? EXPENSE_BATCH_SCHEMA.emptyLines() : {};
                currentBatch = {
                    id: null,
                    localId: null,
                    registration: newReg,
                    status: 'draft',
                    lines: emptyLines,
                    totalAmount: 0
                };
                window.currentBatch = currentBatch;

                // Update UI
                setStatusTitle('draft');
                document.getElementById('regInput').value = newReg;
                document.getElementById('regInput').disabled = false;
                const notesSection = document.getElementById('notesSection');
                notesSection.classList.remove('hidden');
                const notesLabel = document.getElementById('notesLabel');
                if (notesLabel) notesLabel.textContent = 'NOTES (Optional)';
                const notesInput = document.getElementById('notesInput');
                notesInput.value = '';
                notesInput.placeholder = 'Add any additional notes...';
                notesInput.disabled = false;
                const commsSection = document.getElementById('communicationsSection');
                if (commsSection) commsSection.classList.add('hidden');
                document.getElementById('deleteBatchBtn').classList.add('hidden');
                const expensesListEl = document.getElementById('expensesList');
                if (expensesListEl) { expensesListEl.classList.add('hidden'); expensesListEl.innerHTML = ''; }
                const linesContainer = document.getElementById('linesContainer');
                if (linesContainer) { linesContainer.classList.remove('hidden'); renderLines(); }
                document.getElementById('totalAmount').textContent = '¬£0.00';
                const addExpenseBtn = document.getElementById('addExpenseBtn');
                if (addExpenseBtn) addExpenseBtn.classList.remove('hidden');
                const actionButtons = document.getElementById('actionButtons');
                actionButtons.innerHTML = `
                <button onclick="saveDraft()" class="w-full animated-button animated-button-draft touch-target">
                <span class="text-white font-semibold">Save as Draft</span>
                </button>
                <button onclick="submitBatch()" class="w-full animated-button animated-button-submit touch-target">
                <span class="text-white font-semibold">Submit for Processing</span>
                </button>
                `;
                document.getElementById('batchModal').classList.remove('hidden');
                document.body.style.overflow = 'hidden';
            } catch (error) {
                console.error('Error creating additional expenses batch:', error);
                notifyError('Error creating additional expenses batch. Please try again.');
            }
        }

        // View photos for a batch line (used when batch has lines)
        async function viewExpensePhotos(expenseIndex) {
            const expense = currentBatch.expenses && currentBatch.expenses[expenseIndex];
            const filePhotos = (expense && expense.photos) ? expense.photos.filter(p => p instanceof File || p instanceof Blob) : [];
            const validURLs = getValidPhotoURLs(expense);
            if (filePhotos.length === 0 && validURLs.length === 0) {
                return;
            }

            const grid = document.getElementById('photoViewerGrid');
            
            if (filePhotos.length > 0) {
                grid.innerHTML = filePhotos.map((file) => `
                <div class="mb-4">
                <img src="${URL.createObjectURL(file)}" class="w-full rounded-lg">
                </div>
                `).join('');
            } else {
                // Only show valid image URLs (avoids black/broken images)
                grid.innerHTML = validURLs.map((url, index) => `
                <div class="mb-4">
                <img src="${url}" class="w-full rounded-lg" alt="Expense photo ${index + 1}">
                </div>
                `).join('');
            }

            document.getElementById('photoViewerModal').classList.remove('hidden');
        }

        // View photos from current expense being edited
        function viewCurrentExpensePhotos(startIndex = 0) {
            const filePhotos = (currentExpense && currentExpense.photos) ? currentExpense.photos.filter(p => p instanceof File || p instanceof Blob) : [];
            const validURLs = getValidPhotoURLs(currentExpense);
            if (filePhotos.length === 0 && validURLs.length === 0) {
                return;
            }

            const grid = document.getElementById('photoViewerGrid');
            
            if (filePhotos.length > 0) {
                grid.innerHTML = filePhotos.map((file, index) => `
                <div class="mb-4">
                <img src="${URL.createObjectURL(file)}" class="w-full rounded-lg" alt="Receipt photo ${index + 1}">
                </div>
                `).join('');
            } else {
                grid.innerHTML = validURLs.map((url, index) => `
                <div class="mb-4">
                <img src="${url}" class="w-full rounded-lg" alt="Receipt photo ${index + 1}">
                </div>
                `).join('');
            }

            document.getElementById('photoViewerModal').classList.remove('hidden');
        }

        // Close photo viewer
        function closePhotoViewer() {
            document.getElementById('photoViewerModal').classList.add('hidden');
            document.getElementById('photoViewerGrid').innerHTML = '';
        }

        // Check if there are unsaved changes
        function hasUnsavedChanges() {
            if (!currentBatch) return false;
            
            // Check if it's a new batch with data
            if (!currentBatch.id) {
                // Check if there's a registration entered
                const registration = document.getElementById('regInput').value.trim();
                if (registration) return true;
                
                // Check if there are any expenses
                if (currentBatch.expenses && currentBatch.expenses.length > 0) {
                return true;
                }
                
                // Check if there are notes
                const notes = document.getElementById('notesInput').value.trim();
                if (notes) return true;
            }
            
            return false;
        }

        // Close modals
        async function closeBatchModal() {
            // Prevent closing during upload
            if (window.isUploadingExpense) {
                notifyWarning('Please wait for the upload to complete before closing.', 'Upload in Progress');
                return;
            }

            // Check if there are unsaved changes
            if (hasUnsavedChanges()) {
                // Show custom modal for save/discard choice
                const shouldSave = dialogApi.showConfirmation ? await dialogApi.showConfirmation({
                title: 'Save Draft?',
                message: 'You have unsaved changes. Save them as a draft before closing?',
                confirmText: 'Save Draft',
                cancelText: 'Discard',
                tone: 'warning'
                }) : window.confirm('You have unsaved changes. Save them as a draft before closing?');
                if (shouldSave) {
                // User wants to save
                await saveDraft();
                return;
                } else {
                // User wants to discard - close without saving
                document.getElementById('batchModal').classList.add('hidden');
                document.body.style.overflow = '';
                currentBatch = null;
                }
            } else {
                // No unsaved changes, just close
                document.getElementById('batchModal').classList.add('hidden');
                document.body.style.overflow = '';
                currentBatch = null;
            }
        }
        
        // Update close button state based on upload status
        function updateCloseButtonState() {
            const closeBtn = document.getElementById('closeBatchModalBtn');
            if (closeBtn) {
                if (window.isUploadingExpense) {
                    closeBtn.disabled = true;
                    closeBtn.classList.add('opacity-50', 'cursor-not-allowed');
                    closeBtn.classList.remove('hover:text-white');
                } else {
                    closeBtn.disabled = false;
                    closeBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                    closeBtn.classList.add('hover:text-white');
                }
            }
        }
        
        // Monitor upload status and update close button
        setInterval(updateCloseButtonState, 500);

        function closeExpenseModal() {
            // Clear any border classes when closing
            clearExpenseModalBorders();
            
            const expenseModal = document.getElementById('expenseModal');
            if (expenseModal) expenseModal.classList.add('hidden');
            
            currentExpense = { category: null, amount: 0, photos: [] };
            
            // Reset modal state
            const categorySection = document.getElementById('categorySection');
            if (categorySection) categorySection.classList.remove('hidden');
            
            const amountInput = document.getElementById('amountInput');
            if (amountInput && amountInput.parentElement) {
                amountInput.parentElement.classList.remove('hidden');
            }
            
            const saveBtn = document.getElementById('saveExpenseBtn');
            if (saveBtn) {
                saveBtn.textContent = 'Save Expense';
                saveBtn.onclick = saveExpense;
            }
            
            const photoPreview = document.getElementById('photoPreview');
            if (photoPreview) photoPreview.innerHTML = '';
            
            window.editingExpenseIndex = undefined;
        }

        // Go back to portal
        function goToPortal() {
            window.location.href = '/pages/driver-portal.html';
        }

        // Render paid batch list with PDF/photo options
        function renderPaidBatchList(batches, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = batches.map(batch => {
                const itemCount = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(batch) : 0;
                let totalPhotos = 0;
                if (batch.lines && typeof batch.lines === 'object') {
                    for (const line of Object.values(batch.lines)) {
                        if (line && Array.isArray(line.photos)) totalPhotos += line.photos.filter(p => typeof p === 'string').length;
                    }
                }
                return `
                <div class="animated-border-panel animated-border-paid fade-in">
                <div class="flex items-start justify-between mb-2">
                <div class="license-plate">${batch.registration}</div>
                <span class="bg-green-500 px-3 py-1 rounded-full text-xs font-semibold uppercase">PAID</span>
                </div>
                <div class="flex items-center justify-between mt-3 mb-2">
                <span class="text-gray-400 text-sm">${itemCount} Expense${itemCount !== 1 ? 's' : ''}</span>
                <span class="text-green-500 font-semibold text-lg">¬£${batch.totalAmount?.toFixed(2) || '0.00'}</span>
                </div>
                <div class="flex gap-2 mt-3">
                <button onclick="event.stopPropagation(); viewPaidExpensePDF('${batch.id}')" 
                class="flex-1 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-semibold rounded-lg transition-colors flex items-center justify-center gap-2 touch-target">
                <span class="material-symbols-outlined text-sm">description</span>
                View PDF
                </button>
                <button onclick="event.stopPropagation(); downloadPaidExpensePDF('${batch.id}')" 
                class="flex-1 py-2 bg-green-600 hover:bg-green-700 text-white text-sm font-semibold rounded-lg transition-colors flex items-center justify-center gap-2 touch-target">
                <span class="material-symbols-outlined text-sm">download</span>
                Download
                </button>
                ${totalPhotos > 0 ? `
                <button onclick="event.stopPropagation(); viewPaidExpensePhotos('${batch.id}')" 
                class="py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white text-sm font-semibold rounded-lg transition-colors flex items-center justify-center gap-2 touch-target">
                <span class="material-symbols-outlined text-sm">photo_camera</span>
                ${totalPhotos}
                </button>
                ` : ''}
                </div>
                </div>
                `;
            }).join('');
        }

        // Generate PDF for paid expense batch (matching app layout exactly)
        function generatePaidExpensePDF(batch) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Get dates
            const paymentDate = batch.paidAt?.toDate ? batch.paidAt.toDate() : 
                (batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date());
            const submissionDate = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
            const validationDate = batch.validatedAt?.toDate ? batch.validatedAt.toDate() : null;
            const processedDate = batch.processedAt?.toDate
                ? batch.processedAt.toDate()
                : (batch.processedAt instanceof Date
                ? batch.processedAt
                : (batch.processedAt ? new Date(batch.processedAt) : null));
            
            // Format dates (medium date style with short time)
            const formatDate = (date) => {
                if (!date) return 'Not set';
                const options = { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
                };
                return date.toLocaleDateString('en-GB', options);
            };
            
            const ptToMm = 0.352778; // Conversion factor: 1pt = 0.352778mm
            let y = 32 * ptToMm; // Start at 32pt = 11.3mm (matching app)
            
            // Title - centered, 28pt bold
            doc.setFontSize(28);
            doc.setFont(undefined, 'bold');
            const titleWidth = doc.getTextWidth('Expense Report');
            doc.text('Expense Report', (210 - titleWidth) / 2, y);
            y += 24 * ptToMm; // 24pt = 8.5mm
            
            // Information section - 16pt medium weight
            doc.setFontSize(16);
            doc.setFont(undefined, 'normal');
            const infoStartX = 48 * ptToMm; // 48pt left margin = 17mm (matching app)
            doc.text(`Registration: ${batch.registration}`, infoStartX, y);
            y += 24 * ptToMm; // 24pt = 8.5mm
            doc.text(`Driver: ${batch.driverName || 'Unknown'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Submitted on: ${formatDate(submissionDate)}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Validated on: ${validationDate ? formatDate(validationDate) : 'Not validated'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Paid on: ${paymentDate ? formatDate(paymentDate) : 'Not paid'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Processed on: ${processedDate ? formatDate(processedDate) : 'Not processed'}`, infoStartX, y);
            y += 28 * ptToMm; // 28pt = 9.9mm before table
            
            // Table setup (matching app dimensions)
            const tableStartY = y;
            const pageWidth = 210; // A4 width in mm
            const leftMargin = 48 * 0.352778; // 48pt in mm ‚âà 17mm
            const tableWidth = pageWidth - (leftMargin * 2);
            const col0 = 42.33; // Category column in mm
            const colRest = (tableWidth - col0) / 5;
            
            // Category normalization map
            const categoryMap = {
                'fuel': 'Fuel',
                'charge': 'Charge',
                'train': 'Train',
                'train fare': 'Train',
                'bus': 'Bus',
                'taxi': 'Taxi',
                'car wash': 'Car Wash',
                'carwash': 'Car Wash',
                'toll': 'Tolls',
                'tolls': 'Tolls',
                'other': 'Other'
            };
            
            const categories = ['Fuel', 'Charge', 'Train', 'Bus', 'Taxi', 'Car Wash', 'Tolls', 'Other'];
            
            const expensesByCategory = {};
            const usedLines = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLines) ? EXPENSE_BATCH_SCHEMA.getUsedLines(batch) : [];
            const getCategoryLabel = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getCategoryLabel) ? EXPENSE_BATCH_SCHEMA.getCategoryLabel : (k) => k;
            usedLines.forEach(lineKey => {
                const line = batch.lines && batch.lines[lineKey];
                if (!line) return;
                const label = getCategoryLabel(lineKey);
                const normalizedCat = (label && label.split(' ')[0]) ? label.split(' ')[0] : 'Other';
                if (!expensesByCategory[normalizedCat]) expensesByCategory[normalizedCat] = [];
                expensesByCategory[normalizedCat].push({ amount: line.amount || 0 });
            });
            
            // Create table data
            const tableData = [];
            const headers = ['', '1', '2', '3', '4', 'TOTAL'];
            tableData.push(headers);
            
            categories.forEach(category => {
                const categoryExpenses = expensesByCategory[category] || [];
                const row = [category];
                
                for (let i = 0; i < 4; i++) {
                if (i < categoryExpenses.length) {
                row.push(`¬£${parseFloat(categoryExpenses[i].amount || 0).toFixed(2)}`);
                } else {
                row.push('');
                }
                }
                
                const categoryTotal = categoryExpenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
                row.push(categoryTotal > 0 ? `¬£${categoryTotal.toFixed(2)}` : '');
                tableData.push(row);
            });
            
            const totalRow = ['TOTAL', '', '', '', '', `¬£${batch.totalAmount?.toFixed(2) || '0.00'}`];
            tableData.push(totalRow);
            
            // Draw table
            doc.autoTable({
                startY: tableStartY,
                head: [tableData[0]],
                body: tableData.slice(1),
                headStyles: { 
                fillColor: [217, 217, 217],
                textColor: 0,
                fontStyle: 'bold',
                fontSize: 15
                },
                bodyStyles: {
                fontSize: 15,
                textColor: 0
                },
                alternateRowStyles: {
                fillColor: [245, 245, 245]
                },
                columnStyles: {
                0: { cellWidth: col0, fontStyle: 'bold' },
                1: { cellWidth: colRest, halign: 'left' },
                2: { cellWidth: colRest, halign: 'left' },
                3: { cellWidth: colRest, halign: 'left' },
                4: { cellWidth: colRest, halign: 'left' },
                5: { cellWidth: colRest, halign: 'left', fontStyle: 'bold' }
                },
                styles: {
                lineWidth: 1,
                lineColor: 0
                },
                margin: { left: infoStartX }
            });
            
            y = doc.lastAutoTable.finalY + 40;
            
            // Expense summary lines
            const primaryCategories = ['Fuel', 'Charge', 'Car Wash'];
            const secondaryCategories = ['Bus', 'Train', 'Taxi', 'Tolls', 'Other'];
            
            const primaryAmounts = [];
            primaryCategories.forEach(cat => {
                const exp = expensesByCategory[cat] || [];
                if (exp.length > 0) {
                const amounts = exp.map(e => `¬£${parseFloat(e.amount || 0).toFixed(2)}`).join(' + ');
                primaryAmounts.push(`${cat}:(${amounts})`);
                }
            });
            
            if (primaryAmounts.length > 0) {
                doc.setFontSize(13);
                doc.setFont(undefined, 'bold');
                doc.text(primaryAmounts.join('  '), infoStartX, y);
                y += 24 * ptToMm;
            }
            
            const secondaryAmounts = [];
            secondaryCategories.forEach(cat => {
                const exp = expensesByCategory[cat] || [];
                if (exp.length > 0) {
                const amounts = exp.map(e => `¬£${parseFloat(e.amount || 0).toFixed(2)}`).join(' + ');
                secondaryAmounts.push(`${cat}: (${amounts})`);
                }
            });
            
            if (secondaryAmounts.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'normal');
                doc.text(secondaryAmounts.join(' '), infoStartX, y);
                y += 24 * ptToMm;
            }
            
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            doc.text(`Total: ¬£${batch.totalAmount?.toFixed(2) || '0.00'}`, infoStartX, y);
            y += 32 * ptToMm;
            
            doc.setFontSize(13);
            doc.setFont(undefined, 'italic');
            doc.setTextColor(105, 105, 105);
            const footerText = 'This report is for client records. Please retain for your files.\n\nIf you have any questions, contact SOTO support.';
            doc.text(footerText, infoStartX, y, { maxWidth: 210 - (infoStartX * 2), align: 'left' });
            
            doc.setFontSize(12);
            doc.setTextColor(128, 128, 128);
            doc.text('Expense report generated by - SOTORoutes', 105, 280, { align: 'center' });
            
            return doc;
        }

        // View PDF in new window
        function viewPaidExpensePDF(batchId) {
            const batch = allBatches.find(b => b.id === batchId && b.status === 'paid');
            if (!batch) {
                notifyError('Batch not found.', 'Missing Batch');
                return;
            }

            try {
                const doc = generatePaidExpensePDF(batch);
                const pdfBlob = doc.output('blob');
                const url = URL.createObjectURL(pdfBlob);
                window.open(url, '_blank');
                setTimeout(() => URL.revokeObjectURL(url), 100);
            } catch (error) {
                console.error('Error generating PDF:', error);
                notifyError('Failed to generate PDF. Please try again.');
            }
        }

        // Download PDF and Photos as ZIP
        async function downloadPaidExpensePDF(batchId) {
            const batch = allBatches.find(b => b.id === batchId && b.status === 'paid');
            if (!batch) {
                notifyError('Batch not found.', 'Missing Batch');
                return;
            }

            try {
                const zip = new JSZip();
                
                // Get current date for folder structure
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                const dateFolderName = `${day}_${month}_${year}`;
                
                // Clean registration
                const cleanedReg = batch.registration.replace(/[\/\\:]/g, '-').replace(/\s+/g, '_');
                
                // Folder path: dateFolderName/cleanedReg/
                const folderPath = `${dateFolderName}/${cleanedReg}/`;
                
                // Generate and add PDF
                const doc = generatePaidExpensePDF(batch);
                const pdfBlob = doc.output('blob');
                const driverNameForFile = (batch.driverName || 'Unknown_Driver').replace(/_/g, ' ');
                const pdfFileName = `${cleanedReg}_${driverNameForFile}.pdf`;
                zip.file(folderPath + pdfFileName, pdfBlob);
                
                // Download and add photos (valid URLs only) from batch.lines
                let photoIndex = 1;
                for (const line of Object.values(batch.lines || {})) {
                    if (!line || !Array.isArray(line.photos)) continue;
                    for (const photoURL of line.photos) {
                        if (typeof photoURL !== 'string' || !photoURL.startsWith('http')) continue;
                        try {
                            const response = await fetch(photoURL);
                            const photoBlob = await response.blob();
                            zip.file(folderPath + `photo_${photoIndex}.jpg`, photoBlob);
                            photoIndex++;
                        } catch (error) {
                            console.error('Error downloading photo:', photoURL, error);
                        }
                    }
                }
                
                // Generate and download ZIP
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${cleanedReg}_${dateFolderName}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                notifySuccess('Successfully downloaded PDF and photos as ZIP file!', 'Download Complete');
            } catch (error) {
                console.error('Error downloading PDF and photos:', error);
                notifyError('Failed to download files. Please try again.');
            }
        }

        // View all photos for a paid expense batch
        function viewPaidExpensePhotos(batchId) {
            const batch = allBatches.find(b => b.id === batchId && b.status === 'paid');
            if (!batch || !batch.lines) {
                notifyError('Batch not found.', 'Missing Batch');
                return;
            }

            const allPhotos = [];
            for (const line of Object.values(batch.lines)) {
                if (!line || !Array.isArray(line.photos)) continue;
                line.photos.filter(p => typeof p === 'string' && p.startsWith('http')).forEach(photoURL => allPhotos.push(photoURL));
            }

            if (allPhotos.length === 0) {
                notifyInfo('No photos available for this expense batch.', 'No Photos');
                return;
            }

            const grid = document.getElementById('photoViewerGrid');
            grid.innerHTML = allPhotos.map((url, index) => `
                <div class="w-full max-w-4xl mx-auto mb-6">
                    <div class="bg-[#1a1f24] rounded-xl p-4 shadow-2xl border border-[#283039]">
                        <img 
                            src="${url}" 
                            alt="Expense photo ${index + 1}" 
                            class="w-full h-auto rounded-lg shadow-lg object-contain max-h-[70vh] mx-auto"
                            loading="lazy"
                            style="display: block;"
                        >
                        <div class="text-center mt-3 text-sm text-gray-400">
                            Photo ${index + 1} of ${allPhotos.length}
                        </div>
                    </div>
                </div>
            `).join('');

            document.getElementById('photoViewerModal').classList.remove('hidden');
        }
    </script>
</body>
</html>