<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expenses - SOTO Routes</title>
    <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
    <link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/logos/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/logos/favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="/assets/logos/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/assets/logos/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/logos/apple-touch-icon.png">
    <link rel="stylesheet" href="/assets/css/responsive-nav.css">
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/mobile-nav.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="/js/settings.js"></script>
    <!-- PDF Generation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <!-- ZIP Creation Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="/js/expense-batch-schema.js"></script>
    <script src="../js/ui-dialogs.js"></script>
    <script>
        // CACHE BUSTER - Force fresh load
        console.log('ðŸ”´ EXPENSES PAGE LOADING - CACHE BUSTER v2 - ' + new Date().getTime());
        
        tailwind.config = {
            plugins: {
                forms: {},
                containerQueries: {}
            }
        }
    </script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, orderBy, limit, where, updateDoc, doc, deleteDoc, getDoc, getDocFromServer, setDoc, serverTimestamp, arrayUnion } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        import { getStorage, ref, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        const storage = getStorage(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.db = db;
        window.storage = storage;
        window.ref = ref;
        window.getDownloadURL = getDownloadURL;
        window.auth = auth;
        window.functions = functions;
        window.firebase = {
            functions,
            httpsCallable
        };
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseDoc = doc;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseGetDoc = getDoc;
        window.firebaseSetDoc = setDoc;
        window.serverTimestamp = serverTimestamp;
        window.arrayUnion = arrayUnion;
        
        // Make individual functions globally accessible
        window.query = query;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.updateDoc = updateDoc;
        window.where = where;
        window.orderBy = orderBy;
        window.doc = doc;
        window.getDoc = getDoc;
        window.getDocFromServer = getDocFromServer;
        window.setDoc = setDoc;
        window.signOut = signOut;
        
        // Make auth object globally accessible
        window.auth = auth;
        
        console.log('Firebase initialized successfully!');
        
        // Wait for DOM to be ready before initializing
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                console.log('ðŸ”´ DOM loaded, initializing expenses app...');
                initializeExpensesApp();
            });
        } else {
            // DOM is already loaded
            console.log('ðŸ”´ DOM already loaded, initializing expenses app...');
            initializeExpensesApp();
        }
    </script>
    <style>
        .tab-active {
            border-bottom: 3px solid #3b82f6;
            color: #3b82f6;
        }
        
        .license-plate {
            background: #FFD500;
            color: #000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 2px;
            padding: 6px 12px;
            border-radius: 4px;
            border: 2px solid #000;
            display: inline-block;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 20, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        /* Loading spinner */
        .spinner-wrapper {
            width: 32px;
            height: 32px;
            position: relative;
        }
        .spinner {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 26px;
            height: 26px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
        
        @keyframes flash {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        .flash-red {
            animation: flash 1s infinite;
        }
    </style>
</head>
<body class="bg-[#111418] text-white" style='font-family: Inter, "Noto Sans", sans-serif;'>
<div class="relative flex h-auto min-h-screen w-full flex-col dark group/design-root overflow-x-hidden">
<div class="flex h-full grow flex-col">

<header class="relative flex items-center justify-between whitespace-nowrap border-b border-solid border-b-[#283039] px-6 py-3" data-soto-nav>
<div class="flex items-center gap-4">
<div class="size-8 text-[var(--primary-color)]">
<svg fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
<path d="M13.8261 17.4264C16.7203 18.1174 20.2244 18.5217 24 18.5217C27.7756 18.5217 31.2797 18.1174 34.1739 17.4264C36.9144 16.7722 39.9967 15.2331 41.3563 14.1648L24.8486 40.6391C24.4571 41.267 23.5429 41.267 23.1514 40.6391L6.64374 14.1648C8.00331 15.2331 11.0856 16.7722 13.8261 17.4264Z" fill="currentColor"></path>
<path clip-rule="evenodd" d="M39.998 12.236C39.9944 12.2537 39.9875 12.2845 39.9748 12.3294C39.9436 12.4399 39.8949 12.5741 39.8346 12.7175C39.8168 12.7597 39.7989 12.8007 39.7813 12.8398C38.5103 13.7113 35.9788 14.9393 33.7095 15.4811C30.9875 16.131 27.6413 16.5217 24 16.5217C20.3587 16.5217 17.0125 16.131 14.2905 15.4811C12.0012 14.9346 9.44505 13.6897 8.18538 12.8168C8.17384 12.7925 8.16216 12.767 8.15052 12.7408C8.09919 12.6249 8.05721 12.5114 8.02977 12.411C8.00356 12.3152 8.00039 12.2667 8.00004 12.2612C8.00004 12.261 8 12.2607 8.00004 12.2612C8.00004 12.2359 8.0104 11.9233 8.68485 11.3686C9.34546 10.8254 10.4222 10.2469 11.9291 9.72276C14.9242 8.68098 19.1919 8 24 8C28.8081 8 33.0758 8.68098 36.0709 9.72276C37.5778 10.2469 38.6545 10.8254 39.3151 11.3686C39.9006 11.8501 39.9857 12.1489 39.998 12.236ZM4.95178 15.2312L21.4543 41.6973C22.6288 43.5809 25.3712 43.5809 26.5457 41.6973L43.0534 15.223C43.0709 15.1948 43.0878 15.1662 43.104 15.1371L41.3563 14.1648C43.104 15.1371 43.1038 15.1374 43.104 15.1371L43.1051 15.135L43.1065 15.1325L43.1101 15.1261L43.1199 15.1082C43.1276 15.094 43.1377 15.0754 43.1497 15.0527C43.1738 15.0075 43.2062 14.9455 43.244 14.8701C43.319 14.7208 43.4196 14.511 43.5217 14.2683C43.6901 13.8679 44 13.0689 44 12.2609C44 10.5573 43.003 9.22254 41.8558 8.2791C40.6947 7.32427 39.1354 6.55361 37.385 5.94477C33.8654 4.72057 29.133 4 24 4C18.867 4 14.1346 4.72057 10.615 5.94478C8.86463 6.55361 7.30529 7.32428 6.14419 8.27911C4.99695 9.22255 3.99999 10.5573 3.99999 12.2609C3.99999 13.1275 4.29264 13.9078 4.49321 14.3607C4.60375 14.6102 4.71348 14.8196 4.79687 14.9689C4.83898 15.0444 4.87547 15.1065 4.9035 15.1529C4.91754 15.1762 4.92954 15.1957 4.93916 15.2111L4.94662 15.223L4.95178 15.2312ZM35.9868 18.996L24 38.22L12.0131 18.996C12.4661 19.1391 12.9179 19.2658 13.3617 19.3718C16.4281 20.1039 20.0901 20.5217 24 20.5217C27.9099 20.5217 31.5719 20.1039 34.6383 19.3718C35.082 19.2658 35.5339 19.1391 35.9868 18.996Z" fill="currentColor" fill-rule="evenodd"></path>
</svg>
</div>
<h2 class="text-xl font-bold">SOTO Routes</h2>
</div>
<nav class="flex flex-1 justify-center gap-2" data-soto-nav-links>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/dashboard.html">Dashboard</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/optimisation.html">Optimisation</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/drivers.html">Drivers</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/availability.html">Availability</a>
<a class="bg-[#283039] text-white text-xs font-medium rounded-md px-3 py-2" href="/pages/expenses.html">Expenses</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/wait-times.html">Wait Times</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/messages.html">Messages</a>
<a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="#">Authorization</a>
</nav>
<div class="flex items-center gap-4">
<button type="button" class="mobile-nav-toggle" data-soto-nav-toggle aria-label="Toggle navigation" aria-expanded="false">
    <span class="material-symbols-outlined text-xl">menu</span>
</button>
<div class="relative">
    <button class="flex items-center justify-center rounded-full h-10 w-10 bg-[#283039] hover:bg-[#3a444e] transition-colors relative" onclick="showNotifications()">
        <span class="material-symbols-outlined text-xl">notifications</span>
        <!-- Notification Badge -->
        <span class="notification-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center font-bold hidden">0</span>
    </button>
    <!-- Notifications Dropdown -->
    <div id="notificationDropdown" class="hidden absolute right-0 mt-2 w-80 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto">
        <div class="px-4 py-3 border-b border-[#283039]">
            <h3 class="text-white font-semibold text-sm">Notifications</h3>
        </div>
        <div id="notificationsList" class="max-h-64 overflow-y-auto">
            <!-- Notifications will be loaded here -->
        </div>
    </div>
</div>
<div class="relative">
    <button onclick="toggleProfileDropdown()" class="flex items-center justify-center rounded-full size-10 bg-black overflow-hidden hover:ring-2 hover:ring-blue-500 transition-all cursor-pointer">
        <img id="officeLogoImg" src="/assets/logos/favicon.svg" alt="Office Logo" class="w-full h-full object-cover" onerror="this.src='/assets/logos/favicon.svg'">
    </button>
    <!-- Profile Dropdown -->
    <div id="profileDropdown" class="hidden absolute right-0 mt-2 w-48 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50 py-2 flex flex-col gap-2">
        <button onclick="showSettings()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors rounded-t-lg">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">settings</span>
            Settings
        </button>
        <button onclick="showChangePassword()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">lock</span>
            Change Password
        </button>
        <button onclick="viewUsage()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">calendar_month</span>
            View Usage
        </button>
        <button onclick="logout()" class="block w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-[#283039] transition-colors rounded-b-lg">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">logout</span>
            Logout
        </button>
    </div>
</div>
</div>
</header>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="flex items-center gap-4">
            <div class="spinner-wrapper">
                <div class="spinner"></div>
                <div class="spinner1"></div>
            </div>
            <span class="text-gray-400">Loading...</span>
        </div>
    </div>


    <!-- Main Content -->
    <div class="max-w-7xl mx-auto px-4 py-6">
        
        <!-- Page Header -->
        <div class="mb-6 text-center">
            <h1 class="text-3xl font-bold mb-2">Expense Management</h1>
            <p class="text-gray-400 mb-4">Review and manage driver expense submissions</p>
            
            <!-- Search Bar -->
            <div class="flex justify-center mb-6">
                <div class="relative w-96">
                    <input type="text" id="expenseSearch" placeholder="Search expenses..." 
                        class="w-full bg-[#1a1f24] border border-gray-800 rounded-lg px-4 py-2 pl-10 text-white placeholder-gray-500 focus:outline-none focus:border-blue-500 transition-colors">
                    <span class="material-symbols-outlined absolute left-3 top-2.5 text-gray-500">search</span>
                    <!-- Search Results Dropdown -->
                    <div id="searchResults" class="hidden absolute top-full left-0 right-0 mt-2 bg-[#1a1f24] border border-gray-800 rounded-lg shadow-lg max-h-96 overflow-y-auto z-50">
                        <!-- Results will be populated here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="border-b border-gray-800 mb-6">
            <div class="flex gap-8 justify-center">
                <button onclick="switchTab('pending')" id="tab-pending" class="tab-active py-3 px-1 font-semibold transition-colors">
                    Pending <span id="pending-count" class="ml-2 px-2 py-0.5 bg-orange-500 text-white text-xs rounded-full">0</span>
                </button>
                <button onclick="switchTab('validated')" id="tab-validated" class="py-3 px-1 text-gray-400 hover:text-white font-semibold transition-colors">
                    Validated <span id="validated-count" class="ml-2 px-2 py-0.5 bg-blue-500 text-white text-xs rounded-full">0</span>
                </button>
                <button onclick="switchTab('paid')" id="tab-paid" class="py-3 px-1 text-gray-400 hover:text-white font-semibold transition-colors">
                    Paid <span id="paid-count" class="ml-2 px-2 py-0.5 bg-green-500 text-white text-xs rounded-full">0</span>
                </button>
                <button onclick="switchTab('returned')" id="tab-returned" class="py-3 px-1 text-gray-400 hover:text-white font-semibold transition-colors">
                    Returned <span id="returned-count" class="ml-2 px-2 py-0.5 bg-red-500 text-white text-xs rounded-full">0</span>
                </button>
            </div>
        </div>

        <!-- Tab Content -->
        <div id="content-pending" class="tab-content">
            <!-- Group by Driver Toggle -->
            <div id="pending-header" class="mb-4 flex items-center justify-between">
                <button id="groupByDriverPendingBtn" onclick="toggleGroupByDriverPending()" 
                    class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors flex items-center gap-2">
                    <span class="material-symbols-outlined text-lg">group</span>
                    <span id="groupByDriverPendingText">Group by Driver</span>
                </button>
            </div>
            <div id="pending-list" class="space-y-3"></div>
            <div id="pending-empty" class="hidden text-center py-16 text-gray-500">
                <span class="material-symbols-outlined text-6xl mb-4">check_circle</span>
                <p class="text-xl">No pending expenses</p>
            </div>
        </div>

        <div id="content-validated" class="tab-content hidden">
            <!-- Group by Driver Toggle -->
            <div id="validated-header" class="mb-4 flex items-center justify-between">
                <button id="groupByDriverBtn" onclick="toggleGroupByDriver()" 
                    class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors flex items-center gap-2">
                    <span class="material-symbols-outlined text-lg">group</span>
                    <span id="groupByDriverText">Group by Driver</span>
                </button>
            </div>
            <div id="validated-list" class="space-y-3"></div>
            <div id="validated-empty" class="hidden text-center py-16 text-gray-500">
                <span class="material-symbols-outlined text-6xl mb-4">task_alt</span>
                <p class="text-xl">No validated expenses</p>
            </div>
        </div>

        <div id="content-paid" class="tab-content hidden">
            <!-- Generate PDFs Button (only shown if there are paid expenses) -->
            <div id="paid-header" class="hidden mb-4">
                <button id="generatePDFsBtn" onclick="generateAllPDFs()" 
                    class="w-full px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-semibold rounded-lg transition-colors flex items-center justify-center gap-2">
                    <span class="material-symbols-outlined">description</span>
                    Generate PDF's
                </button>
            </div>
            <div id="paid-list" class="space-y-3"></div>
            <div id="paid-empty" class="hidden text-center py-16 text-gray-500">
                <span class="material-symbols-outlined text-6xl mb-4">payments</span>
                <p class="text-xl">No paid expenses</p>
            </div>
        </div>

        <div id="content-returned" class="tab-content hidden">
            <div id="returned-list" class="space-y-3"></div>
            <div id="returned-empty" class="hidden text-center py-16 text-gray-500">
                <span class="material-symbols-outlined text-6xl mb-4">undo</span>
                <p class="text-xl">No returned expenses</p>
            </div>
        </div>

    </div>

    <!-- Batch Detail Modal -->
    <div id="batchModal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50 overflow-y-auto">
        <div class="min-h-screen px-4 py-8 flex items-center justify-center">
            <div class="bg-[#1a1f24] rounded-lg w-full max-w-4xl">
                
                <!-- Modal Header -->
                <div class="border-b border-gray-800 px-6 py-4">
                    <div class="flex items-center justify-between">
                        <h2 class="text-xl font-semibold">Expense Batch Details</h2>
                        <button onclick="closeModal()" class="text-gray-400 hover:text-white transition-colors">
                            <span class="material-symbols-outlined">close</span>
                        </button>
                    </div>
                </div>

                <!-- Modal Content -->
                <div class="p-6">
                    
                    <!-- Batch Info -->
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                        <div class="bg-[#283039] rounded-lg p-4">
                            <label class="text-sm text-gray-400 block mb-1">Driver</label>
                            <p id="modal-driver" class="text-lg font-semibold"></p>
                        </div>
                        <div class="bg-[#283039] rounded-lg p-4">
                            <label class="text-sm text-gray-400 block mb-1">Registration</label>
                            <div id="modal-reg" class="license-plate text-lg"></div>
                        </div>
                        <div class="bg-[#283039] rounded-lg p-4">
                            <label class="text-sm text-gray-400 block mb-1">Total Amount</label>
                            <p id="modal-total" class="text-lg font-semibold text-green-500"></p>
                        </div>
                        <div class="bg-[#283039] rounded-lg p-4">
                            <label class="text-sm text-gray-400 block mb-1">Submitted</label>
                            <p id="modal-date" class="text-lg"></p>
                        </div>
                    </div>

                    <!-- Communications (driver notes, return reasons, appeal messages) -->
                    <div id="modal-communications" class="hidden mb-6">
                        <label class="text-sm text-gray-400 block mb-2">Communications</label>
                        <div id="modal-communications-list" class="space-y-3 rounded-lg border border-gray-700 p-4 bg-[#1a1f24]"></div>
                    </div>

                    <!-- Expenses List -->
                    <div class="mb-6">
                        <h3 class="text-lg font-semibold mb-3">Expenses</h3>
                        <div id="modal-expenses" class="space-y-2"></div>
                    </div>

                    <!-- Actions -->
                    <div id="modal-actions" class="flex gap-3">
                        <!-- Actions will be added based on status -->
                    </div>

                </div>
            </div>
        </div>
    </div>

    <!-- Return Modal -->
    <div id="returnModal" class="hidden fixed inset-0 bg-black bg-opacity-75 z-50">
        <div class="min-h-screen px-4 py-8 flex items-center justify-center">
            <div class="bg-[#1a1f24] rounded-lg w-full max-w-lg">
                <div class="border-b border-gray-800 px-6 py-4">
                    <h2 class="text-xl font-semibold">Return Expense Batch</h2>
                </div>
                <div class="p-6">
                    <label class="text-sm text-gray-400 block mb-2">Reason for Return</label>
                    <textarea 
                        id="returnReason" 
                        rows="4" 
                        class="w-full bg-[#283039] text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-red-500 focus:outline-none"
                        placeholder="Explain why this batch is being returned..."
                    ></textarea>
                    <div class="flex gap-3 mt-4">
                        <button onclick="closeReturnModal()" class="flex-1 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button onclick="confirmReturn()" class="flex-1 py-2 bg-red-600 hover:bg-red-700 rounded-lg transition-colors">
                            Return Batch
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Photo Viewer Modal -->
    <div id="photoViewer" class="hidden fixed inset-0 bg-black bg-opacity-90 z-50">
        <div class="w-full h-full flex flex-col max-w-7xl mx-auto">
            <!-- Header -->
            <div class="flex items-center justify-between px-6 py-4 bg-[#1a1f24] border-b border-[#283039]">
                <button onclick="closePhotoViewer()" class="text-white hover:text-gray-300 transition-colors p-2 hover:bg-[#283039] rounded-lg">
                    <span class="material-symbols-outlined text-2xl">close</span>
                </button>
                <h3 class="text-white font-semibold text-lg">View Photos</h3>
                <div class="flex items-center gap-2">
                    <button onclick="resetPhotoZoom()" class="text-white hover:text-gray-300 transition-colors p-2 hover:bg-[#283039] rounded-lg" title="Reset Zoom">
                        <span class="material-symbols-outlined text-xl">fit_screen</span>
                    </button>
                    <button onclick="zoomPhotoOut()" class="text-white hover:text-gray-300 transition-colors p-2 hover:bg-[#283039] rounded-lg" title="Zoom Out">
                        <span class="material-symbols-outlined text-xl">zoom_out</span>
                    </button>
                    <button onclick="zoomPhotoIn()" class="text-white hover:text-gray-300 transition-colors p-2 hover:bg-[#283039] rounded-lg" title="Zoom In">
                        <span class="material-symbols-outlined text-xl">zoom_in</span>
                    </button>
                </div>
            </div>
            <!-- Photo container -->
            <div class="flex-1 bg-black flex items-center justify-center overflow-hidden" id="photoViewerContent">
                <!-- Photos will be injected here -->
            </div>
        </div>
    </div>

    <script>
        let currentSession = null;
        let currentUser = null;

        /** Only count/display real image URLs (avoids placeholders or broken entries showing as "X photos" or black images). */
        function isValidPhotoURL(url) {
            return typeof url === 'string' && url.trim().length > 0 && (url.startsWith('http://') || url.startsWith('https://'));
        }
        let allBatches = [];
        function getBatchItemCount(batch) {
            return (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getUsedLineCount) ? EXPENSE_BATCH_SCHEMA.getUsedLineCount(batch) : 0;
        }
        function escapeHtml(s) {
            if (s == null) return '';
            return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }
        let currentBatch = null;
        let activeTab = 'pending';
        let groupByDriver = false; // Toggle for grouping validated expenses by driver
        let groupByDriverPending = false; // Toggle for grouping pending expenses by driver
        const BATCH_PAGE_SIZE = 10;
        const displayedBatchCount = { pending: BATCH_PAGE_SIZE, validated: BATCH_PAGE_SIZE, paid: BATCH_PAGE_SIZE, returned: BATCH_PAGE_SIZE };
        const notifyError = (message, title = 'Error') => uiDialogs.showAlert({ title, message, tone: 'danger' });
        const notifyWarning = (message, title = 'Heads Up') => uiDialogs.showAlert({ title, message, tone: 'warning' });
        const notifySuccess = (message, title = 'Success') => uiDialogs.showAlert({ title, message, tone: 'success' });
        const notifyInfo = (message, title = 'Notice') => uiDialogs.showAlert({ title, message, tone: 'info' });
        const getCurrentOfficeId = () => currentUser?.officeId || currentSession?.officeId || null;

        // Initialize function
        async function initializeExpensesApp() {
            console.log('=== EXPENSES INITIALIZATION START ===');
            console.log('Current URL:', window.location.href);
            
            try {
                const session = await window.sotoSession.bootstrap(['office', 'admin']);
                if (!session) {
                    console.warn('Session bootstrap failed; redirecting to login.');
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                currentSession = session;
                currentUser = { uid: session.uid, ...session };

                try {
                    const userDoc = await window.getDoc(window.doc(window.db, 'users', session.uid));
                    if (userDoc.exists()) {
                        currentUser = { ...currentUser, ...userDoc.data() };
                    }
                } catch (profileError) {
                    console.warn('Unable to load user profile document:', profileError);
                }

                if (!currentUser || (currentUser.role !== 'office' && currentUser.role !== 'admin')) {
                    notifyWarning('This page is for office staff only.', 'Access Denied');
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                if (!getCurrentOfficeId()) {
                    notifyWarning('No office assigned to your account.', 'Access Denied');
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                await loadOfficeLogo(getCurrentOfficeId());
                await initializeNotifications();
                initializeSearch();
                
                console.log('Loading expense batches...');
                await loadAllBatches();
                document.getElementById('loadingOverlay').style.display = 'none';
                // Open to tab from URL if present (e.g. from overdue notification click)
                const urlParams = new URLSearchParams(window.location.search);
                const tabParam = urlParams.get('tab');
                if (tabParam === 'pending' || tabParam === 'validated') {
                    switchTab(tabParam);
                    if (window.history && window.history.replaceState) {
                        const u = new URL(window.location.href);
                        u.searchParams.delete('tab');
                        window.history.replaceState({}, '', u.pathname + u.search);
                    }
                }
                console.log('Loading complete!');
            } catch (error) {
                console.error('Initialization error:', error);
                notifyError('Error initializing app: ' + error.message);
                window.location.href = '/pages/soto-routes-login.html';
            }
        }

        // Load office logo from Firebase
        async function loadOfficeLogo(officeId) {
            if (!officeId) return;
            
            try {
                const officeDoc = await window.getDoc(window.doc(window.db, 'offices', officeId));
                if (officeDoc.exists()) {
                    const officeData = officeDoc.data();
                    const logoImg = document.getElementById('officeLogoImg');
                    if (logoImg && officeData.logoUrl) {
                        logoImg.src = officeData.logoUrl;
                        console.log('Office logo loaded:', officeData.logoUrl);
                    }
                }
            } catch (error) {
                console.error('Error loading office logo:', error);
                // Fallback to default logo (already set in HTML)
            }
        }

        // Load all expense batches
        async function loadAllBatches() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('Unable to load batches without office context.');
                    allBatches = [];
                    updateCounts();
                    displayBatches();
                    return;
                }

                console.log('Loading expense batches for officeId:', officeId);
                
                // Load batches and expenses in parallel (fixes N+1 query problem)
                const batchesCollection = window.collection(window.db, 'expenseBatches');
                const expensesCollection = window.collection(window.db, 'expenses');

                const [batchesSnapshot, expensesSnapshot, legacyBatchesSnapshot, legacyExpensesSnapshot] = await Promise.all([
                    window.getDocs(window.query(
                        batchesCollection,
                        window.where('officeId', '==', officeId)
                    )),
                    window.getDocs(window.query(
                        expensesCollection,
                        window.where('officeId', '==', officeId)
                    )),
                    (async () => {
                        try {
                            return await window.getDocs(window.query(
                                batchesCollection,
                                window.where('officeId', '==', null)
                            ));
                        } catch (legacyError) {
                            console.warn('Legacy expense batches query failed:', legacyError);
                            return { docs: [] };
                        }
                    })(),
                    (async () => {
                        try {
                            return await window.getDocs(window.query(
                                expensesCollection,
                                window.where('officeId', '==', null)
                            ));
                        } catch (legacyError) {
                            console.warn('Legacy expenses query failed:', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);
                
                console.log('Found batches:', batchesSnapshot.docs.length);
                console.log('Found expenses:', expensesSnapshot.docs.length);
                
                allBatches = [];

                // Group expenses by batchId for efficient lookup
                const expensesByBatch = {};
                const expenseDocs = [...expensesSnapshot.docs, ...(legacyExpensesSnapshot?.docs || [])];

                for (const expDoc of expenseDocs) {
                    const expData = { id: expDoc.id, ...expDoc.data() };
                    const batchId = expData.batchId;

                    if (expData.officeId && expData.officeId !== officeId) {
                        continue;
                    }

                    if (!expData.officeId) {
                        try {
                            await window.updateDoc(expDoc.ref, { officeId });
                            expData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for expense ${expDoc.id}:`, error);
                            continue;
                        }
                    }

                    if (batchId) {
                        if (!expensesByBatch[batchId]) {
                            expensesByBatch[batchId] = [];
                        }
                        expensesByBatch[batchId].push(expData);
                    }
                }

                // Process batches and attach their expenses
                const batchDocs = [...batchesSnapshot.docs, ...(legacyBatchesSnapshot?.docs || [])];

                for (const doc of batchDocs) {
                    const rawData = doc.data();

                    if (rawData.officeId && rawData.officeId !== officeId) {
                        continue;
                    }

                    const batchData = { id: doc.id, ...rawData };

                    if (!batchData.officeId) {
                        try {
                            await window.updateDoc(doc.ref, { officeId });
                            batchData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for batch ${doc.id}:`, error);
                            continue;
                        }
                    }

                    // Filter out expenses with incomplete photos (photosUploading flag)
                    const allExpenses = expensesByBatch[doc.id] || [];
                    batchData.expenses = allExpenses.filter(exp => {
                        // Only show expenses where photosUploading is false or undefined (not actively uploading)
                        return exp.photosUploading !== true;
                    });
                    allBatches.push(batchData);
                }

                // Sort by updatedAt descending (client-side)
                allBatches.sort((a, b) => {
                    const aTime = a.updatedAt?.toDate ? a.updatedAt.toDate().getTime() : 0;
                    const bTime = b.updatedAt?.toDate ? b.updatedAt.toDate().getTime() : 0;
                    return bTime - aTime; // Descending order
                });

                console.log('Total batches loaded:', allBatches.length);
                updateCounts();
                displayBatches();
            } catch (error) {
                console.error('Error loading batches:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
                notifyError('Error loading expense batches: ' + error.message);
            }
        }

        // Update counts
        function updateCounts() {
            const pending = allBatches.filter(b => b.status === 'pending').length;
            const validated = allBatches.filter(b => b.status === 'validated').length;
            const paid = allBatches.filter(b => b.status === 'paid').length;
            const returned = allBatches.filter(b => b.status === 'returned').length;

            document.getElementById('pending-count').textContent = pending;
            document.getElementById('validated-count').textContent = validated;
            document.getElementById('paid-count').textContent = paid;
            document.getElementById('returned-count').textContent = returned;
        }

        // Switch tab
        function switchTab(tab) {
            activeTab = tab;
            
            // Update tab styles
            document.querySelectorAll('[id^="tab-"]').forEach(btn => {
                btn.classList.remove('tab-active', 'text-blue-500');
                btn.classList.add('text-gray-400');
            });
            document.getElementById(`tab-${tab}`).classList.add('tab-active', 'text-blue-500');
            document.getElementById(`tab-${tab}`).classList.remove('text-gray-400');

            // Show/hide content
            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
            document.getElementById(`content-${tab}`).classList.remove('hidden');

            displayBatches();
        }

        // Calculate working hours between two dates (8am-5pm Mon-Fri only)
        function calculateWorkingHours(startDate, endDate) {
            let currentDate = new Date(startDate);
            let workingHours = 0;
            
            while (currentDate < endDate) {
                const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, etc.
                const hour = currentDate.getHours();
                
                // Check if it's a weekday (Monday = 1 to Friday = 5)
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    // Check if it's within working hours (8am to 5pm)
                    if (hour >= 8 && hour < 17) {
                        workingHours += 1;
                    }
                }
                
                // Move to next hour
                currentDate.setHours(currentDate.getHours() + 1);
            }
            
            return workingHours;
        }
        
        // Get timer color based on working hours
        function getTimerColor(hours) {
            if (hours <= 6) return 'text-green-500';
            if (hours <= 18) return 'text-orange-500';
            return 'text-red-500';
        }
        
        // Get timer class based on working hours (for flashing)
        function getTimerClass(hours) {
            if (hours > 24) return 'text-red-500 flash-red';
            return '';
        }
        
        // Toggle group by driver for validated expenses
        function toggleGroupByDriver() {
            groupByDriver = !groupByDriver;
            const btn = document.getElementById('groupByDriverBtn');
            const text = document.getElementById('groupByDriverText');
            
            if (groupByDriver) {
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                btn.classList.remove('bg-[#283039]', 'hover:bg-[#3a444e]');
                text.textContent = 'Ungroup';
            } else {
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                btn.classList.add('bg-[#283039]', 'hover:bg-[#3a444e]');
                text.textContent = 'Group by Driver';
            }
            
            displayBatches();
        }

        // Toggle group by driver for pending expenses
        function toggleGroupByDriverPending() {
            groupByDriverPending = !groupByDriverPending;
            const btn = document.getElementById('groupByDriverPendingBtn');
            const text = document.getElementById('groupByDriverPendingText');
            
            if (groupByDriverPending) {
                btn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                btn.classList.remove('bg-[#283039]', 'hover:bg-[#3a444e]');
                text.textContent = 'Ungroup';
            } else {
                btn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                btn.classList.add('bg-[#283039]', 'hover:bg-[#3a444e]');
                text.textContent = 'Group by Driver';
            }
            
            displayBatches();
        }

        function loadMoreBatches() {
            displayedBatchCount[activeTab] += BATCH_PAGE_SIZE;
            displayBatches();
        }

        function sortByOldestFirst(batches, tab) {
            return batches.slice().sort((a, b) => {
                const aTime = (a.submittedAt?.toDate ? a.submittedAt.toDate() : (a.updatedAt?.toDate ? a.updatedAt.toDate() : new Date(a.submittedAt || a.updatedAt || 0))).getTime();
                const bTime = (b.submittedAt?.toDate ? b.submittedAt.toDate() : (b.updatedAt?.toDate ? b.updatedAt.toDate() : new Date(b.submittedAt || b.updatedAt || 0))).getTime();
                return aTime - bTime;
            });
        }

        // Display batches
        function displayBatches() {
            let filtered = allBatches.filter(b => b.status === activeTab);
            if (activeTab === 'paid') filtered = filtered.filter(b => b.status === 'paid');
            filtered = sortByOldestFirst(filtered, activeTab);
            const totalCount = filtered.length;
            const limit = displayedBatchCount[activeTab];
            const toDisplay = filtered.slice(0, limit);
            const hasMore = totalCount > limit;
            
            // Handle grouping by driver for validated expenses
            if (activeTab === 'validated' && groupByDriver) {
                // Group by driver (using paginated toDisplay)
                const driverGroups = {};
                toDisplay.forEach(batch => {
                    const driverId = batch.driverId || batch.driverEmail || 'unknown';
                    if (!driverGroups[driverId]) {
                        driverGroups[driverId] = {
                            driverId: driverId,
                            driverName: batch.driverName || 'Unknown Driver',
                            driverEmail: batch.driverEmail || '',
                            batches: [],
                            earliestDate: null
                        };
                    }
                    driverGroups[driverId].batches.push(batch);
                    
                    // Track earliest submission date
                    const batchDate = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                    if (!driverGroups[driverId].earliestDate || batchDate < driverGroups[driverId].earliestDate) {
                        driverGroups[driverId].earliestDate = batchDate;
                    }
                });
                
                // Sort drivers by earliest submission date (oldest first)
                const sortedDrivers = Object.values(driverGroups).sort((a, b) => {
                    return a.earliestDate - b.earliestDate;
                });
                
                // Render grouped
                const list = document.getElementById(`${activeTab}-list`);
                const empty = document.getElementById(`${activeTab}-empty`);
                
                if (sortedDrivers.length === 0) {
                    list.innerHTML = '';
                    empty.classList.remove('hidden');
                } else {
                    empty.classList.add('hidden');
                    
                    list.innerHTML = sortedDrivers.map(driverGroup => {
                        // Calculate total for this driver
                        const totalAmount = driverGroup.batches.reduce((sum, b) => sum + (b.totalAmount || 0), 0);
                        const totalExpenses = driverGroup.batches.reduce((sum, b) => sum + getBatchItemCount(b), 0);
                        
                        const batchesHTML = driverGroup.batches.map(batch => {
                            const date = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
                            const workingHours = calculateWorkingHours(date, new Date());
                            const color = getTimerColor(workingHours);
                            const flashClass = getTimerClass(workingHours);
                            
                            return `
                                <div onclick="openBatchDetail('${batch.id}')" class="bg-[#283039] border border-gray-700 hover:border-gray-600 rounded-lg p-3 cursor-pointer transition-colors ml-4">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1">
                                            <p class="text-sm text-gray-300 mb-1">${batch.registration || 'No Reg'}</p>
                                            <p class="text-xs text-gray-400">${date.toLocaleDateString()}</p>
                                            <div class="text-xs ${color} ${flashClass} font-semibold mt-1">${workingHours}h since submission</div>
                                        </div>
                                        <span class="text-green-400 font-semibold">Â£${batch.totalAmount?.toFixed(2) || '0.00'}</span>
                                    </div>
                                    <div class="text-xs text-gray-500 ml-4">${getBatchItemCount(batch)} item${getBatchItemCount(batch) !== 1 ? 's' : ''}</div>
                                </div>
                            `;
                        }).join('');
                        
                        return `
                            <div class="mb-6">
                                <div class="bg-[#1a1f24] border border-gray-800 rounded-lg p-4 mb-3">
                                    <div class="flex items-center justify-between mb-3">
                                        <div>
                                            <p class="font-semibold text-lg">${driverGroup.driverName}</p>
                                            <p class="text-sm text-gray-400">${driverGroup.driverEmail}</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="text-green-500 font-semibold text-xl">Â£${totalAmount.toFixed(2)}</p>
                                            <p class="text-xs text-gray-400">${totalExpenses} expense${totalExpenses !== 1 ? 's' : ''}</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="space-y-2">
                                    ${batchesHTML}
                                </div>
                            </div>
                        `;
                    }).join('');
                    if (hasMore) {
                        list.innerHTML += `<div class="flex justify-center mt-4">
                            <button onclick="loadMoreBatches()" class="flex items-center gap-2 px-4 py-2 bg-[#283039] hover:bg-[#3a4552] text-white rounded-lg border border-gray-700 transition-colors">
                                <span class="material-symbols-outlined">expand_more</span>
                                Load 10 more
                            </button>
                        </div>`;
                    }
                }
                return;
            }
            
            // Handle grouping by driver for pending expenses
            if (activeTab === 'pending' && groupByDriverPending) {
                // Group by driver (using paginated toDisplay)
                const driverGroups = {};
                toDisplay.forEach(batch => {
                    const driverId = batch.driverId || batch.driverEmail || 'unknown';
                    if (!driverGroups[driverId]) {
                        driverGroups[driverId] = {
                            driverId: driverId,
                            driverName: batch.driverName || 'Unknown Driver',
                            driverEmail: batch.driverEmail || '',
                            batches: [],
                            earliestDate: null
                        };
                    }
                    driverGroups[driverId].batches.push(batch);
                    
                    // Track earliest submission date
                    const batchDate = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                    if (!driverGroups[driverId].earliestDate || batchDate < driverGroups[driverId].earliestDate) {
                        driverGroups[driverId].earliestDate = batchDate;
                    }
                });
                
                // Sort drivers by earliest submission date (oldest first)
                const sortedDrivers = Object.values(driverGroups).sort((a, b) => {
                    return a.earliestDate - b.earliestDate;
                });
                
                // Render grouped
                const list = document.getElementById(`${activeTab}-list`);
                const empty = document.getElementById(`${activeTab}-empty`);
                
                if (sortedDrivers.length === 0) {
                    list.innerHTML = '';
                    empty.classList.remove('hidden');
                } else {
                    empty.classList.add('hidden');
                    
                    list.innerHTML = sortedDrivers.map(driverGroup => {
                        // Calculate total for this driver
                        const totalAmount = driverGroup.batches.reduce((sum, b) => sum + (b.totalAmount || 0), 0);
                        const totalExpenses = driverGroup.batches.reduce((sum, b) => sum + getBatchItemCount(b), 0);
                        
                        const batchesHTML = driverGroup.batches.map(batch => {
                            const date = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
                            const workingHours = calculateWorkingHours(date, new Date());
                            const color = getTimerColor(workingHours);
                            const flashClass = getTimerClass(workingHours);
                            
                            return `
                                <div onclick="openBatchDetail('${batch.id}')" class="bg-[#283039] border border-gray-700 hover:border-gray-600 rounded-lg p-3 cursor-pointer transition-colors ml-4">
                                    <div class="flex items-start justify-between mb-2">
                                        <div class="flex-1">
                                            <p class="text-sm text-gray-300 mb-1">${batch.registration || 'No Reg'}</p>
                                            <p class="text-xs text-gray-400">${date.toLocaleDateString()}</p>
                                            <div class="text-xs ${color} ${flashClass} font-semibold mt-1">${workingHours}h since submission</div>
                                        </div>
                                        <span class="text-green-400 font-semibold">Â£${batch.totalAmount?.toFixed(2) || '0.00'}</span>
                                    </div>
                                    <div class="text-xs text-gray-500 ml-4">${getBatchItemCount(batch)} item${getBatchItemCount(batch) !== 1 ? 's' : ''}</div>
                                </div>
                            `;
                        }).join('');
                        
                        return `
                            <div class="mb-6">
                                <div class="bg-[#1a1f24] border border-gray-800 rounded-lg p-4 mb-3">
                                    <div class="flex items-center justify-between mb-3">
                                        <div>
                                            <p class="font-semibold text-lg">${driverGroup.driverName}</p>
                                            <p class="text-sm text-gray-400">${driverGroup.driverEmail}</p>
                                        </div>
                                        <div class="text-right">
                                            <p class="text-green-500 font-semibold text-xl">Â£${totalAmount.toFixed(2)}</p>
                                            <p class="text-xs text-gray-400">${totalExpenses} expense${totalExpenses !== 1 ? 's' : ''}</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="space-y-2">
                                    ${batchesHTML}
                                </div>
                            </div>
                        `;
                    }).join('');
                    if (hasMore) {
                        list.innerHTML += `<div class="flex justify-center mt-4">
                            <button onclick="loadMoreBatches()" class="flex items-center gap-2 px-4 py-2 bg-[#283039] hover:bg-[#3a4552] text-white rounded-lg border border-gray-700 transition-colors">
                                <span class="material-symbols-outlined">expand_more</span>
                                Load 10 more
                            </button>
                        </div>`;
                    }
                }
                return;
            }
            
            // Regular display (not grouped)
            const list = document.getElementById(`${activeTab}-list`);
            const empty = document.getElementById(`${activeTab}-empty`);

            if (toDisplay.length === 0) {
                list.innerHTML = '';
                empty.classList.remove('hidden');
            } else {
                empty.classList.add('hidden');
                
                // Show/hide generate PDFs button for paid tab
                if (activeTab === 'paid') {
                    document.getElementById('paid-header').classList.remove('hidden');
                } else {
                    document.getElementById('paid-header').classList.add('hidden');
                }
            
            list.innerHTML = toDisplay.map(batch => {
                    const date = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
                    
                    // Calculate working hours for pending and validated expenses
                    let timerHTML = '';
                    if (activeTab === 'pending' || activeTab === 'validated') {
                        const workingHours = calculateWorkingHours(date, new Date());
                        const color = getTimerColor(workingHours);
                        const flashClass = getTimerClass(workingHours);
                        timerHTML = `<div class="text-xs ${color} ${flashClass} font-semibold mt-1">${workingHours}h since submission</div>`;
                    }
                    
                    return `
                        <div onclick="openBatchDetail('${batch.id}')" class="bg-[#1a1f24] border border-gray-800 hover:border-gray-700 rounded-lg p-4 cursor-pointer transition-colors">
                            <div class="flex items-start justify-between mb-3">
                                <div>
                                    <p class="font-semibold text-lg mb-1">${batch.driverName || 'Unknown Driver'}</p>
                                    <p class="text-sm text-gray-400">${batch.driverEmail || ''}</p>
                                    ${timerHTML}
                                </div>
                                <div class="license-plate">${batch.registration}</div>
                            </div>
                            <div class="flex items-center justify-between">
                                <span class="text-gray-400 text-sm">${getBatchItemCount(batch)} item${getBatchItemCount(batch) !== 1 ? 's' : ''} â€¢ ${date.toLocaleDateString()}</span>
                                <span class="text-green-500 font-semibold text-xl">Â£${batch.totalAmount?.toFixed(2) || '0.00'}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            if (hasMore) {
                list.innerHTML += `<div class="flex justify-center mt-4">
                    <button onclick="loadMoreBatches()" class="flex items-center gap-2 px-4 py-2 bg-[#283039] hover:bg-[#3a4552] text-white rounded-lg border border-gray-700 transition-colors">
                        <span class="material-symbols-outlined">expand_more</span>
                        Load 10 more
                    </button>
                </div>`;
            }
            }
        }

        function extractStoragePathFromURL(downloadURL) {
            try {
                var url = new URL(downloadURL);
                var pathMatch = url.pathname.match(/\/o\/(.+)/);
                if (pathMatch) return decodeURIComponent(pathMatch[1]);
                return null;
            } catch (e) { return null; }
        }
        var FIREBASE_STORAGE_URL_PREFIX_OFFICE = 'https://firebasestorage.googleapis.com/v0/b/soto-routes.firebasestorage.app/';
        async function refreshFirebasePhotoURLs(batch, onDone) {
            if (!batch || !batch.lines || !window.storage || typeof window.ref !== 'function' || typeof window.getDownloadURL !== 'function') { if (onDone) onDone(); return; }
            var updated = false;
            for (var lineKey in batch.lines) {
                var line = batch.lines[lineKey];
                if (!line || !Array.isArray(line.photos)) continue;
                for (var i = 0; i < line.photos.length; i++) {
                    var p = line.photos[i];
                    if (typeof p !== 'string' || p.indexOf(FIREBASE_STORAGE_URL_PREFIX_OFFICE) !== 0) continue;
                    var path = extractStoragePathFromURL(p);
                    if (!path) continue;
                    try {
                        var photoRef = window.ref(window.storage, path);
                        var freshURL = await window.getDownloadURL(photoRef);
                        if (freshURL && freshURL !== p) { line.photos[i] = freshURL; updated = true; }
                    } catch (err) { console.warn('[refreshFirebasePhotoURLs] Failed to refresh URL for', path, err); }
                }
            }
            if (onDone) onDone(updated);
        }
        function renderBatchDetailExpenses() {
            if (!currentBatch) return;
            var categoryEmojis = { 'Fuel': 'â›½', 'Charge': 'ðŸ”Œ', 'Train': 'ðŸš‚', 'Bus': 'ðŸšŒ', 'Taxi': 'ðŸš•', 'Car Wash': 'ðŸ§¼', 'Tolls': 'ðŸ›£ï¸', 'Other': 'ðŸ“', 'fuel': 'â›½', 'charge': 'ðŸ”Œ', 'train': 'ðŸš‚', 'bus': 'ðŸšŒ', 'taxi': 'ðŸš•', 'car wash': 'ðŸ§¼', 'tolls': 'ðŸ›£ï¸', 'other': 'ðŸ“' };
            var usedKeys = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines)) ? (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines).call(null, currentBatch) : [];
            var getCategoryLabel = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getCategoryLabel) ? EXPENSE_BATCH_SCHEMA.getCategoryLabel : (function(k) { return k; });
            var getCategoryGroup = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && EXPENSE_BATCH_SCHEMA.getCategoryGroup) ? EXPENSE_BATCH_SCHEMA.getCategoryGroup : (function(k) { return (k || '').replace(/\d+$/, ''); });
            var lineEmojis = { train: 'ðŸš‚', taxi: 'ðŸš•', fuel: 'â›½', charge: 'ðŸ”Œ', bus: 'ðŸšŒ', carWash: 'ðŸ§¼', toll: 'ðŸ›£ï¸', other: 'ðŸ“' };
            var el = document.getElementById('modal-expenses');
            if (!el) return;
            el.innerHTML = usedKeys.map(function(lineKey) {
                var line = (currentBatch.lines || {})[lineKey];
                if (!line) return '';
                var label = getCategoryLabel(lineKey);
                var prefix = getCategoryGroup(lineKey) || 'other';
                var emoji = lineEmojis[prefix] || 'ðŸ“';
                var validPhotos = Array.isArray(line.photos) ? line.photos.filter(isValidPhotoURL) : [];
                return '<div class="bg-[#283039] rounded-lg p-3 flex items-center justify-between">' +
                    '<div class="flex items-center gap-3">' +
                    '<span class="text-2xl">' + emoji + '</span>' +
                    '<div>' +
                    '<div class="font-medium capitalize">' + label + '</div>' +
                    (validPhotos.length > 0 ? '<button onclick="viewExpensePhotos(\'' + lineKey + '\')" class="w-8 h-8 rounded-lg border border-gray-600 flex items-center justify-center bg-[#1e252b] hover:bg-[#283039] focus:outline-none focus:ring-2 focus:ring-blue-400 relative flex-shrink-0" title="' + validPhotos.length + ' photo' + (validPhotos.length !== 1 ? 's' : '') + '">' +
                    '<span class="material-symbols-outlined text-gray-400 text-lg">photo_camera</span>' +
                    '<span class="absolute -top-0.5 -right-0.5 min-w-[14px] h-[14px] rounded-full bg-blue-500 text-white text-[10px] font-semibold flex items-center justify-center">' + Math.min(validPhotos.length, 4) + '</span></button>' : '') +
                    '</div></div>' +
                    '<span class="font-semibold text-green-500">Â£' + parseFloat(line.amount || 0).toFixed(2) + '</span>' +
                    '</div>';
            }).join('');
        }

        // Open batch detail â€” fetch from server so we always show latest (including all photo URLs). List data can be cached.
        async function openBatchDetail(batchId) {
            var batch = allBatches.find(b => b.id === batchId);
            if (!batch) return;
            try {
                var batchRef = window.doc(window.db, 'expenseBatches', batchId);
                if (typeof window.getDocFromServer === 'function') {
                    var snap = await window.getDocFromServer(batchRef);
                    if (snap.exists()) batch = { id: snap.id, ...snap.data() };
                } else {
                    var snap = await window.getDoc(batchRef);
                    if (snap.exists()) batch = { id: snap.id, ...snap.data() };
                }
                var idx = allBatches.findIndex(b => b.id === batchId);
                if (idx >= 0) allBatches[idx] = batch;
            } catch (e) {
                console.warn('Could not refetch batch, using list data:', e);
            }
            currentBatch = batch;

            const date = currentBatch.submittedAt?.toDate ? currentBatch.submittedAt.toDate() : new Date();
            document.getElementById('modal-driver').textContent = currentBatch.driverName || 'Unknown Driver';
            document.getElementById('modal-reg').textContent = currentBatch.registration;
            document.getElementById('modal-total').textContent = `Â£${currentBatch.totalAmount?.toFixed(2) || '0.00'}`;
            document.getElementById('modal-date').textContent = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

            // Communications: thread of driver notes, return messages, appeal messages
            const commsList = document.getElementById('modal-communications-list');
            const commsSection = document.getElementById('modal-communications');
            if (commsList && commsSection) {
                const entries = Array.isArray(currentBatch.communications) && currentBatch.communications.length > 0
                    ? currentBatch.communications.map(c => ({
                        from: c.from || 'driver',
                        authorName: c.authorName || (c.from === 'office' ? 'Office' : (currentBatch.driverName || 'Driver')),
                        message: c.message || '',
                        createdAt: c.createdAt
                    }))
                    : [];
                if (entries.length > 0) {
                    commsSection.classList.remove('hidden');
                    commsList.innerHTML = entries.map(e => {
                        const dateStr = e.createdAt && (e.createdAt.toDate ? e.createdAt.toDate() : e.createdAt) ? new Date(e.createdAt.toDate ? e.createdAt.toDate() : e.createdAt).toLocaleString() : '';
                        const namePart = `<strong>${escapeHtml(e.authorName)}</strong>`;
                        const label = dateStr ? namePart + ' Â· ' + escapeHtml(dateStr) : namePart;
                        return `<div class="border-l-2 pl-3 ${e.from === 'office' ? 'border-red-500' : 'border-blue-500'}"><p class="text-sm font-medium text-gray-300 mb-1">${label}</p><p class="text-white whitespace-pre-wrap text-sm">${escapeHtml(e.message)}</p></div>`;
                    }).join('');
                } else {
                    commsSection.classList.add('hidden');
                }
            }

            renderBatchDetailExpenses();

            // Show appropriate actions
            const actions = document.getElementById('modal-actions');
            if (currentBatch.status === 'pending') {
                actions.innerHTML = `
                    <button onclick="returnBatch()" class="flex-1 py-3 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-colors">
                        <span class="material-symbols-outlined text-sm">undo</span>
                        Return for Review
                    </button>
                    <button onclick="validateBatch()" class="flex-1 py-3 bg-green-600 hover:bg-green-700 rounded-lg font-semibold transition-colors">
                        <span class="material-symbols-outlined text-sm">check_circle</span>
                        Validate
                    </button>
                `;
            } else if (currentBatch.status === 'validated') {
                actions.innerHTML = `
                    <button onclick="markAsPaid()" class="flex-1 py-3 bg-blue-600 hover:bg-blue-700 rounded-lg font-semibold transition-colors">
                        <span class="material-symbols-outlined text-sm">payments</span>
                        Mark as Paid
                    </button>
                `;
            } else {
                actions.innerHTML = '';
            }

            document.getElementById('batchModal').classList.remove('hidden');
            // Fallback: refresh Firebase Storage URLs in background (e.g. revoked token). Root cause fix is in driver upload-complete (no cache read).
            if (typeof refreshFirebasePhotoURLs === 'function') refreshFirebasePhotoURLs(currentBatch, function(updated) {
                if (updated && typeof renderBatchDetailExpenses === 'function') renderBatchDetailExpenses();
            });
        }

        // Validate batch
        async function validateBatch() {
            const confirmed = await showConfirmation({
                title: 'Validate Expense Batch',
                message: 'Are you sure you want to validate this expense batch?',
                confirmText: 'Validate',
                cancelText: 'Cancel',
                confirmClass: 'bg-blue-600 hover:bg-blue-700 focus:ring-blue-500'
            });

            if (!confirmed) return;

            try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', currentBatch.id), {
                    status: 'validated',
                    validatedAt: window.serverTimestamp(),
                    validatedBy: currentUser.uid,
                    updatedAt: window.serverTimestamp()
                });

                closeModal();
                await loadAllBatches();
            } catch (error) {
                console.error('Error validating batch:', error);
                notifyError('Error validating batch. Please try again.');
            }
        }

        // Return batch
        function returnBatch() {
            document.getElementById('returnModal').classList.remove('hidden');
        }

        // Confirm return
        async function confirmReturn() {
            const reason = document.getElementById('returnReason').value.trim();
            if (!reason) {
                notifyWarning('Please provide a reason for returning this batch.', 'Action Required');
                return;
            }
            const officeName = (currentUser.name || [currentUser.firstName, currentUser.lastName].filter(Boolean).join(' ') || 'Office').trim() || 'Office';

            try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', currentBatch.id), {
                    status: 'returned',
                    returnedAt: window.serverTimestamp(),
                    returnedBy: currentUser.uid,
                    updatedAt: window.serverTimestamp(),
                    communications: window.arrayUnion({ from: 'office', authorName: officeName, message: reason, createdAt: Date.now() })
                });

            notifySuccess('Batch returned to the driver.');
                closeReturnModal();
                closeModal();
                await loadAllBatches();
            } catch (error) {
                console.error('Error returning batch:', error);
            notifyError('Error returning batch. Please try again.');
            }
        }

        // Mark as paid
        async function markAsPaid() {
            const confirmed = await showConfirmation({
                title: 'Mark Expense Batch as Paid',
                message: 'Confirm that this expense batch has been paid?',
                confirmText: 'Mark as Paid',
                cancelText: 'Cancel',
                confirmClass: 'bg-green-600 hover:bg-green-700 focus:ring-green-500'
            });

            if (!confirmed) return;

            try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', currentBatch.id), {
                    status: 'paid',
                    paidAt: window.serverTimestamp(),
                    paidBy: currentUser.uid,
                    updatedAt: window.serverTimestamp()
                });

                closeModal();
                await loadAllBatches();
            } catch (error) {
                console.error('Error updating batch:', error);
                notifyError('Error updating batch. Please try again.');
            }
        }

        // Photo zoom state - stored per photo
        const photoZoomStates = new Map();
        let currentActivePhoto = null;
        let isDraggingPhoto = false;
        let dragStartX = 0;
        let dragStartY = 0;
        
        // Prevent page zoom handler
        function preventPageZoom(e) {
            if ((e.ctrlKey || e.metaKey) && e.target.closest('#photoViewer')) {
                e.preventDefault();
                return false;
            }
        }

        // Get or create zoom state for a photo
        function getPhotoZoomState(photo) {
            if (!photoZoomStates.has(photo)) {
                photoZoomStates.set(photo, {
                    zoom: 1,
                    offsetX: 0,
                    offsetY: 0
                });
            }
            return photoZoomStates.get(photo);
        }

        // View photos for a batch line (lineKey e.g. 'train1')
        async function viewExpensePhotos(lineKey) {
            const line = currentBatch && currentBatch.lines && currentBatch.lines[lineKey];
            const validPhotos = (line && Array.isArray(line.photos)) ? line.photos.filter(isValidPhotoURL) : [];
            if (validPhotos.length === 0) {
                return;
            }

            const viewer = document.getElementById('photoViewer');
            const content = document.getElementById('photoViewerContent');
            if (!viewer || !content) {
                console.error('Photo viewer elements not found.');
                return;
            }
            
            // Clear previous zoom states
            photoZoomStates.clear();
            currentActivePhoto = null;
            
            // Photos are URLs (from Firebase Storage) - display only valid URLs to avoid black/broken images
            content.innerHTML = validPhotos.map((url, index) => {
                const state = { zoom: 1, offsetX: 0, offsetY: 0 };
                return `
                <div class="w-full max-w-4xl mx-auto photo-container" data-photo-index="${index}">
                    <div class="bg-[#1a1f24] rounded-xl p-4 shadow-2xl border border-[#283039]">
                        <div class="relative overflow-hidden rounded-lg photo-wrapper" style="min-height: 400px; display: flex; align-items: center; justify-content: center;">
                            <img 
                                src="${url}" 
                                alt="Expense photo ${index + 1}" 
                                class="zoomable-photo w-full h-auto rounded-lg shadow-lg object-contain max-h-[70vh] mx-auto select-none"
                                loading="lazy"
                                style="display: block; transform: scale(${state.zoom}) translate(${state.offsetX}px, ${state.offsetY}px); transform-origin: center center; transition: transform 0.1s ease-out; max-width: 100%;"
                                draggable="false"
                                data-photo-url="${url}"
                            >
                        </div>
                        <div class="text-center mt-3 text-sm text-gray-400 photo-zoom-indicator" data-base-text="Photo ${index + 1} of ${validPhotos.length}">
                            Photo ${index + 1} of ${validPhotos.length}
                        </div>
                    </div>
                </div>
            `;
            }).join('');

            // Set up zoom and pan for all photos
            const photos = content.querySelectorAll('.zoomable-photo');
            photos.forEach((photo, index) => {
                setupPhotoZoom(photo);
                // Store initial state
                photoZoomStates.set(photo, { zoom: 1, offsetX: 0, offsetY: 0 });
            });

            // Set current active photo to first one
            if (photos.length > 0) {
                currentActivePhoto = photos[0];
            }

            viewer.classList.remove('hidden');
            
            // Prevent page zoom when photo viewer is open and Ctrl+scroll is used
            document.addEventListener('wheel', preventPageZoom, { passive: false, capture: true });
        }

        // Setup zoom and pan for a photo
        function setupPhotoZoom(photo) {
            const container = photo.closest('.photo-container');
            const wrapper = photo.closest('.photo-wrapper');
            
            // Mouse wheel zoom (Ctrl + scroll) - only on this photo
            container.addEventListener('wheel', (e) => {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const state = getPhotoZoomState(photo);
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.5, Math.min(5, state.zoom * zoomFactor));
                    
                    if (Math.abs(newZoom - state.zoom) > 0.01) {
                        state.zoom = newZoom;
                        currentActivePhoto = photo;
                        updatePhotoTransform(photo);
                    }
                    return false;
                }
            }, { passive: false });

            // Mouse drag to pan when zoomed
            let isMouseDown = false;
            let startX = 0;
            let startY = 0;
            let startOffsetX = 0;
            let startOffsetY = 0;

            wrapper.addEventListener('mousedown', (e) => {
                const state = getPhotoZoomState(photo);
                if (state.zoom > 1 && e.button === 0) {
                    isMouseDown = true;
                    isDraggingPhoto = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    startOffsetX = state.offsetX;
                    startOffsetY = state.offsetY;
                    photo.style.cursor = 'grabbing';
                    currentActivePhoto = photo;
                    e.preventDefault();
                }
            });

            const handleMouseMove = (e) => {
                if (isMouseDown && currentActivePhoto === photo) {
                    const state = getPhotoZoomState(photo);
                    const deltaX = (e.clientX - startX) / state.zoom;
                    const deltaY = (e.clientY - startY) / state.zoom;
                    state.offsetX = startOffsetX + deltaX;
                    state.offsetY = startOffsetY + deltaY;
                    updatePhotoTransform(photo);
                }
            };

            const handleMouseUp = () => {
                if (isMouseDown && currentActivePhoto === photo) {
                    isMouseDown = false;
                    isDraggingPhoto = false;
                    const state = getPhotoZoomState(photo);
                    photo.style.cursor = state.zoom > 1 ? 'grab' : 'default';
                }
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);

            // Double click to reset zoom
            wrapper.addEventListener('dblclick', () => {
                const state = getPhotoZoomState(photo);
                state.zoom = 1;
                state.offsetX = 0;
                state.offsetY = 0;
                currentActivePhoto = photo;
                updatePhotoTransform(photo);
            });

            // Click to focus this photo for zoom controls
            wrapper.addEventListener('click', (e) => {
                if (!isMouseDown) {
                    currentActivePhoto = photo;
                }
            });
        }

        // Update photo transform
        function updatePhotoTransform(photo) {
            if (!photo) return;
            
            const state = getPhotoZoomState(photo);
            photo.style.transform = `scale(${state.zoom}) translate(${state.offsetX}px, ${state.offsetY}px)`;
            photo.style.cursor = state.zoom > 1 ? (isDraggingPhoto ? 'grabbing' : 'grab') : 'default';
            
            // Update zoom indicator
            const container = photo.closest('.photo-container');
            const indicator = container?.querySelector('.photo-zoom-indicator');
            if (indicator) {
                const baseText = indicator.getAttribute('data-base-text') || 'Photo';
                
                if (state.zoom > 1) {
                    indicator.innerHTML = `${baseText} <span class="ml-2 text-blue-400">${Math.round(state.zoom * 100)}%</span>`;
                } else {
                    indicator.textContent = baseText;
                }
            }
        }

        // Zoom in
        function zoomPhotoIn() {
            if (!currentActivePhoto) {
                const photos = document.querySelectorAll('.zoomable-photo');
                if (photos.length > 0) {
                    currentActivePhoto = photos[0];
                } else {
                    return;
                }
            }
            
            const state = getPhotoZoomState(currentActivePhoto);
            state.zoom = Math.min(5, state.zoom + 0.25);
            updatePhotoTransform(currentActivePhoto);
        }

        // Zoom out
        function zoomPhotoOut() {
            if (!currentActivePhoto) {
                const photos = document.querySelectorAll('.zoomable-photo');
                if (photos.length > 0) {
                    currentActivePhoto = photos[0];
                } else {
                    return;
                }
            }
            
            const state = getPhotoZoomState(currentActivePhoto);
            state.zoom = Math.max(0.5, state.zoom - 0.25);
            updatePhotoTransform(currentActivePhoto);
        }

        // Reset zoom
        function resetPhotoZoom() {
            if (!currentActivePhoto) {
                const photos = document.querySelectorAll('.zoomable-photo');
                if (photos.length > 0) {
                    currentActivePhoto = photos[0];
                } else {
                    return;
                }
            }
            
            const state = getPhotoZoomState(currentActivePhoto);
            state.zoom = 1;
            state.offsetX = 0;
            state.offsetY = 0;
            isDraggingPhoto = false;
            updatePhotoTransform(currentActivePhoto);
        }

        // Close photo viewer
        function closePhotoViewer() {
            const viewer = document.getElementById('photoViewer');
            const content = document.getElementById('photoViewerContent');
            if (viewer) {
                viewer.classList.add('hidden');
            }
            if (content) {
                content.innerHTML = '';
            }
            // Reset zoom state
            photoZoomStates.clear();
            currentActivePhoto = null;
            isDraggingPhoto = false;
            
            // Remove page zoom prevention
            document.removeEventListener('wheel', preventPageZoom, { capture: true });
        }

        // Close photo viewer on Escape key
        document.addEventListener('keydown', function(e) {
            const viewer = document.getElementById('photoViewer');
            if (e.key === 'Escape' && viewer && !viewer.classList.contains('hidden')) {
                closePhotoViewer();
            }
        });

        // Close modals
        function closeModal() {
            document.getElementById('batchModal').classList.add('hidden');
            currentBatch = null;
        }

        function closeReturnModal() {
            document.getElementById('returnModal').classList.add('hidden');
            document.getElementById('returnReason').value = '';
        }

        // Logout
        async function logout() {
            try {
                await window.signOut(window.auth);
            } catch (error) {
                console.warn('Logout error (Firebase signOut):', error);
            } finally {
                window.sotoSession?.clearSession();
                window.location.href = '/pages/soto-routes-login.html';
            }
        }

        // Helper functions for navigation
        async function showNotifications() {
            const dropdown = document.getElementById('notificationDropdown');
            if (!dropdown) return;
            
            // Toggle dropdown visibility
            dropdown.classList.toggle('hidden');
            
            if (!dropdown.classList.contains('hidden')) {
                // Load and display notifications
                await loadNotifications();
            }
        }

        function toggleProfileDropdown() {
            const dropdown = document.getElementById('profileDropdown');
            dropdown.classList.toggle('hidden');
        }

        function showChangePassword() {
            // TODO: Implement change password
            console.log('Change password clicked');
        }

        // Settings functions
        async function showSettings() {
            const modal = document.getElementById('settingsModal');
            const dropdown = document.getElementById('profileDropdown');
            dropdown.classList.add('hidden');
            modal.classList.remove('hidden');
            
            const useAsanaApi = window.sotoSettings?.getUseAsanaApiForRoutes() || false;
            const toggle = document.getElementById('useAsanaApiToggle');
            if (toggle) toggle.checked = useAsanaApi;

            const officeId = getCurrentOfficeId();
            if (officeId) {
                try {
                    const officeRef = window.doc(window.db, 'offices', officeId);
                    const officeSnap = await window.getDoc(officeRef);
                    const data = officeSnap.exists() ? officeSnap.data() : {};
                    const overdueToggle = document.getElementById('overdueNotificationToggle');
                    const overdueEmail = document.getElementById('overdueNotificationEmail');
                    if (overdueToggle) overdueToggle.checked = !!data.overdueNotificationEnabled;
                    if (overdueEmail) overdueEmail.value = data.overdueNotificationEmail || '';
                } catch (e) {
                    console.warn('Could not load office settings for overdue notification', e);
                }
            }
        }

        function hideSettings() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function handleAsanaApiToggle(checked) {
            if (window.sotoSettings) {
                window.sotoSettings.setUseAsanaApiForRoutes(checked);
                console.log('Asana API for routes setting updated:', checked);
            }
        }

        async function handleOverdueNotificationToggle(checked) {
            const officeId = getCurrentOfficeId();
            if (!officeId) return;
            const emailEl = document.getElementById('overdueNotificationEmail');
            const email = (emailEl && emailEl.value) ? emailEl.value.trim() : '';
            try {
                await window.updateDoc(window.doc(window.db, 'offices', officeId), {
                    overdueNotificationEnabled: !!checked,
                    overdueNotificationEmail: email || ''
                });
            } catch (e) {
                console.error('Failed to save overdue notification setting', e);
                if (window.uiDialogs) window.uiDialogs.showAlert({ title: 'Settings', message: 'Could not save. You may not have permission to update office settings.', tone: 'danger' });
            }
        }

        async function saveOverdueNotificationEmail() {
            const officeId = getCurrentOfficeId();
            if (!officeId) return;
            const toggle = document.getElementById('overdueNotificationToggle');
            const emailEl = document.getElementById('overdueNotificationEmail');
            const enabled = toggle ? toggle.checked : false;
            const email = (emailEl && emailEl.value) ? emailEl.value.trim() : '';
            try {
                await window.updateDoc(window.doc(window.db, 'offices', officeId), {
                    overdueNotificationEnabled: !!enabled,
                    overdueNotificationEmail: email
                });
            } catch (e) {
                console.error('Failed to save overdue notification email', e);
                if (window.uiDialogs) window.uiDialogs.showAlert({ title: 'Settings', message: 'Could not save. You may not have permission to update office settings.', tone: 'danger' });
            }
        }

        async function markBatchProcessed(batch) {
            const processedAt = new Date();
            if (!batch || !batch.id) {
                console.warn('Unable to mark batch processed: missing batch or ID', batch);
                batch.processedAt = processedAt;
                return processedAt;
            }

            try {
                await window.updateDoc(window.doc(window.db, 'expenseBatches', batch.id), {
                    processedAt: window.serverTimestamp(),
                    updatedAt: window.serverTimestamp()
                });
            } catch (error) {
                console.error(`Error marking batch ${batch.id} as processed:`, error);
            }

            batch.processedAt = processedAt;
            return processedAt;
        }

        // Generate PDFs for all paid expenses
        async function generateAllPDFs() {
            const paidBatches = allBatches.filter(b => b.status === 'paid');
            
            if (paidBatches.length === 0) {
                notifyInfo('There are no paid expenses available for PDF generation.', 'Nothing To Export');
                return;
            }

            const button = document.getElementById('generatePDFsBtn');
            const originalText = button.innerHTML;
            
            // Check if File System Access API is supported
            if (!('showDirectoryPicker' in window)) {
                // Fallback: Ask user if they want to download ZIP to Downloads folder
                const useDownloads = await showConfirmation({
                    title: 'Download ZIP Instead?',
                    message: 'Your browser does not support selecting folders.\n\nWould you like to download a ZIP file to your Downloads folder instead?\n\n(For folder selection, please use Chrome or Edge)',
                    confirmText: 'Download ZIP',
                    cancelText: 'Cancel',
                    tone: 'info'
                });
                
                if (useDownloads) {
                    await downloadAllPDFsAsZIP(paidBatches, button, originalText);
                }
                return;
            }

            try {
                button.disabled = true;
                button.innerHTML = '<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Selecting folder...';
                
                // Ask user to select a folder
                const directoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite'
                });
                
                button.innerHTML = '<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Generating PDFs...';
                
                let processed = 0;
                let transferred = 0;
                let total = paidBatches.length;
                
                // Process each paid batch
                for (const batch of paidBatches) {
                    try {
                        await markBatchProcessed(batch);
                        await generateAndSaveExpensePDF(batch, directoryHandle);
                        // Mark as transferred after successful generation (auto-delete in 7 days / 168 hours)
                        const deleteAt = new Date();
                        deleteAt.setHours(deleteAt.getHours() + 168); // 168 hours = 7 days
                        
                        await window.updateDoc(window.doc(window.db, 'expenseBatches', batch.id), {
                            status: 'transferred',
                            transferredAt: window.serverTimestamp(),
                            deleteAt: deleteAt,
                            updatedAt: window.serverTimestamp()
                        });
                        transferred++;
                        processed++;
                        button.innerHTML = `<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Processing ${processed}/${total}...`;
                    } catch (error) {
                        console.error(`Error processing batch ${batch.registration}:`, error);
                        // Continue with next batch
                    }
                }
                
                button.innerHTML = '<span class="material-symbols-outlined">check_circle</span> Complete!';
                setTimeout(() => {
                    button.disabled = false;
                    button.innerHTML = originalText;
                }, 2000);
                
                // Reload batches to reflect transferred status
                await loadAllBatches();
                
                notifySuccess(`Successfully generated and transferred ${transferred} out of ${total} expense PDFs!`, 'PDF Export Complete');
                
            } catch (error) {
                if (error.name === 'AbortError' || error.message?.includes('canceled')) {
                    // User cancelled folder selection - offer Downloads fallback
                    const useDownloads = await showConfirmation({
                        title: 'Download ZIP Instead?',
                        message: 'Folder selection cancelled.\n\nWould you like to download a ZIP file to your Downloads folder instead?',
                        confirmText: 'Download ZIP',
                        cancelText: 'Cancel',
                        tone: 'warning'
                    });
                    if (useDownloads) {
                        await downloadAllPDFsAsZIP(paidBatches, button, originalText);
                    } else {
                        button.disabled = false;
                        button.innerHTML = originalText;
                    }
                    return;
                }
                console.error('Error generating PDFs:', error);
                notifyError('Error generating PDFs: ' + error.message);
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        // Generate PDF and save to folder structure (simplified: date/driverName/registration/)
        async function generateAndSaveExpensePDF(batch, rootDirectoryHandle) {
            // Get payment date for folder structure (use day's date)
            const paymentDate = batch.paidAt?.toDate ? batch.paidAt.toDate() : 
                               (batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date());
            
            const year = paymentDate.getFullYear();
            const month = String(paymentDate.getMonth() + 1).padStart(2, '0');
            const day = String(paymentDate.getDate()).padStart(2, '0');
            
            // Date folder name: DD_MM_YYYY
            const dateFolderName = `${day}_${month}_${year}`;
            
            // Clean driver name for folder
            const driverName = (batch.driverName || 'Unknown_Driver')
                .replace(/[\/\\:]/g, '-')
                .replace(/\s+/g, '_');
            
            // Clean registration for folder
            const cleanedReg = batch.registration
                .replace(/[\/\\:]/g, '-')
                .replace(/\s+/g, '_');
            
            // Create simplified folder structure: dateFolderName/driverName/registration/
            let currentHandle = rootDirectoryHandle;
            
            // Date folder
            currentHandle = await getOrCreateFolder(currentHandle, dateFolderName);
            // Driver folder
            currentHandle = await getOrCreateFolder(currentHandle, driverName);
            // Registration folder
            currentHandle = await getOrCreateFolder(currentHandle, cleanedReg);
            
            // Generate PDF
            const pdfBlob = await generateExpensePDF(batch);
            
            // Save PDF
            const driverNameForFile = driverName.replace(/_/g, ' ');
            const pdfFileName = `${cleanedReg}_${driverNameForFile}.pdf`;
            const pdfFileHandle = await currentHandle.getFileHandle(pdfFileName, { create: true });
            const pdfWritable = await pdfFileHandle.createWritable();
            await pdfWritable.write(pdfBlob);
            await pdfWritable.close();
            
            const usedLineKeys = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines)) ? (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines).call(null, batch) : [];
            const expensesForPhotos = usedLineKeys.map(k => (batch.lines || {})[k]).filter(Boolean);
            let photoIndex = 1;
            for (const expense of expensesForPhotos) {
                const urls = (expense.photos || []).filter(isValidPhotoURL);
                if (urls.length > 0) {
                    for (const photoURL of urls) {
                        try {
                            // Fetch photo from Firebase Storage
                            const response = await fetch(photoURL);
                            const photoBlob = await response.blob();
                            
                            // Save photo
                            const photoFileName = `photo_${photoIndex}.jpg`;
                            const photoFileHandle = await currentHandle.getFileHandle(photoFileName, { create: true });
                            const photoWritable = await photoFileHandle.createWritable();
                            await photoWritable.write(photoBlob);
                            await photoWritable.close();
                            
                            photoIndex++;
                        } catch (error) {
                            console.error('Error saving photo:', photoURL, error);
                        }
                    }
                }
            }
            
            console.log(`Saved PDF and photos for batch ${batch.registration} to folder structure`);
        }

        // Download all PDFs as ZIP (fallback for browsers without File System Access API)
        async function downloadAllPDFsAsZIP(paidBatches, button, originalText) {
            try {
                button.disabled = true;
                button.innerHTML = '<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Generating ZIP...';
                
                const zip = new JSZip();
                let processed = 0;
                let transferred = 0;
                const total = paidBatches.length;
                
                // Process each paid batch
                for (const batch of paidBatches) {
                    button.innerHTML = `<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Processing ${processed + 1}/${total}...`;
                    
                    // Get payment date for folder structure
                    const paymentDate = batch.paidAt?.toDate ? batch.paidAt.toDate() : 
                                       (batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date());
                    
                    const year = paymentDate.getFullYear();
                    const month = String(paymentDate.getMonth() + 1).padStart(2, '0');
                    const day = String(paymentDate.getDate()).padStart(2, '0');
                    const dateFolderName = `${day}_${month}_${year}`;
                    
                    // Clean driver name
                    const driverName = (batch.driverName || 'Unknown_Driver')
                        .replace(/[\/\\:]/g, '-')
                        .replace(/\s+/g, '_');
                    
                    // Clean registration
                    const cleanedReg = batch.registration
                        .replace(/[\/\\:]/g, '-')
                        .replace(/\s+/g, '_');
                    
                    // Folder path: dateFolderName/driverName/cleanedReg/
                    const folderPath = `${dateFolderName}/${driverName}/${cleanedReg}/`;
                    
                    // Generate PDF
                    await markBatchProcessed(batch);
                    const pdfBlob = await generateExpensePDF(batch);
                    
                    // Add PDF to ZIP
                    const driverNameForFile = driverName.replace(/_/g, ' ');
                    const pdfFileName = `${cleanedReg}_${driverNameForFile}.pdf`;
                    zip.file(folderPath + pdfFileName, pdfBlob);
                    
                    const usedLineKeys = (typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines)) ? (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines).call(null, batch) : [];
                    const expensesForPhotos = usedLineKeys.map(k => (batch.lines || {})[k]).filter(Boolean);
                    let photoIndex = 1;
                    for (const expense of expensesForPhotos) {
                        const urls = (expense.photos || []).filter(isValidPhotoURL);
                        if (urls.length > 0) {
                            for (const photoURL of urls) {
                                try {
                                    const response = await fetch(photoURL);
                                    const photoBlob = await response.blob();
                                    zip.file(folderPath + `photo_${photoIndex}.jpg`, photoBlob);
                                    photoIndex++;
                                } catch (error) {
                                    console.error('Error downloading photo:', photoURL, error);
                                }
                            }
                        }
                    }
                    
                    processed++;
                }
                
                // Generate and download ZIP
                button.innerHTML = '<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Creating ZIP...';
                const zipBlob = await zip.generateAsync({ type: 'blob' });
                const url = URL.createObjectURL(zipBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Expense_Reports_${new Date().toISOString().split('T')[0]}.zip`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Mark all batches as transferred after successful ZIP download
                button.innerHTML = '<span class="material-symbols-outlined animate-spin">hourglass_empty</span> Updating status...';
                for (const batch of paidBatches) {
                    try {
                        // Mark as transferred (auto-delete in 7 days / 168 hours)
                        const deleteAt = new Date();
                        deleteAt.setHours(deleteAt.getHours() + 168); // 168 hours = 7 days
                        
                        await window.updateDoc(window.doc(window.db, 'expenseBatches', batch.id), {
                            status: 'transferred',
                            transferredAt: window.serverTimestamp(),
                            deleteAt: deleteAt,
                            updatedAt: window.serverTimestamp()
                        });
                        transferred++;
                    } catch (error) {
                        console.error(`Error marking batch ${batch.id} as transferred:`, error);
                    }
                }
                
                // Reload batches to reflect transferred status
                await loadAllBatches();
                
                button.innerHTML = '<span class="material-symbols-outlined">check_circle</span> Complete!';
                setTimeout(() => {
                    button.disabled = false;
                    button.innerHTML = originalText;
                }, 2000);
                
                notifySuccess(`Successfully generated and transferred ${transferred} expense PDFs!`, 'PDF Export Complete');
            } catch (error) {
                console.error('Error generating ZIP:', error);
                notifyError('Error generating ZIP: ' + error.message);
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        // Helper function to get or create a folder
        async function getOrCreateFolder(parentHandle, folderName) {
            const finalName = sanitizeName(folderName, { fallbackPrefix: 'Folder' });

            if (finalName !== folderName) {
                console.warn(`Sanitized folder name from "${folderName}" to "${finalName}"`);
            }

            try {
                return await parentHandle.getDirectoryHandle(finalName, { create: true });
            } catch (error) {
                console.error(`Error creating folder ${folderName}:`, error);
                throw error;
            }
        }

        // Generate PDF for expense batch (matching app layout exactly)
        async function generateExpensePDF(batch) {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Get dates
            const paymentDate = batch.paidAt?.toDate ? batch.paidAt.toDate() : 
                               (batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date());
            const submissionDate = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
            const validationDate = batch.validatedAt?.toDate ? batch.validatedAt.toDate() : null;
            const processedDate = batch.processedAt?.toDate
                ? batch.processedAt.toDate()
                : (batch.processedAt instanceof Date
                    ? batch.processedAt
                    : (batch.processedAt ? new Date(batch.processedAt) : null));
            
            // Format dates (medium date style with short time)
            const formatDate = (date) => {
                if (!date) return 'Not set';
                const options = { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                };
                return date.toLocaleDateString('en-GB', options);
            };
            
            const ptToMm = 0.352778; // Conversion factor: 1pt = 0.352778mm
            let y = 32 * ptToMm; // Start at 32pt = 11.3mm (matching app)
            
            // Title - centered, 28pt bold
            doc.setFontSize(28);
            doc.setFont(undefined, 'bold');
            const titleWidth = doc.getTextWidth('Expense Report');
            doc.text('Expense Report', (210 - titleWidth) / 2, y);
            y += 24 * ptToMm; // 24pt = 8.5mm
            
            // Information section - 16pt medium weight
            doc.setFontSize(16);
            doc.setFont(undefined, 'normal');
            const infoStartX = 48 * ptToMm; // 48pt left margin = 17mm (matching app)
            doc.text(`Registration: ${batch.registration}`, infoStartX, y);
            y += 24 * ptToMm; // 24pt = 8.5mm
            doc.text(`Driver: ${batch.driverName || 'Unknown'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Submitted on: ${formatDate(submissionDate)}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Validated on: ${validationDate ? formatDate(validationDate) : 'Not validated'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Paid on: ${paymentDate ? formatDate(paymentDate) : 'Not paid'}`, infoStartX, y);
            y += 24 * ptToMm;
            doc.text(`Processed on: ${processedDate ? formatDate(processedDate) : 'Not processed'}`, infoStartX, y);
            y += 28 * ptToMm; // 28pt = 9.9mm before table
            
            // Table setup (matching app dimensions)
            // App uses: pageWidth = 595.2pt (A4), left margin = 48pt, tableWidth = 595.2 - 96 = 499.2pt
            // Column 0 (Category) = 120pt, remaining 5 columns = (499.2 - 120) / 5 = 75.84pt each
            // Converting to mm (1pt = 0.352778mm): col0 = 42.33mm, colRest = 26.75mm each
            const tableStartY = y;
            const pageWidth = 210; // A4 width in mm
            const leftMargin = 48 * 0.352778; // 48pt in mm â‰ˆ 17mm
            const tableWidth = pageWidth - (leftMargin * 2); // Total width minus margins
            const col0 = 42.33; // Category column in mm
            const colRest = (tableWidth - col0) / 5; // Remaining 5 columns equally divided
            
            // Category normalization map
            const categoryMap = {
                'fuel': 'Fuel',
                'charge': 'Charge',
                'train': 'Train',
                'train fare': 'Train',
                'bus': 'Bus',
                'taxi': 'Taxi',
                'car wash': 'Car Wash',
                'carwash': 'Car Wash',
                'toll': 'Tolls',
                'tolls': 'Tolls',
                'other': 'Other'
            };
            
            const categories = ['Fuel', 'Charge', 'Train', 'Bus', 'Taxi', 'Car Wash', 'Tolls', 'Other'];
            const expensesByCategory = {};
            if (batch.lines && typeof EXPENSE_BATCH_SCHEMA !== 'undefined' && (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines)) {
                const prefixToCat = { train: 'Train', taxi: 'Taxi', fuel: 'Fuel', charge: 'Charge', bus: 'Bus', carWash: 'Car Wash', toll: 'Tolls', other: 'Other' };
                (EXPENSE_BATCH_SCHEMA.getUsedLinesInOrder || EXPENSE_BATCH_SCHEMA.getUsedLines).call(null, batch).forEach(lineKey => {
                    const line = batch.lines[lineKey];
                    if (!line || !EXPENSE_BATCH_SCHEMA.hasLineContent(line)) return;
                    const prefix = (EXPENSE_BATCH_SCHEMA.getCategoryGroup && EXPENSE_BATCH_SCHEMA.getCategoryGroup(lineKey)) || 'other';
                    const cat = prefixToCat[prefix] || 'Other';
                    if (!expensesByCategory[cat]) expensesByCategory[cat] = [];
                    expensesByCategory[cat].push({ amount: line.amount || 0, photos: line.photos || [] });
                });
            }

            // Create table data matching app format
            const tableData = [];
            const headers = ['', '1', '2', '3', '4', 'TOTAL'];
            
            // Add header row
            tableData.push(headers);
            
            // Add category rows
            categories.forEach(category => {
                const categoryExpenses = expensesByCategory[category] || [];
                const row = [category];
                
                // Add up to 4 individual expenses
                for (let i = 0; i < 4; i++) {
                    if (i < categoryExpenses.length) {
                        row.push(`Â£${parseFloat(categoryExpenses[i].amount || 0).toFixed(2)}`);
                    } else {
                        row.push('');
                    }
                }
                
                // Calculate category total
                const categoryTotal = categoryExpenses.reduce((sum, exp) => sum + parseFloat(exp.amount || 0), 0);
                row.push(categoryTotal > 0 ? `Â£${categoryTotal.toFixed(2)}` : '');
                
                tableData.push(row);
            });
            
            // Add total row
            const totalRow = ['TOTAL', '', '', '', '', `Â£${batch.totalAmount?.toFixed(2) || '0.00'}`];
            tableData.push(totalRow);
            
            // Draw table using autoTable with custom styling to match app
            doc.autoTable({
                startY: tableStartY,
                head: [tableData[0]],
                body: tableData.slice(1),
                headStyles: { 
                    fillColor: [217, 217, 217], // Gray background (0.85 white)
                    textColor: 0,
                    fontStyle: 'bold',
                    fontSize: 15
                },
                bodyStyles: {
                    fontSize: 15,
                    textColor: 0
                },
                alternateRowStyles: {
                    fillColor: [245, 245, 245] // Very light gray (0.96 white)
                },
                columnStyles: {
                    0: { cellWidth: col0, fontStyle: 'bold' },
                    1: { cellWidth: colRest, halign: 'left' },
                    2: { cellWidth: colRest, halign: 'left' },
                    3: { cellWidth: colRest, halign: 'left' },
                    4: { cellWidth: colRest, halign: 'left' },
                    5: { cellWidth: colRest, halign: 'left', fontStyle: 'bold' }
                },
                styles: {
                    lineWidth: 1,
                    lineColor: 0
                },
                margin: { left: infoStartX }
            });
            
            y = doc.lastAutoTable.finalY + 40;
            
            // Generate expense summary lines (matching app format)
            const primaryCategories = ['Fuel', 'Charge', 'Car Wash'];
            const secondaryCategories = ['Bus', 'Train', 'Taxi', 'Tolls', 'Other'];
            
            // Primary line (bold)
            const primaryAmounts = [];
            primaryCategories.forEach(cat => {
                const exp = expensesByCategory[cat] || [];
                if (exp.length > 0) {
                    const amounts = exp.map(e => `Â£${parseFloat(e.amount || 0).toFixed(2)}`).join(' + ');
                    primaryAmounts.push(`${cat}:(${amounts})`);
                }
            });
            
            if (primaryAmounts.length > 0) {
                doc.setFontSize(13);
                doc.setFont(undefined, 'bold');
                doc.text(primaryAmounts.join('  '), infoStartX, y);
                y += 24 * ptToMm;
            }
            
            // Secondary line (regular)
            const secondaryAmounts = [];
            secondaryCategories.forEach(cat => {
                const exp = expensesByCategory[cat] || [];
                if (exp.length > 0) {
                    const amounts = exp.map(e => `Â£${parseFloat(e.amount || 0).toFixed(2)}`).join(' + ');
                    secondaryAmounts.push(`${cat}: (${amounts})`);
                }
            });
            
            if (secondaryAmounts.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'normal');
                doc.text(secondaryAmounts.join(' '), infoStartX, y);
                y += 24 * ptToMm;
            }
            
            // Total line (bold)
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            doc.text(`Total: Â£${batch.totalAmount?.toFixed(2) || '0.00'}`, infoStartX, y);
            y += 32 * ptToMm;
            
            // Footer text
            doc.setFontSize(13);
            doc.setFont(undefined, 'italic');
            doc.setTextColor(105, 105, 105); // darkGray
            const footerText = 'This report is for client records. Please retain for your files.\n\nIf you have any questions, contact SOTO support.';
            doc.text(footerText, infoStartX, y, { maxWidth: 210 - (infoStartX * 2), align: 'left' });
            
            // Bottom footer
            doc.setFontSize(12);
            doc.setTextColor(128, 128, 128); // gray
            doc.text('Expense report generated by - SOTORoutes', 
                    105, 280, { align: 'center' });
            
            return doc.output('blob');
        }


        // Check for expenses over 24 working hours old; returns { total, pendingCount, validatedCount }
        async function checkOldExpenses(officeId) {
            try {
                const batchesQuery = window.query(
                    window.collection(window.db, 'expenseBatches'),
                    window.where('officeId', '==', officeId)
                );
                const batchesSnapshot = await window.getDocs(batchesQuery);
                const now = new Date();
                let pendingCount = 0;
                let validatedCount = 0;
                batchesSnapshot.docs.forEach(doc => {
                    const batch = doc.data();
                    if (batch.status !== 'pending' && batch.status !== 'validated') return;
                    const submittedAt = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                    if (!submittedAt) return;
                    const workingHours = calculateWorkingHours(submittedAt, now);
                    if (workingHours > 24) {
                        if (batch.status === 'pending') pendingCount++;
                        else validatedCount++;
                    }
                });
                return { total: pendingCount + validatedCount, pendingCount, validatedCount };
            } catch (error) {
                console.error('Error checking old expenses:', error);
                return { total: 0, pendingCount: 0, validatedCount: 0 };
            }
        }

        // Which tab to open for overdue notification: pending if any overdue in pending (or both), else validated
        function getOverdueExpensesTab(result) {
            if (!result || result.total === 0) return 'pending';
            if (result.pendingCount > 0) return 'pending';
            return 'validated';
        }

        // Update notification count across all office pages
        async function updateNotificationCount() {
            try {
                console.log('[EXPENSES] updateNotificationCount called');
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.log('[EXPENSES] No office context available for notifications');
                    return;
                }
                
                console.log('[EXPENSES] Office ID:', officeId);
                
                // Get all availability change notifications for this office
                const notificationsQuery = window.query(
                    window.collection(window.db, 'availabilityNotifications'),
                    window.where('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.getDocs(notificationsQuery);
                console.log('[EXPENSES] Total notifications found:', notificationsSnapshot.docs.length);
                
                // Aggregate notifications by driver
                const driverChanges = {};
                // Filter to only unseen notifications and convert dates
                const allNotifications = notificationsSnapshot.docs
                    .map(doc => {
                        const data = doc.data();
                        return {
                            id: doc.id,
                            ...data,
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt)
                        };
                    })
                    .filter(notification => notification.seen !== true) // Only include unseen notifications
                    .sort((a, b) => b.createdAt - a.createdAt); // Sort by date (most recent first)
                
                console.log('[EXPENSES] Unseen notifications:', allNotifications.length);
                
                // Group by driver and only count the most recent batch (within 1 hour of latest)
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    if (!driverId) return;
                    
                    if (!driverChanges[driverId]) {
                        // First notification for this driver (most recent)
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName || 'Unknown Driver',
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [],
                            latestDate: notification.createdAt,
                            earliestDate: notification.createdAt
                        };
                        
                        if (notification.changeType === 'unavailable') {
                            driverChanges[driverId].daysOff = 1;
                        } else {
                            driverChanges[driverId].daysAvailable = 1;
                        }
                        driverChanges[driverId].notifications.push(notification);
                    } else {
                        // Check if this notification is within 1 hour of the latest (most recent) one
                        // This ensures we only count the most recent batch, not old unseen notifications
                        const timeDiffFromLatest = Math.abs(driverChanges[driverId].latestDate - notification.createdAt);
                        const oneHour = 60 * 60 * 1000; // 1 hour in milliseconds

                        if (timeDiffFromLatest <= oneHour) {
                            // Same batch - add to counts
                            if (notification.changeType === 'unavailable') {
                                driverChanges[driverId].daysOff++;
                            } else {
                                driverChanges[driverId].daysAvailable++;
                            }
                            driverChanges[driverId].notifications.push(notification);
                            // Update earliest date if this is older
                            if (notification.createdAt < driverChanges[driverId].earliestDate) {
                                driverChanges[driverId].earliestDate = notification.createdAt;
                            }
                            // latestDate stays as the most recent (first one we found)
                        }
                        // If outside the batch window (more than 1 hour from latest), ignore it
                    }
                });
                
                // Count total number of drivers with changes
                const availabilityCount = Object.keys(driverChanges).length;
                console.log('[EXPENSES] Drivers with changes:', availabilityCount);
                
                // Check for old expenses (>24 working hours)
                const oldExpenseResult = await checkOldExpenses(officeId);
                console.log('[EXPENSES] Old expenses count:', oldExpenseResult.total);
                
                // Total notification count (availability changes + old expenses)
                const unreadCount = availabilityCount + (oldExpenseResult.total > 0 ? 1 : 0);
                console.log('[EXPENSES] Total unread count:', unreadCount);
                
                // Update notification badge on all pages
                updateNotificationBadge(unreadCount);
                console.log('[EXPENSES] Badge updated');
                
            } catch (error) {
                console.error('[EXPENSES] Error updating notification count:', error);
            }
        }

        // Update notification badge display
        function updateNotificationBadge(count) {
            console.log('[EXPENSES] updateNotificationBadge called with count:', count);
            const badgeElements = document.querySelectorAll('.notification-badge');
            console.log('[EXPENSES] Found badge elements:', badgeElements.length);
            badgeElements.forEach((badge, index) => {
                console.log(`[EXPENSES] Badge ${index}:`, badge);
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.classList.remove('hidden');
                    console.log(`[EXPENSES] Badge ${index} shown with count:`, badge.textContent);
                } else {
                    badge.classList.add('hidden');
                    console.log(`[EXPENSES] Badge ${index} hidden`);
                }
            });
        }

        // Load notifications for dropdown (aggregated by driver)
        async function loadNotifications() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) return;
                
                // Get all availability change notifications for this office
                const notificationsQuery = window.query(
                    window.collection(window.db, 'availabilityNotifications'),
                    window.where('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.getDocs(notificationsQuery);
                const notificationsList = document.getElementById('notificationsList');
                
                const oldExpenseResult = await checkOldExpenses(officeId);
                const overdueTab = getOverdueExpensesTab(oldExpenseResult);
                
                const driverChanges = {};
                // Filter to only unseen notifications and convert dates
                const allNotifications = notificationsSnapshot.docs
                    .map(doc => {
                        const data = doc.data();
                        return {
                            id: doc.id,
                            ...data,
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt)
                        };
                    })
                    .filter(notification => notification.seen !== true) // Only include unseen notifications
                    .sort((a, b) => b.createdAt - a.createdAt); // Sort by date (most recent first)
                
                // Group by driver and only count the most recent batch (within 1 hour of latest)
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    if (!driverId) return;
                    
                    if (!driverChanges[driverId]) {
                        // First notification for this driver (most recent)
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName || 'Unknown Driver',
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [],
                            latestDate: notification.createdAt,
                            earliestDate: notification.createdAt
                        };
                        
                        if (notification.changeType === 'unavailable') {
                            driverChanges[driverId].daysOff = 1;
                        } else {
                            driverChanges[driverId].daysAvailable = 1;
                        }
                        driverChanges[driverId].notifications.push(notification);
                    } else {
                        // Check if this notification is within 1 hour of the latest (most recent) one
                        const timeDiffFromLatest = Math.abs(driverChanges[driverId].latestDate - notification.createdAt);
                        const oneHour = 60 * 60 * 1000; // 1 hour in milliseconds

                        if (timeDiffFromLatest <= oneHour) {
                            // Same batch - add to counts
                            if (notification.changeType === 'unavailable') {
                                driverChanges[driverId].daysOff++;
                            } else {
                                driverChanges[driverId].daysAvailable++;
                            }
                            driverChanges[driverId].notifications.push(notification);
                            // Update earliest date if this is older
                            if (notification.createdAt < driverChanges[driverId].earliestDate) {
                                driverChanges[driverId].earliestDate = notification.createdAt;
                            }
                            // latestDate stays as the most recent (first one we found)
                        }
                        // If outside the batch window (more than 1 hour from latest), ignore it
                    }
                });
                
                const sortedDrivers = Object.values(driverChanges).sort((a, b) => b.latestDate - a.latestDate);
                notificationsList.innerHTML = '';
                
                if (oldExpenseResult.total > 0) {
                    const expenseNotification = createOldExpenseNotificationElement(oldExpenseResult.total, overdueTab);
                    notificationsList.appendChild(expenseNotification);
                }
                
                sortedDrivers.forEach(driverData => {
                    const notificationElement = createAggregatedNotificationElement(driverData);
                    notificationsList.appendChild(notificationElement);
                });
                
                if (oldExpenseResult.total === 0 && sortedDrivers.length === 0) {
                    notificationsList.innerHTML = '<div class="px-4 py-3 text-gray-400 text-sm text-center">No notifications yet</div>';
                }
            } catch (error) {
                console.error('Error loading notifications:', error);
            }
        }

        // Create old expense notification element; tab = which tab to open (pending or validated)
        function createOldExpenseNotificationElement(count, tab) {
            const openTab = (tab === 'validated' || tab === 'pending') ? tab : 'pending';
            const url = '/pages/expenses.html?tab=' + openTab;
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => {
                document.getElementById('notificationDropdown').classList.add('hidden');
                window.location.href = url;
            };
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">There ${count === 1 ? 'is' : 'are'} ${count} expense${count === 1 ? '' : 's'} over 24 working hours old</div>
                        <div class="text-[#9cabba] text-xs mt-1">Click to view in ${openTab === 'validated' ? 'Validated' : 'Pending'} tab</div>
                    </div>
                    <div class="w-2 h-2 bg-red-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }

        // Create aggregated notification element
        function createAggregatedNotificationElement(driverData) {
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => handleAggregatedNotificationClick(driverData);
            
            let message = '';
            if (driverData.daysOff > 0 && driverData.daysAvailable > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off and is available for ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'}`;
            } else if (driverData.daysOff > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off`;
            } else {
                message = `${driverData.driverName} is available for ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'}`;
            }
            
            const timeAgo = getTimeAgo(driverData.latestDate);
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">${message}</div>
                        <div class="text-[#9cabba] text-xs mt-1">${timeAgo}</div>
                    </div>
                    <div class="w-2 h-2 bg-blue-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }

        async function handleAggregatedNotificationClick(driverData) {
            try {
                // Hide dropdown
                document.getElementById('notificationDropdown').classList.add('hidden');
                
                // Navigate to availability page
                const dates = driverData.notifications.map(n => n.date).sort();
                const earliestDate = dates[0] ? new Date(dates[0]) : new Date();
                const year = earliestDate.getFullYear();
                const month = earliestDate.getMonth() + 1;
                
                window.location.href = `/pages/availability.html?year=${year}&month=${month}&showChanges=${driverData.driverId}`;
                
            } catch (error) {
                console.error('Error handling aggregated notification click:', error);
            }
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins} ${diffMins === 1 ? 'minute' : 'minutes'} ago`;
            if (diffHours < 24) return `${diffHours} ${diffHours === 1 ? 'hour' : 'hours'} ago`;
            if (diffDays < 7) return `${diffDays} ${diffDays === 1 ? 'day' : 'days'} ago`;
            return date.toLocaleDateString();
        }

        // Initialize notification system on page load
        async function initializeNotifications() {
            await updateNotificationCount();
            
            // Set up click outside to close dropdown
            document.addEventListener('click', function(event) {
                const dropdown = document.getElementById('notificationDropdown');
                const button = event.target.closest('button[onclick="showNotifications()"]');
                
                if (!dropdown || !button) return;
                
                if (!dropdown.contains(event.target) && !button.contains(event.target)) {
                    dropdown.classList.add('hidden');
                }
            });
            
            // Update notifications periodically
            setInterval(async () => {
                await updateNotificationCount();
            }, 30000); // Every 30 seconds
            
            // Update when page becomes visible
            document.addEventListener('visibilitychange', async () => {
                if (!document.hidden) {
                    await updateNotificationCount();
                }
            });
        }

        // Initialize search functionality
        function initializeSearch() {
            const searchInput = document.getElementById('expenseSearch');
            const searchResults = document.getElementById('searchResults');
            let searchTimeout;
            
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.trim().toLowerCase();
                
                clearTimeout(searchTimeout);
                
                if (query.length < 2) {
                    searchResults.classList.add('hidden');
                    return;
                }
                
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300); // Debounce search
            });
            
            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                const searchContainer = document.getElementById('expenseSearch').parentElement;
                if (!searchContainer.contains(e.target)) {
                    searchResults.classList.add('hidden');
                }
            });
        }
        
        // Perform search across all batches
        function performSearch(query) {
            const searchResults = document.getElementById('searchResults');
            const results = [];
            
            // Search through all batches (exclude drafts)
            allBatches.forEach(batch => {
                if (batch.status === 'draft') return;
                const driverName = (batch.driverName || '').toLowerCase();
                const driverEmail = (batch.driverEmail || '').toLowerCase();
                const registration = (batch.registration || '').toLowerCase();
                const batchId = batch.id.toLowerCase();
                
                if (driverName.includes(query) || 
                    driverEmail.includes(query) || 
                    registration.includes(query) ||
                    batchId.includes(query)) {
                    results.push(batch);
                }
            });
            
            if (results.length === 0) {
                searchResults.innerHTML = `
                    <div class="px-4 py-3 text-gray-400 text-sm text-center">
                        No expenses found
                    </div>
                `;
            } else {
                searchResults.innerHTML = results.slice(0, 10).map(batch => {
                    const date = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date();
                    const statusColors = {
                        pending: 'bg-orange-500',
                        validated: 'bg-blue-500',
                        paid: 'bg-green-500',
                        returned: 'bg-red-500'
                    };
                    const statusColor = statusColors[batch.status] || 'bg-gray-500';
                    
                    return `
                        <div onclick="selectSearchResult('${batch.id}')" 
                            class="px-4 py-3 border-b border-gray-800 hover:bg-[#283039] cursor-pointer transition-colors">
                            <div class="flex items-center justify-between">
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span class="px-2 py-0.5 ${statusColor} text-white text-xs rounded-full font-semibold">${batch.status}</span>
                                        <span class="font-semibold text-white">${batch.driverName || 'Unknown Driver'}</span>
                                    </div>
                                    <div class="text-sm text-gray-400">${batch.driverEmail || ''}</div>
                                    <div class="text-xs text-gray-500 mt-1">${batch.registration || 'No Reg'} â€¢ ${date.toLocaleDateString()}</div>
                                </div>
                                <div class="text-right ml-4">
                                    <div class="text-green-400 font-semibold">Â£${batch.totalAmount?.toFixed(2) || '0.00'}</div>
                                    <div class="text-xs text-gray-500">${getBatchItemCount(batch)} item${getBatchItemCount(batch) !== 1 ? 's' : ''}</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            searchResults.classList.remove('hidden');
        }
        
        // Handle search result selection
        function selectSearchResult(batchId) {
            const batch = allBatches.find(b => b.id === batchId);
            if (!batch) return;
            
            // Switch to the appropriate tab
            switchTab(batch.status);
            
            // Close search
            document.getElementById('expenseSearch').value = '';
            document.getElementById('searchResults').classList.add('hidden');
            
            // Scroll to and highlight the batch (open modal)
            setTimeout(() => {
                openBatchDetail(batchId);
            }, 100);
        }

        function viewUsage() {
            const officeId = getCurrentOfficeId();
            if (!officeId) {
                notifyWarning('Unable to determine office ID.');
                return;
            }
            window.location.href = `/pages/office-calendar.html?officeId=${officeId}`;
        }

        function sanitizeName(rawName, options = {}) {
            if (!rawName) return '';

            const { replaceSpaces = false, fallbackPrefix = 'Item', allowDot = false } = options;

            let name = String(rawName)
                .replace(/\*/g, '!')
                .replace(/[<>:"/\\|?\x00-\x1F]/g, '');

            if (replaceSpaces) {
                name = name.replace(/\s+/g, '_');
            }

            name = name.trim();

            if (!allowDot) {
                name = name.replace(/[. ]+$/g, '');
            }

            if (!name) {
                return `${fallbackPrefix}-${Date.now()}`;
            }

            return name;
        }
    </script>
</div>
</div>

<!-- Settings Modal -->
<div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-md">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold text-white">Settings</h3>
            <button onclick="hideSettings()" class="text-gray-400 hover:text-white">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        
            <div class="space-y-4">
                <div class="flex items-center justify-between py-3 border-b border-[#283039]">
                    <div class="flex-1">
                        <label for="useAsanaApiToggle" class="block text-sm font-medium text-white mb-1">
                            Use Asana API for route input
                        </label>
                        <p class="text-xs text-gray-400">When enabled, routes button will redirect to automatic routes page</p>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input 
                            type="checkbox" 
                            id="useAsanaApiToggle" 
                            class="sr-only peer"
                            onchange="handleAsanaApiToggle(this.checked)"
                        >
                        <div class="w-11 h-6 bg-[#283039] peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div class="py-3 border-b border-[#283039]">
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex-1">
                            <label for="overdueNotificationToggle" class="block text-sm font-medium text-white mb-1">
                                Receive an email notification when expenses are overdue
                            </label>
                            <p class="text-xs text-gray-400">One email when expense batches first pass 24 working hours</p>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer shrink-0 ml-2">
                            <input type="checkbox" id="overdueNotificationToggle" class="sr-only peer" onchange="handleOverdueNotificationToggle(this.checked)">
                            <div class="w-11 h-6 bg-[#283039] peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                    </div>
                    <input type="email" id="overdueNotificationEmail" placeholder="Email address for notifications" class="w-full mt-2 px-3 py-2 bg-[#111418] border border-[#283039] rounded-lg text-white placeholder-gray-500 focus:outline-none focus:border-blue-500" onblur="saveOverdueNotificationEmail()">
                </div>
            </div>
            
            <div class="mt-6 flex justify-end">
            <button 
                onclick="hideSettings()"
                class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors font-medium"
            >
                Close
            </button>
        </div>
    </div>
</div>
</body>
</html>

