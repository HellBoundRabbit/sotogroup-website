<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SOTO Routes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="/manifest.json">
    <title>Wait Times - Driver Portal</title>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="../js/ui-dialogs.js"></script>
    <script src="/js/session-manager.js"></script>
    <!-- Offline Storage & Upload Queue System -->
    <script src="/js/expense-offline-storage.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet">
    <style>
        .touch-target { min-height: 44px; min-width: 44px; }
        .license-plate {
            background: #FFD500;
            color: #000;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            letter-spacing: 2px;
            padding: 8px 16px;
            border-radius: 6px;
            border: 2px solid #000;
            text-transform: uppercase;
        }
        /* Dark theme time picker styling */
        input[type="time"] {
            color-scheme: dark;
            color: white;
            background-color: #283039;
            position: relative;
            padding-right: 40px !important;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            background-size: 20px 20px;
        }
        input[type="time"]:hover {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='20' height='20' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2.5' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='12' cy='12' r='10'/%3E%3Cpolyline points='12 6 12 12 16 14'/%3E%3C/svg%3E");
        }
        /* Hide the default calendar picker indicator */
        input[type="time"]::-webkit-calendar-picker-indicator {
            opacity: 0;
            width: 20px;
            height: 20px;
            cursor: pointer;
            position: absolute;
            right: 12px;
            z-index: 1;
        }
        input[type="time"]::-webkit-datetime-edit-text {
            color: white;
        }
        input[type="time"]::-webkit-datetime-edit-hour-field,
        input[type="time"]::-webkit-datetime-edit-minute-field {
            color: white;
        }
        input[type="time"]::-webkit-datetime-edit-ampm-field {
            color: white;
        }
        input[type="time"]::-webkit-datetime-edit-fields-wrapper {
            color: white;
        }
        /* Ensure the picker popup uses dark theme */
        input[type="time"]:focus {
            color-scheme: dark;
        }
        .category-btn {
            transition: all 0.2s ease;
        }
        .category-btn.active {
            border-color: #3b82f6;
            background-color: rgba(59, 130, 246, 0.15);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .badge-awaiting {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }
        .badge-charging {
            background: rgba(16, 185, 129, 0.15);
            color: #34d399;
        }
        .badge-wash {
            background: rgba(249, 115, 22, 0.15);
            color: #fb923c;
        }
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(15, 20, 25, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Loading spinner */
        .spinner-wrapper {
            width: 64px;
            height: 64px;
            position: relative;
        }
        .spinner {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 52px;
            height: 52px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        .spinner-green {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner-green::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(0, 255, 0) 35%, rgb(0, 200, 0));
            box-shadow: 0px -5px 20px 0px rgb(0, 255, 0), 0px 5px 20px 0px rgb(0, 200, 0);
        }
        .spinner-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
            color: white;
            font-size: 1.5rem;
            -webkit-font-smoothing: antialiased;
            text-rendering: optimizeLegibility;
            filter: none !important;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Animated border panels for wait time cards */
        .animated-border-panel {
            position: relative;
            background: #1a1f24;
            border-radius: 1rem;
            padding: 1rem;
            isolation: isolate;
        }
        .animated-border-panel::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 1rem;
            background: #1a1f24;
            z-index: -1;
        }
        
        /* Pending: orange and black */
        .animated-border-pending::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(255, 165, 0), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Processed: green and black */
        .animated-border-processed::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(0, 255, 0), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        @keyframes borderGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        /* Modal: purple and cyan border */
        .animated-border-modal {
            position: relative;
            background: #1a1f24;
            isolation: isolate;
        }
        .animated-border-modal::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 1.5rem;
            background: #1a1f24;
            z-index: -1;
        }
        .animated-border-modal::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 1.5rem;
            background: linear-gradient(45deg, rgb(186, 66, 255), rgb(0, 225, 255), rgb(186, 66, 255));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Animated button borders */
        .animated-button {
            position: relative;
            background: rgb(36, 36, 36);
            border-radius: 0.5rem;
            padding: 0.75rem 1rem;
            isolation: isolate;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 48px;
        }
        .animated-button::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 0.5rem;
            background: rgb(36, 36, 36);
            z-index: -1;
        }
        
        /* Submit: green and black */
        .animated-button-submit::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(0, 255, 0), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
        
        /* Discard: grey and black */
        .animated-button-discard::before {
            content: '';
            position: absolute;
            inset: -2px;
            border-radius: 0.5rem;
            background: linear-gradient(45deg, rgb(0, 0, 0), rgb(128, 128, 128), rgb(0, 0, 0));
            background-size: 200% 200%;
            animation: borderGradient 3s ease infinite;
            z-index: -1;
        }
    </style>
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, where, orderBy, serverTimestamp, doc, getDoc, deleteDoc, updateDoc, Timestamp, onSnapshot } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signOut } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';

        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);

        window.firebaseApp = app;
        window.db = db;
        window.auth = auth;
        window.functions = functions;
        window.firebase = {
            functions,
            httpsCallable
        };
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;
        window.query = query;
        window.where = where;
        window.orderBy = orderBy;
        window.serverTimestamp = serverTimestamp;
        window.doc = doc;
        window.getDoc = getDoc;
        window.deleteDoc = deleteDoc;
        window.updateDoc = updateDoc;
        window.Timestamp = Timestamp;
        window.onSnapshot = onSnapshot;
        window.signOut = signOut;
        window.where = where;
        window.collection = collection;
        window.addDoc = addDoc;
        window.getDocs = getDocs;

        console.log('Firebase initialized for driver wait times.');

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeDriverWaitTimesApp);
        } else {
            initializeDriverWaitTimesApp();
        }
    </script>
</head>
<body class="bg-black text-white min-h-screen">
    <!-- Upload Banner (shown when uploading) -->
    <div id="uploadBanner" class="hidden fixed top-0 left-0 right-0 bg-orange-600 text-white z-[100] shadow-lg">
        <div class="flex items-center justify-center gap-3 px-4 py-2">
            <span class="material-symbols-outlined animate-pulse">cloud_upload</span>
            <div class="flex flex-col items-center flex-1">
                <span id="uploadBannerText" class="font-semibold text-sm">Uploading wait times...</span>
                <span id="uploadBannerSubtitle" class="text-xs opacity-90">Saving to server...</span>
                <!-- Progress bar -->
                <div id="uploadProgressBar" class="w-full max-w-xs mt-2 h-1.5 bg-white bg-opacity-20 rounded-full overflow-hidden">
                    <div id="uploadProgressFill" class="h-full bg-white transition-all duration-300" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
        <div class="text-center">
            <div class="spinner-wrapper mx-auto mb-4">
                <div class="spinner"></div>
                <div class="spinner1"></div>
            </div>
            <p class="text-gray-400">Loading your wait times...</p>
        </div>
    </div>

    <div id="topNav" class="bg-black border-b border-gray-800 sticky top-0 z-50">
        <div class="flex items-center px-4 py-3">
            <button onclick="goToPortal()" class="touch-target">
                <div class="spinner-wrapper">
                    <div class="spinner"></div>
                    <div class="spinner1">
                        <span class="material-symbols-outlined spinner-icon">arrow_back</span>
                    </div>
                </div>
            </button>
            <h1 class="flex-1 text-center text-xl font-semibold">My Wait Times</h1>
            <button onclick="window.location.href='/pages/driver-processed-wait-times.html'" class="touch-target">
                <div class="spinner-wrapper">
                    <div class="spinner-green"></div>
                    <div class="spinner1">
                        <span class="material-symbols-outlined spinner-icon">task_alt</span>
                    </div>
                </div>
            </button>
        </div>
    </div>

    <main class="container max-w-2xl mx-auto px-4 py-6 pb-24 space-y-6">
        <section id="emptyState" class="hidden text-center py-16 fade-in">
            <span class="material-symbols-outlined text-6xl text-gray-600 mb-4">pending_actions</span>
            <h2 class="text-xl font-semibold mb-2">No wait times yet</h2>
            <p class="text-gray-500 max-w-sm mx-auto">Use the button below to log your current waiting period.</p>
        </section>

        <section id="returnedSection" class="hidden space-y-3 fade-in">
            <header class="flex items-center justify-between">
                <h2 class="text-sm font-bold text-red-400 tracking-wide">RETURNED</h2>
            </header>
            <div id="returnedList" class="space-y-3"></div>
        </section>

        <section id="pendingSection" class="hidden space-y-3 fade-in">
            <header class="flex items-center justify-between">
                <h2 class="text-sm font-bold text-orange-400 tracking-wide">PENDING</h2>
            </header>
            <div id="pendingList" class="space-y-3"></div>
        </section>
    </main>

    <button onclick="openWaitTimeModal()" class="fixed bottom-6 right-6 z-40">
        <div class="spinner-wrapper">
            <div class="spinner"></div>
            <div class="spinner1">
                <span class="material-symbols-outlined spinner-icon">add</span>
            </div>
        </div>
    </button>

    <div id="waitTimeModal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 overflow-y-auto">
        <div class="min-h-screen px-4 flex items-end sm:items-center justify-center">
            <div class="bg-[#1a1f24] rounded-t-3xl sm:rounded-3xl w-full max-w-2xl transform transition-all animated-border-modal">
                <div class="sticky top-0 bg-[#1a1f24] border-b border-gray-800 rounded-t-3xl z-10">
                    <div class="flex items-center justify-between px-6 py-4">
                        <h2 class="text-lg font-semibold">Log Wait Time</h2>
                        <button onclick="closeWaitTimeModal()" class="touch-target text-gray-400 hover:text-white transition-colors">
                            <span class="material-symbols-outlined">close</span>
                        </button>
                    </div>
                </div>
                <form id="waitTimeForm" class="p-6 pb-8 space-y-6">
                    <div>
                        <label class="text-sm text-gray-400 mb-2 block">REGISTRATION</label>
                        <input
                            id="regInput"
                            type="text"
                            placeholder="AB12 CDE"
                            maxlength="8"
                            class="w-full bg-[#283039] text-white text-xl font-mono text-center uppercase px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none"
                        >
                    </div>

                    <div>
                        <label class="text-sm text-gray-400 mb-3 block">WAIT TYPE</label>
                        <div class="grid grid-cols-1 sm:grid-cols-3 gap-3">
                            <button type="button" class="category-btn border border-gray-700 rounded-xl p-4 flex flex-col items-center gap-2 hover:border-blue-500 focus:outline-none"
                                data-category="awaiting_release" onclick="selectWaitCategory('awaiting_release')">
                                <span class="text-3xl">üö¶</span>
                                <span class="text-sm font-semibold">Awaiting Release</span>
                            </button>
                            <button type="button" class="category-btn border border-gray-700 rounded-xl p-4 flex flex-col items-center gap-2 hover:border-green-500 focus:outline-none"
                                data-category="charging_vehicle" onclick="selectWaitCategory('charging_vehicle')">
                                <span class="text-3xl">üîå</span>
                                <span class="text-sm font-semibold">Charging Vehicle</span>
                            </button>
                            <button type="button" class="category-btn border border-gray-700 rounded-xl p-4 flex flex-col items-center gap-2 hover:border-orange-500 focus:outline-none"
                                data-category="car_wash" onclick="selectWaitCategory('car_wash')">
                                <span class="text-3xl">üßº</span>
                                <span class="text-sm font-semibold">Car Wash</span>
                            </button>
                        </div>
                        <p id="categoryHint" class="text-xs text-gray-500 mt-2 hidden"></p>
                    </div>

                    <div id="timeSelection" class="hidden">
                        <label class="text-sm text-gray-400 mb-3 block">WAIT TIME</label>
                        <div class="space-y-4">
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label class="text-xs text-gray-400 mb-2 block">Delay Start Time</label>
                                    <input 
                                        type="time" 
                                        id="delayStartTime" 
                                        class="w-full bg-[#283039] border border-gray-700 text-white rounded-lg px-4 py-3 focus:outline-none focus:border-blue-500 text-lg"
                                    />
                                </div>
                                <div>
                                    <label class="text-xs text-gray-400 mb-2 block">Delay End Time</label>
                                    <input 
                                        type="time" 
                                        id="delayEndTime" 
                                        class="w-full bg-[#283039] border border-gray-700 text-white rounded-lg px-4 py-3 focus:outline-none focus:border-blue-500 text-lg"
                                    />
                                </div>
                            </div>
                            <div id="durationDisplay" class="bg-[#1f2730] border border-[#2f3944] rounded-xl px-4 py-3">
                                <p class="text-xs uppercase tracking-wide text-gray-400 mb-1">Total Wait Duration</p>
                                <p id="calculatedDuration" class="text-lg font-semibold text-white">--</p>
                            </div>
                        </div>
                    </div>

                    <div id="notesSection" class="hidden">
                        <label class="text-sm text-gray-400 mb-2 block">NOTES</label>
                        <textarea
                            id="notesInput"
                            placeholder="What are the details of this delay?"
                            rows="3"
                            class="w-full bg-[#283039] text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none resize-none"
                        ></textarea>
                        <p class="text-xs text-gray-500 mt-1">Provide key details so the office can take action quickly.</p>
                    </div>

                    <div class="space-y-3 pt-2">
                        <button id="saveWaitTimeBtn" type="submit" class="w-full animated-button animated-button-submit touch-target disabled:opacity-50 disabled:cursor-not-allowed">
                            <span class="text-white font-semibold">Save Wait Time</span>
                        </button>
                        <button type="button" onclick="closeWaitTimeModal()" class="w-full animated-button animated-button-discard touch-target">
                            <span class="text-white font-semibold">Discard</span>
                        </button>
                    </div>
                </form>
            </div>
    </div>
</div>

    <!-- Appeal Modal for Returned Wait Times -->
    <div id="appealModal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 overflow-y-auto">
        <div class="min-h-screen px-4 flex items-end sm:items-center justify-center">
            <div class="bg-[#1a1f24] rounded-t-3xl sm:rounded-3xl w-full max-w-2xl transform transition-all animated-border-modal">
                <div class="sticky top-0 bg-[#1a1f24] border-b border-gray-800 rounded-t-3xl z-10">
                    <div class="flex items-center justify-between px-6 py-4">
                        <h2 class="text-lg font-semibold">Appeal Returned Wait Time</h2>
                        <button onclick="closeAppealModal()" class="touch-target text-gray-400 hover:text-white transition-colors">
                            <span class="material-symbols-outlined">close</span>
                        </button>
                    </div>
                </div>
                <form id="appealForm" class="p-6 pb-8 space-y-6">
                    <div class="bg-red-500/10 border border-red-500/30 rounded-xl p-4">
                        <p class="text-xs font-semibold text-red-400 mb-2">RETURN REASON</p>
                        <p id="appealReturnReason" class="text-sm text-red-300 leading-relaxed"></p>
                    </div>

                    <div>
                        <label class="text-sm text-gray-400 mb-2 block">ADJUST WAIT DURATION</label>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-xs text-gray-400">Hours</span>
                                    <span class="text-xs text-gray-500">0 - 12</span>
                                </div>
                                <select id="appealHoursSelect" class="w-full bg-[#283039] border border-gray-700 text-white rounded-lg px-3 py-3 focus:outline-none focus:border-blue-500">
                                    <option value="0">0 hours</option>
                                    <option value="1">1 hour</option>
                                    <option value="2">2 hours</option>
                                    <option value="3">3 hours</option>
                                    <option value="4">4 hours</option>
                                    <option value="5">5 hours</option>
                                    <option value="6">6 hours</option>
                                    <option value="7">7 hours</option>
                                    <option value="8">8 hours</option>
                                    <option value="9">9 hours</option>
                                    <option value="10">10 hours</option>
                                    <option value="11">11 hours</option>
                                    <option value="12">12 hours</option>
                                </select>
                            </div>
                            <div>
                                <div class="flex items-center justify-between mb-1">
                                    <span class="text-xs text-gray-400">Minutes</span>
                                    <span class="text-xs text-gray-500">15 min increments</span>
                                </div>
                                <select id="appealMinutesSelect" class="w-full bg-[#283039] border border-gray-700 text-white rounded-lg px-3 py-3 focus:outline-none focus:border-blue-500">
                                    <option value="0">0 minutes</option>
                                    <option value="15">15 minutes</option>
                                    <option value="30">30 minutes</option>
                                    <option value="45">45 minutes</option>
                                </select>
                            </div>
                        </div>
                        <div class="mt-2 bg-[#1f2730] border border-[#2f3944] rounded-xl px-4 py-2">
                            <p class="text-xs uppercase tracking-wide text-gray-400 mb-1">Updated Wait Time</p>
                            <p id="appealDurationDisplay" class="text-lg font-semibold text-white">--</p>
                        </div>
                    </div>

                    <div>
                        <label class="text-sm text-gray-400 mb-2 block">ADDITIONAL NOTES</label>
                        <textarea
                            id="appealNotesInput"
                            placeholder="Explain your appeal and provide any additional context..."
                            rows="4"
                            class="w-full bg-[#283039] text-white px-4 py-3 rounded-lg border border-gray-700 focus:border-blue-500 focus:outline-none resize-none"
                        ></textarea>
                        <p class="text-xs text-gray-500 mt-1">Add details to support your appeal.</p>
                    </div>

                    <div class="space-y-3 pt-2">
                        <button id="submitAppealBtn" type="submit" class="w-full animated-button animated-button-submit touch-target disabled:opacity-50 disabled:cursor-not-allowed">
                            <span class="text-white font-semibold">Resubmit Wait Time</span>
                        </button>
                        <button type="button" onclick="closeAppealModal()" class="w-full animated-button animated-button-discard touch-target">
                            <span class="text-white font-semibold">Back</span>
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <script>
        const THREE_DAYS_MS = 3 * 24 * 60 * 60 * 1000;
        const SEVEN_DAYS_MS = 7 * 24 * 60 * 60 * 1000;
        const WAIT_CATEGORIES = {
            awaiting_release: {
                label: 'Awaiting Release',
                icon: 'üö¶',
                badge: 'badge-awaiting',
                hint: 'Use this when you are waiting for a vehicle to be released.'
            },
            charging_vehicle: {
                label: 'Charging Vehicle',
                icon: 'üîå',
                badge: 'badge-charging',
                hint: 'Use this when the vehicle is currently charging.'
            },
            car_wash: {
                label: 'Car Wash',
                icon: 'üßº',
                badge: 'badge-wash',
                hint: 'Use this when the vehicle is being cleaned.'
            }
        };

        let currentSession = null;
        let currentUser = null;
        let unsubscribeWaitTimes = null;
        let selectedWaitCategory = null;
        let isSaving = false;
        let waitTimeToAppeal = null;
        const WAIT_TIME_SUBMISSION_QUEUE_KEY = 'wait_time_submission_queue_v1';
        let remoteWaitTimes = [];
        let localWaitTimes = [];

        const notifyError = (message, title = 'Error') => uiDialogs.showAlert({ title, message, tone: 'danger' });
        const notifyWarning = (message, title = 'Heads Up') => uiDialogs.showAlert({ title, message, tone: 'warning' });
        const notifySuccess = (message, title = 'Success') => uiDialogs.showAlert({ title, message, tone: 'success' });
        const notifyInfo = (message, title = 'Notice') => uiDialogs.showAlert({ title, message, tone: 'info' });
        const getCurrentOfficeId = () => currentSession?.officeId || currentUser?.officeId || '';

        function loadWaitTimeQueue() {
            try {
                const raw = localStorage.getItem(WAIT_TIME_SUBMISSION_QUEUE_KEY);
                return raw ? JSON.parse(raw) : [];
            } catch (error) {
                console.error('Error reading wait time submission queue:', error);
                return [];
            }
        }

        function saveWaitTimeQueue(queue) {
            try {
                localStorage.setItem(WAIT_TIME_SUBMISSION_QUEUE_KEY, JSON.stringify(queue));
            } catch (error) {
                console.error('Error saving wait time submission queue:', error);
            }
        }

        function convertQueueEntryToLocalWaitTime(entry) {
            const base = entry.data || {};
            return {
                id: entry.localId,
                registration: base.registration,
                category: base.category,
                categoryLabel: base.categoryLabel,
                hours: base.hours,
                minutes: base.minutes,
                totalMinutes: base.totalMinutes,
                notes: base.notes || '',
                driverId: base.driverId,
                driverEmail: base.driverEmail,
                driverName: base.driverName,
                officeId: base.officeId,
                processingStatus: 'pending',
                createdAt: entry.createdAt,
                updatedAt: entry.createdAt,
                isLocal: true
            };
        }

        function loadLocalWaitTimesFromQueue() {
            const queue = loadWaitTimeQueue();
            localWaitTimes = queue.map(convertQueueEntryToLocalWaitTime);
        }

        function addLocalWaitTimeEntry(queueEntry) {
            const localEntry = convertQueueEntryToLocalWaitTime(queueEntry);
            localWaitTimes.push(localEntry);
        }

        function removeLocalWaitTime(localId) {
            const index = localWaitTimes.findIndex(item => item.id === localId);
            if (index >= 0) {
                localWaitTimes.splice(index, 1);
            }
        }

        function queueWaitTimeForSync(baseData, options = {}) {
            if (!currentUser) return;

            const localId = `local-wait-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
            const createdAt = Date.now();
            const entry = {
                localId,
                createdAt,
                data: {
                    ...baseData,
                    driverId: currentUser.uid,
                    driverEmail: currentUser.email || '',
                    driverName: baseData.driverName,
                    officeId: currentUser.officeId || ''
                }
            };

            const queue = loadWaitTimeQueue();
            queue.push(entry);
            saveWaitTimeQueue(queue);
            addLocalWaitTimeEntry(entry);
            renderWaitTimes();

            if (!options?.silent) {
                notifyInfo('Saved offline. We will sync this wait time when you are back online.', 'Queued Offline');
            }

            if (navigator.onLine) {
                syncWaitTimeQueue({ showToast: false });
            }
        }

        async function syncWaitTimeQueue(options = {}) {
            if (!navigator.onLine || !currentUser) {
                return;
            }

            const queue = loadWaitTimeQueue();
            if (!queue.length) {
                return;
            }

            const remaining = [];
            let processedCount = 0;
            const officeId = getCurrentOfficeId();
            if (!officeId) {
                console.warn('Missing office context while syncing wait time queue.');
                return;
            }

            for (const entry of queue) {
                try {
                    const data = entry.data || {};
                    
                    // Check for unique registration before syncing
                    let uniqueReg = data.registration;
                    try {
                        uniqueReg = await getUniqueWaitTimeReg(data.registration);
                    } catch (error) {
                        console.error('Error checking for duplicate registration in queue sync:', error);
                        // Continue with original registration if check fails
                    }

                    const firestoreData = {
                        driverId: currentUser.uid,
                        driverEmail: data.driverEmail || currentUser.email || '',
                        driverName: data.driverName ||
                            currentUser.name ||
                            `${currentUser.firstName || ''} ${currentUser.lastName || ''}`.trim() ||
                            'Driver',
                        officeId: data.officeId || officeId,
                        registration: uniqueReg,
                        category: data.category,
                        categoryLabel: data.categoryLabel,
                        hours: data.hours,
                        minutes: data.minutes,
                        totalMinutes: data.totalMinutes,
                        delayStartTime: data.delayStartTime || '',
                        delayEndTime: data.delayEndTime || '',
                        notes: data.notes || '',
                        processingStatus: 'pending',
                        createdAt: entry.createdAt ?
                            window.Timestamp.fromMillis(entry.createdAt) :
                            window.serverTimestamp(),
                        updatedAt: window.serverTimestamp()
                    };

                    await window.addDoc(window.collection(window.db, 'waitTimes'), firestoreData);
                    removeLocalWaitTime(entry.localId);
                    processedCount += 1;
                } catch (error) {
                    console.error('Error syncing queued wait time:', error);
                    remaining.push(entry);
                }
            }

            saveWaitTimeQueue(remaining);
            if (processedCount > 0) {
                renderWaitTimes();
                if (options?.showToast) {
                    notifySuccess(`${processedCount} wait time${processedCount === 1 ? '' : 's'} synced successfully.`, 'Back Online');
                }
            }
        }

        async function backfillWaitTimesOffice() {
            const officeId = getCurrentOfficeId();
            if (!officeId) return;

            try {
                const legacyQuery = window.query(
                    window.collection(window.db, "waitTimes"),
                    window.where("driverId", "==", currentUser.uid)
                );
                const snapshot = await window.getDocs(legacyQuery);
                const updates = snapshot.docs
                    .filter((doc) => {
                        const data = doc.data();
                        return !data.officeId;
                    })
                    .map((doc) => window.updateDoc(doc.ref, {officeId}));
                if (updates.length > 0) {
                    await Promise.allSettled(updates);
                }
            } catch (error) {
                console.warn("Failed to backfill wait time office IDs:", error);
            }
        }
        window.backfillWaitTimesOffice = backfillWaitTimesOffice;

        async function initializeDriverWaitTimesApp() {
            console.log('Initializing driver wait times page...');

            try {
                const session = await window.sotoSession.bootstrap(['driver']);
                if (!session) {
                    window.location.href = '/pages/soto-routes-login.html';
                    return;
                }

                currentSession = session;

                const userDoc = await window.getDoc(window.doc(window.db, 'users', session.uid));
                    if (!userDoc.exists()) {
                        window.location.href = '/pages/soto-routes-login.html';
                        return;
                    }

                currentUser = { uid: session.uid, ...session, ...userDoc.data() };
                    if (currentUser.role !== 'driver') {
                        notifyWarning('This page is for drivers only.', 'Access Denied');
                        window.location.href = '/pages/soto-lp.html';
                        return;
                    }

                    loadLocalWaitTimesFromQueue();
                    renderWaitTimes();
                await syncWaitTimeQueue({ showToast: false });
                    window.addEventListener('online', () => syncWaitTimeQueue({ showToast: true }));

                await backfillWaitTimesOffice();

                    document.getElementById('loadingOverlay').style.display = 'none';
                    attachFormInteractions();
                    startWaitTimesListener();
                    
                    // Register Service Worker for background uploads
                    if ('serviceWorker' in navigator) {
                        try {
                            const registration = await navigator.serviceWorker.register('/sw.js');
                            console.log('[SW] Service Worker registered:', registration.scope);
                            
                            // Check for updates periodically
                            setInterval(() => {
                                registration.update();
                            }, 60000); // Check every minute
                        } catch (error) {
                            console.warn('[SW] Service Worker registration failed:', error);
                        }
                    }
                    
                    // Initialize upload queue monitoring
                    if (window.waitTimeUploadQueue) {
                        await window.waitTimeUploadQueue.updateGlobalUploadStatus();
                        
                        // Trigger Service Worker to process any pending uploads
                        if (navigator.onLine) {
                            try {
                                await window.waitTimeUploadQueue.getAuthTokenAndProcessQueue();
                            } catch (error) {
                                console.warn('[Wait Times] Failed to trigger upload processing:', error);
                            }
                        }
                        
                        // Set up periodic status updates while uploading
                        if (window.uploadStatusCheckInterval) {
                            clearInterval(window.uploadStatusCheckInterval);
                        }
                        window.uploadStatusCheckInterval = setInterval(async () => {
                            if (window.waitTimeUploadQueue && typeof window.waitTimeUploadQueue.updateGlobalUploadStatus === 'function') {
                                await window.waitTimeUploadQueue.updateGlobalUploadStatus();
                            }
                            // Refresh wait times to update greyed out status
                            if (typeof renderWaitTimes === 'function') {
                                renderWaitTimes();
                            }
                        }, 3000); // Check every 3 seconds
                    }
                    
                    // Listen for Service Worker messages
                    if ('serviceWorker' in navigator && navigator.serviceWorker) {
                        navigator.serviceWorker.addEventListener('message', async (event) => {
                            const { type } = event.data || {};
                            if (type === 'upload-status-changed') {
                                // Service Worker updated upload status, check again
                                if (window.waitTimeUploadQueue && typeof window.waitTimeUploadQueue.updateGlobalUploadStatus === 'function') {
                                    await window.waitTimeUploadQueue.updateGlobalUploadStatus();
                                }
                                // Refresh wait times to update greyed out status
                                if (typeof renderWaitTimes === 'function') {
                                    renderWaitTimes();
                                }
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading driver profile:', error);
                    notifyError('Unable to load your profile. Please try again.');
                }
        }
        
        // Clean up interval when page unloads
        window.addEventListener('beforeunload', () => {
            if (window.uploadStatusCheckInterval) {
                clearInterval(window.uploadStatusCheckInterval);
            }
        });

        function attachFormInteractions() {
            const form = document.getElementById('waitTimeForm');
            form.addEventListener('submit', (event) => {
                event.preventDefault();
                saveWaitTime();
            });

            document.getElementById('regInput').addEventListener('input', (event) => {
                const cleaned = event.target.value.toUpperCase().replace(/[^A-Z0-9 ]/g, '');
                event.target.value = cleaned;
                validateWaitTimeForm();
            });

            document.getElementById('delayStartTime').addEventListener('change', () => {
                calculateDuration();
                validateWaitTimeForm();
            });
            document.getElementById('delayEndTime').addEventListener('change', () => {
                calculateDuration();
                validateWaitTimeForm();
            });
            document.getElementById('notesInput').addEventListener('input', validateWaitTimeForm);
        }

        function startWaitTimesListener() {
            if (unsubscribeWaitTimes) {
                unsubscribeWaitTimes();
            }

            const officeId = getCurrentOfficeId();
            if (!officeId) {
                console.warn('No office context for wait time listener.');
                return;
            }

            const waitTimesQuery = window.query(
                window.collection(window.db, 'waitTimes'),
                window.where('driverId', '==', currentUser.uid),
                window.where('officeId', '==', officeId)
            );

            unsubscribeWaitTimes = window.onSnapshot(waitTimesQuery, (snapshot) => {
                remoteWaitTimes = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                snapshot.docs.forEach(async (docSnap) => {
                    const data = docSnap.data();
                    if (!data.officeId) {
                        try {
                            await window.updateDoc(docSnap.ref, { officeId });
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for wait time ${docSnap.id}:`, error);
                        }
                    }
                });
                renderWaitTimes();
            }, (error) => {
                console.error('Error listening for wait times:', error);
                if (navigator.onLine) {
                    notifyError('Could not load wait times.');
                }
            });
        }

        function renderWaitTimes() {
            const waitTimes = [...localWaitTimes, ...remoteWaitTimes];
            waitTimes.sort((a, b) => {
                const aTime = toDate(a.createdAt)?.getTime() || 0;
                const bTime = toDate(b.createdAt)?.getTime() || 0;
                return bTime - aTime;
            });
            const returned = waitTimes.filter(item => (item.processingStatus || 'pending') === 'returned');
            const pending = waitTimes.filter(item => {
                const status = item.processingStatus || 'pending';
                return status !== 'processed' && status !== 'returned';
            });

            document.getElementById('returnedSection').classList.toggle('hidden', returned.length === 0);
            document.getElementById('pendingSection').classList.toggle('hidden', pending.length === 0);
            document.getElementById('emptyState').classList.toggle('hidden', (returned.length > 0 || pending.length > 0));

            renderWaitTimeList(returned, 'returnedList', { allowDelete: false, showProcessedMeta: false, isReturned: true });
            renderWaitTimeList(pending, 'pendingList', { allowDelete: false, showProcessedMeta: false });
        }

        function renderWaitTimeList(items, containerId, options = {}) {
            const container = document.getElementById(containerId);
            if (!items.length) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = items.map(item => renderWaitTimeCard(item, options)).join('');
        }

        function renderWaitTimeCard(item, options) {
            const category = WAIT_CATEGORIES[item.category] || {
                label: 'Other',
                icon: '‚è±Ô∏è',
                badge: 'badge-awaiting'
            };
            const totalMinutes = typeof item.totalMinutes === 'number'
                ? item.totalMinutes
                : ((item.hours || 0) * 60) + (item.minutes || 0);
            const createdAt = toDate(item.createdAt);
            const processedAt = toDate(item.processedAt);
            const submittedText = createdAt ? `Submitted ${formatRelativeTime(createdAt)}` : 'Submission time unavailable';
            const processedText = processedAt ? `Processed ${formatRelativeTime(processedAt)}` : '';
            const processedBy = item.processedByName || item.processedBy || '';
            const processedMeta = options.showProcessedMeta && processedText ? `
                <div class="flex items-center gap-2 text-sm text-green-400">
                    <span class="material-symbols-outlined text-base">task_alt</span>
                    <span>${processedText}</span>
                </div>
                ${processedBy ? `<p class="text-xs text-gray-500">Processed by ${escapeHtml(processedBy)}</p>` : ''}
            ` : '';

            const isReturned = options.isReturned || (item.processingStatus || 'pending') === 'returned';
            const isPending = (item.processingStatus || 'pending') !== 'processed' && !isReturned;
            const isProcessed = (item.processingStatus || 'pending') === 'processed';
            
            // Check if wait time is currently uploading
            // For now, we'll use isLocal as indicator (local wait times are being uploaded)
            // In the future, we could check the waitTimeUploadQueue to see if this specific ID is uploading
            const isUploading = item.isLocal && isPending;
            
            const greyedOut = isUploading ? 'opacity-50 cursor-not-allowed' : '';
            const uploadIndicator = isUploading ? `
                <div class="mt-2 text-orange-400 text-xs flex items-center gap-1">
                    <span class="material-symbols-outlined text-sm animate-pulse">cloud_upload</span>
                    Uploading...
                </div>
            ` : '';
            
            let borderClass = 'animated-border-panel animated-border-pending';
            if (isReturned) {
                borderClass = 'animated-border-panel';
            } else if (isProcessed) {
                borderClass = 'animated-border-panel animated-border-processed';
            }

            // Check if this wait time has been returned 3 times (cannot appeal)
            const hasThirdReturn = !!item.returnNotes3;
            const returnedActions = isReturned ? `
                <div class="mt-4 flex flex-col sm:flex-row gap-3">
                    ${hasThirdReturn ? `
                    <button disabled class="flex-1 animated-button animated-button-submit touch-target opacity-50 cursor-not-allowed">
                        <span class="text-white font-semibold">Cannot Appeal</span>
                    </button>
                    ` : `
                    <button onclick="openAppealModal('${item.id}')" class="flex-1 animated-button animated-button-submit touch-target">
                        <span class="text-white font-semibold">Appeal</span>
                    </button>
                    `}
                    <button onclick="discardReturnedWaitTime('${item.id}')" class="flex-1 animated-button animated-button-discard touch-target">
                        <span class="text-white font-semibold">Discard</span>
                    </button>
                </div>
                ${hasThirdReturn ? `
                <div class="mt-3 bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-sm text-red-200">
                    <p class="text-xs font-semibold text-red-400 mb-1">‚ö†Ô∏è Maximum Appeals Reached</p>
                    <p class="leading-relaxed">You have appealed too many times. Please call your office to discuss this wait time further. Please discard this wait time submission.</p>
                </div>
                ` : ''}
            ` : '';
            
            return `
                <article class="${borderClass} ${greyedOut}" ${isReturned ? 'style="border: 2px solid rgba(239, 68, 68, 0.5); background: rgba(239, 68, 68, 0.05);"' : ''}>
                    <div class="flex items-start justify-between gap-4">
                        <div class="flex flex-wrap items-center gap-3">
                            <span class="license-plate">${escapeHtml(item.registration || 'UNKNOWN')}</span>
                            <span class="inline-flex items-center gap-1 px-3 py-1 rounded-full text-xs font-semibold ${category.badge}">
                                <span>${category.icon}</span>
                                ${category.label}
                            </span>
                            ${item.isLocal ? `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-semibold text-orange-300 bg-orange-500/10">
                                <span class="material-symbols-outlined text-sm">cloud_off</span>Awaiting Sync
                            </span>` : ''}
                            ${isReturned ? `<span class="inline-flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-semibold text-red-300 bg-red-500/10">
                                <span class="material-symbols-outlined text-sm">undo</span>Returned
                            </span>` : ''}
                        </div>
                    </div>
                    <div class="mt-4 flex flex-wrap items-center gap-4 text-sm text-gray-300">
                        <div class="flex items-center gap-1">
                            <span class="material-symbols-outlined text-base text-blue-400">schedule</span>
                            <span>${formatDuration(totalMinutes)}</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="material-symbols-outlined text-base text-gray-400">today</span>
                            <span>${submittedText}</span>
                        </div>
                    </div>
                    ${item.notes ? `
                    <div class="mt-4 bg-[#1f2730] border border-[#2f3944] rounded-xl p-3 text-sm text-gray-200">
                        <p class="text-xs text-gray-400 mb-1">ORIGINAL NOTES</p>
                        <p class="leading-relaxed">${escapeHtml(item.notes)}</p>
                    </div>
                    ` : ''}
                    ${item.returnNotes1 ? `
                    <div class="mt-4 bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-sm text-red-200">
                        <p class="text-xs font-semibold text-red-400 mb-1">OFFICE RETURN MESSAGE 1</p>
                        <p class="leading-relaxed">${escapeHtml(item.returnNotes1)}</p>
                    </div>
                    ` : item.returnNotes ? `
                    <div class="mt-4 bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-sm text-red-200">
                        <p class="text-xs font-semibold text-red-400 mb-1">OFFICE RETURN MESSAGE 1</p>
                        <p class="leading-relaxed">${escapeHtml(item.returnNotes)}</p>
                    </div>
                    ` : ''}
                    ${item.appealNotes1 ? `
                    <div class="mt-4 bg-blue-500/10 border border-blue-500/30 rounded-xl p-3 text-sm text-blue-200">
                        <p class="text-xs font-semibold text-blue-400 mb-1">YOUR APPEAL MESSAGE 1</p>
                        <p class="leading-relaxed">${escapeHtml(item.appealNotes1)}</p>
                    </div>
                    ` : ''}
                    ${item.returnNotes2 ? `
                    <div class="mt-4 bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-sm text-red-200">
                        <p class="text-xs font-semibold text-red-400 mb-1">OFFICE RETURN MESSAGE 2</p>
                        <p class="leading-relaxed">${escapeHtml(item.returnNotes2)}</p>
                    </div>
                    ` : ''}
                    ${item.appealNotes2 ? `
                    <div class="mt-4 bg-blue-500/10 border border-blue-500/30 rounded-xl p-3 text-sm text-blue-200">
                        <p class="text-xs font-semibold text-blue-400 mb-1">YOUR APPEAL MESSAGE 2</p>
                        <p class="leading-relaxed">${escapeHtml(item.appealNotes2)}</p>
                    </div>
                    ` : ''}
                    ${item.returnNotes3 ? `
                    <div class="mt-4 bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-sm text-red-200">
                        <p class="text-xs font-semibold text-red-400 mb-1">OFFICE RETURN MESSAGE 3</p>
                        <p class="leading-relaxed">${escapeHtml(item.returnNotes3)}</p>
                    </div>
                    ` : ''}
                    ${item.originalTotalMinutes && item.originalTotalMinutes !== totalMinutes ? `
                    <div class="mt-3 bg-[#1f2730] border border-[#2f3944] rounded-xl p-3 text-sm text-gray-200">
                        <p class="text-xs text-gray-400 uppercase tracking-wide mb-1">Adjustment Summary</p>
                        <div class="flex flex-wrap gap-4">
                            <span>Original: <span class="font-semibold">${formatDuration(item.originalTotalMinutes)}</span></span>
                            <span>Updated: <span class="font-semibold">${formatDuration(totalMinutes)}</span></span>
                        </div>
                    </div>
                    ` : ''}
                    ${options.showProcessedMeta && item.officeNotes ? `
                    <div class="mt-3 bg-[#1f2730] border border-[#2f3944] rounded-xl p-3 text-sm text-gray-200">
                        <p class="text-xs font-semibold text-gray-400 mb-1">OFFICE NOTES</p>
                        <p class="leading-relaxed">${escapeHtml(item.officeNotes)}</p>
                    </div>
                    ` : ''}
                    ${processedMeta ? `<div class="mt-3">${processedMeta}</div>` : ''}
                    ${uploadIndicator}
                    ${returnedActions}
                </article>
            `;
        }

        function selectWaitCategory(category) {
            selectedWaitCategory = category;
            document.querySelectorAll('.category-btn').forEach(btn => {
                if (btn.dataset.category === category) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            const hintEl = document.getElementById('categoryHint');
            const categoryInfo = WAIT_CATEGORIES[category];
            if (categoryInfo && categoryInfo.hint) {
                hintEl.textContent = categoryInfo.hint;
                hintEl.classList.remove('hidden');
            } else {
                hintEl.classList.add('hidden');
            }

            document.getElementById('timeSelection').classList.remove('hidden');
            document.getElementById('notesSection').classList.remove('hidden');
            validateWaitTimeForm();
        }

        async function saveWaitTime() {
            if (isSaving) {
                return;
            }

            const regInput = document.getElementById('regInput');
            const delayStartTime = document.getElementById('delayStartTime').value;
            const delayEndTime = document.getElementById('delayEndTime').value;
            const notesInput = document.getElementById('notesInput');
            const saveBtn = document.getElementById('saveWaitTimeBtn');

            let registration = normalizeRegistration(regInput.value);
            
            // Validate times
            if (!delayStartTime || !delayEndTime) {
                notifyWarning('Please select both delay start and end times.');
                return;
            }
            
            // Calculate duration from times
            const duration = calculateDuration();
            const hours = duration.hours;
            const minutes = duration.minutes;
            const totalMinutes = duration.totalMinutes;
            const notes = (notesInput.value || '').trim();

            if (!registration) {
                notifyWarning('Enter the vehicle registration.');
                regInput.focus();
                return;
            }

            if (!selectedWaitCategory) {
                notifyWarning('Select a wait type before saving.');
                return;
            }

            if (totalMinutes <= 0) {
                notifyWarning('Wait time must be at least 15 minutes.');
                return;
            }

            if (!notes) {
                notifyWarning('Add details explaining the wait time.');
                notesInput.focus();
                return;
            }

            // Get unique registration (adds ! if duplicate)
            try {
                const originalReg = normalizeRegForComparison(registration);
                registration = await getUniqueWaitTimeReg(registration);
                // Update the input field to show the modified registration if it changed
                const newRegNormalized = normalizeRegForComparison(registration);
                if (originalReg !== newRegNormalized) {
                    // Format the registration back with spaces for display
                    // Handle cases like "AB12!", "AB12!2", etc.
                    const match = newRegNormalized.match(/^([A-Z0-9]{0,6})([!][0-9]*)?$/);
                    if (match) {
                        const baseReg = match[1];
                        const suffix = match[2] || '';
                        let formatted = baseReg;
                        if (baseReg.length >= 2) {
                            formatted = baseReg.slice(0, 2);
                            if (baseReg.length > 2) {
                                formatted += ' ' + baseReg.slice(2);
                            }
                        }
                        regInput.value = formatted + suffix;
                    } else {
                        regInput.value = newRegNormalized.replace(/(.{1,2})(.{1,2})(.{0,4})/, '$1 $2 $3').trim();
                    }
                }
            } catch (error) {
                console.error('Error checking for duplicate registration:', error);
                // Continue with original registration if check fails
            }

            const driverName = currentUser?.name ||
                `${currentUser?.firstName || ''} ${currentUser?.lastName || ''}`.trim() ||
                'Driver';

            const baseData = {
                driverName,
                registration,
                category: selectedWaitCategory,
                categoryLabel: WAIT_CATEGORIES[selectedWaitCategory]?.label || selectedWaitCategory,
                hours,
                minutes,
                totalMinutes,
                delayStartTime,
                delayEndTime,
                notes
            };

            // Create timestamp for IndexedDB (actual number)
            const createdAtTimestamp = Date.now();
            
            const waitTimeData = {
                driverId: currentUser.uid,
                driverEmail: currentUser.email || '',
                driverName,
                officeId: currentUser.officeId || '',
                registration,
                category: selectedWaitCategory,
                categoryLabel: WAIT_CATEGORIES[selectedWaitCategory]?.label || selectedWaitCategory,
                hours,
                minutes,
                totalMinutes,
                delayStartTime,
                delayEndTime,
                notes,
                processingStatus: 'pending',
                createdAt: createdAtTimestamp, // Use actual timestamp for IndexedDB
                updatedAt: createdAtTimestamp
            };
            
            // For Firestore, use serverTimestamp() if creating directly
            const firestoreWaitTimeData = {
                ...waitTimeData,
                createdAt: window.serverTimestamp(),
                updatedAt: window.serverTimestamp()
            };

            isSaving = true;
            saveBtn.disabled = true;
            const saveBtnSpan = saveBtn.querySelector('span');
            if (saveBtnSpan) {
                saveBtnSpan.textContent = 'Saving...';
            } else {
                saveBtn.textContent = 'Saving...';
            }

            try {
                // WRITE-FIRST APPROACH: Save to IndexedDB immediately, then to Firestore
                // Service Worker will handle upload if offline
                
                // Step 1: Create wait time document in Firestore immediately (if online)
                let waitTimeDocId = null;
                if (navigator.onLine) {
                    try {
                        const waitTimeDocRef = await window.addDoc(window.collection(window.db, 'waitTimes'), firestoreWaitTimeData);
                        waitTimeDocId = waitTimeDocRef.id;
                        console.log('[saveWaitTime] Created wait time doc:', waitTimeDocId);
                    } catch (firestoreError) {
                        console.error('[saveWaitTime] Firestore error, will queue:', firestoreError);
                        // Continue to queue if Firestore fails
                    }
                }

                // Step 2: Queue for upload (Service Worker will handle if offline or if Firestore failed)
                if (window.waitTimeUploadQueue) {
                    try {
                        await window.waitTimeUploadQueue.enqueueWaitTimeUpload(waitTimeData, waitTimeDocId);
                        console.log('[saveWaitTime] Queued wait time for upload');
                    } catch (queueError) {
                        console.error('[saveWaitTime] Failed to queue upload:', queueError);
                    }
                }

                // Step 3: Update upload status
                if (window.waitTimeUploadQueue && typeof window.waitTimeUploadQueue.updateGlobalUploadStatus === 'function') {
                    await window.waitTimeUploadQueue.updateGlobalUploadStatus();
                }

                // Step 4: Refresh wait times list to show new entry (greyed out if uploading)
                if (typeof renderWaitTimes === 'function') {
                    renderWaitTimes();
                }

                // No success message - orange banner shows upload status
                closeWaitTimeModal();
            } catch (error) {
                console.error('Error saving wait time:', error);
                notifyWarning('Error saving wait time. Please try again.', 'Error');
            } finally {
                isSaving = false;
                saveBtn.disabled = false;
                const saveBtnSpan = saveBtn.querySelector('span');
                if (saveBtnSpan) {
                    saveBtnSpan.textContent = 'Save Wait Time';
                } else {
                    saveBtn.textContent = 'Save Wait Time';
                }
                validateWaitTimeForm();
            }
        }

        function openWaitTimeModal() {
            resetWaitTimeForm();
            document.getElementById('waitTimeModal').classList.remove('hidden');
            setTimeout(() => document.getElementById('regInput').focus(), 50);
        }

        function closeWaitTimeModal() {
            document.getElementById('waitTimeModal').classList.add('hidden');
            resetWaitTimeForm();
        }

        function resetWaitTimeForm() {
            const form = document.getElementById('waitTimeForm');
            form.reset();
            selectedWaitCategory = null;
            document.getElementById('categoryHint').classList.add('hidden');
            document.getElementById('timeSelection').classList.add('hidden');
            document.getElementById('notesSection').classList.add('hidden');
            document.getElementById('notesInput').value = '';
            document.getElementById('delayStartTime').value = '';
            document.getElementById('delayEndTime').value = '';
            document.getElementById('calculatedDuration').textContent = '--';
            document.querySelectorAll('.category-btn').forEach(btn => btn.classList.remove('active'));
            isSaving = false;
            validateWaitTimeForm();
        }

        function validateWaitTimeForm() {
            const reg = normalizeRegistration(document.getElementById('regInput').value);
            const delayStartTime = document.getElementById('delayStartTime').value;
            const delayEndTime = document.getElementById('delayEndTime').value;
            const notes = (document.getElementById('notesInput').value || '').trim();
            const saveBtn = document.getElementById('saveWaitTimeBtn');
            
            // Calculate duration if both times are set
            let totalMinutes = 0;
            if (delayStartTime && delayEndTime) {
                const duration = calculateDuration();
                totalMinutes = duration.totalMinutes;
            }

            const isValid = Boolean(reg) && Boolean(selectedWaitCategory) && Boolean(delayStartTime) && Boolean(delayEndTime) && totalMinutes >= 15 && Boolean(notes) && !isSaving;
            saveBtn.disabled = !isValid;
        }

        function calculateDuration() {
            const startTime = document.getElementById('delayStartTime').value;
            const endTime = document.getElementById('delayEndTime').value;
            const durationDisplay = document.getElementById('calculatedDuration');
            
            if (!startTime || !endTime) {
                durationDisplay.textContent = '--';
                return { hours: 0, minutes: 0, totalMinutes: 0 };
            }
            
            // Parse times
            const [startHours, startMinutes] = startTime.split(':').map(Number);
            const [endHours, endMinutes] = endTime.split(':').map(Number);
            
            // Convert to minutes since midnight
            const startTotalMinutes = startHours * 60 + startMinutes;
            const endTotalMinutes = endHours * 60 + endMinutes;
            
            // Calculate difference (handle case where end time is next day)
            let diffMinutes = endTotalMinutes - startTotalMinutes;
            if (diffMinutes < 0) {
                // End time is next day (e.g., start 23:00, end 01:00)
                diffMinutes = (24 * 60) - startTotalMinutes + endTotalMinutes;
            }
            
            const hours = Math.floor(diffMinutes / 60);
            const minutes = diffMinutes % 60;
            
            // Update display
            durationDisplay.textContent = formatDuration(diffMinutes);
            
            return { hours, minutes, totalMinutes: diffMinutes };
        }

        function formatDuration(totalMinutes) {
            const minutes = Math.max(totalMinutes || 0, 0);
            const hrs = Math.floor(minutes / 60);
            const mins = minutes % 60;
            const parts = [];
            if (hrs > 0) {
                parts.push(`${hrs}h`);
            }
            if (mins > 0) {
                parts.push(`${mins}m`);
            }
            return parts.length ? parts.join(' ') : '0m';
        }

        function formatRelativeTime(date) {
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();
            const diffMinutes = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMinutes < 1) return 'Just now';
            if (diffMinutes < 60) return `${diffMinutes} minute${diffMinutes === 1 ? '' : 's'} ago`;
            if (diffHours < 24) return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
            if (diffDays < 7) return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
            return date.toLocaleString();
        }

        function toDate(value) {
            if (!value) return null;
            if (value instanceof Date) return value;
            if (value.toDate) return value.toDate();
            if (typeof value === 'number') return new Date(value);
            if (typeof value === 'string') return new Date(value);
            return null;
        }

        function normalizeRegistration(registration) {
            return (registration || '')
                .toUpperCase()
                .replace(/[^A-Z0-9 ]/g, '')
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Helper function to normalize reg (remove spaces only, keep ! and numbers for suffix matching)
        // This matches the expenses logic - only removes spaces, preserves ! and numbers
        function normalizeRegForComparison(reg) {
            return (reg || '').toUpperCase().replace(/\s+/g, '');
        }

        // Helper function to extract base reg (remove ! suffix for comparison)
        function getBaseReg(reg) {
            // Remove trailing exclamation marks (e.g., "REG!!!" -> "REG", "REG!" -> "REG")
            const normalized = normalizeRegForComparison(reg);
            return normalized.replace(/!+$/, '');
        }

        // Helper function to check if a registration exists and add ! suffix if needed
        async function getUniqueWaitTimeReg(baseReg) {
            // Normalize base reg (remove spaces only)
            const normalizedBaseReg = normalizeRegForComparison(baseReg);
            const baseRegOnly = getBaseReg(baseReg);
            
            if (!currentUser || !currentUser.officeId) {
                return normalizedBaseReg;
            }

            // Check if any wait time with this officeId has this exact reg (pending or processed within 7 days)
            const waitTimesQuery = window.query(
                window.collection(window.db, 'waitTimes'),
                window.where('officeId', '==', currentUser.officeId)
            );
            
            let waitTimesSnapshot;
            try {
                waitTimesSnapshot = await window.getDocs(waitTimesQuery);
            } catch (error) {
                console.error('Error checking for duplicate wait times:', error);
                return normalizedBaseReg; // Return as-is if we can't check
            }

            const now = Date.now();
            // Store full registrations (with ! suffix if present) for exact matching
            const existingRegs = new Set();
            
            waitTimesSnapshot.docs.forEach(doc => {
                const data = doc.data();
                if (data.registration) {
                    // Normalize the stored registration (keep full reg with ! suffix for comparison)
                    const reg = normalizeRegForComparison(data.registration);
                    
                    // Check if this wait time is pending or processed within 7 days
                    const status = data.processingStatus || 'pending';
                    const isRelevant = status !== 'processed' || (() => {
                        const processedAt = toDate(data.processedAt);
                        if (!processedAt) return false;
                        return now - processedAt.getTime() <= SEVEN_DAYS_MS;
                    })();
                    
                    if (isRelevant) {
                        // Store the full normalized reg (including ! suffix if present)
                        existingRegs.add(reg);
                    }
                }
            });

            // Check if the base reg (without suffix) exists
            const baseRegExists = Array.from(existingRegs).some(reg => getBaseReg(reg) === baseRegOnly);
            
            // If the exact base reg doesn't exist, return it
            if (!baseRegExists) {
                return normalizedBaseReg;
            }

            // Otherwise, add ! (and incrementing exclamation marks if needed)
            // Format: REG, REG!, REG!!, REG!!!, etc.
            let exclamationCount = 1;
            while (true) {
                const suffix = '!'.repeat(exclamationCount);
                const newReg = `${baseRegOnly}${suffix}`;
                const normalizedNewReg = normalizeRegForComparison(newReg);
                
                // Check if this exact reg (with suffix) already exists
                if (!existingRegs.has(normalizedNewReg)) {
                    return newReg;
                }
                exclamationCount++;
                
                // Safety limit to prevent infinite loop
                if (exclamationCount > 100) {
                    console.error('Too many duplicate registrations, using timestamp suffix');
                    return `${baseRegOnly}!${Date.now()}`;
                }
            }
        }

        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            return text
                .toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        async function logout() {
            try {
                await window.signOut(window.auth);
            } catch (error) {
                console.error('Error during sign out:', error);
            } finally {
                window.sotoSession?.clearSession();
                window.location.href = '/pages/soto-routes-login.html';
            }
        }

        function goToPortal() {
            window.location.href = '/pages/driver-portal.html';
        }

        // Appeal modal functions
        async function openAppealModal(waitTimeId) {
            const allWaitTimes = [...localWaitTimes, ...remoteWaitTimes];
            waitTimeToAppeal = allWaitTimes.find(item => item.id === waitTimeId);
            if (!waitTimeToAppeal) {
                notifyWarning('Wait time not found.');
                return;
            }

            // Check if this wait time has been returned 3 times (cannot appeal)
            if (waitTimeToAppeal.returnNotes3) {
                // Get office name
                let officeName = 'your office';
                try {
                    const officeId = waitTimeToAppeal.officeId || currentUser?.officeId;
                    if (officeId) {
                        const officeDoc = await window.getDoc(window.doc(window.db, 'offices', officeId));
                        if (officeDoc.exists()) {
                            const officeData = officeDoc.data();
                            officeName = officeData.name || 'your office';
                        }
                    }
                } catch (error) {
                    console.warn('Error fetching office name:', error);
                }
                
                notifyError(
                    `Unfortunately, you have appealed too many times. Please call ${officeName} to discuss this wait time further. Please discard this wait time submission.`,
                    'Maximum Appeals Reached'
                );
                return;
            }

            // Set return reason (show the most recent return message)
            const returnReason = waitTimeToAppeal.returnNotes3 || waitTimeToAppeal.returnNotes2 || waitTimeToAppeal.returnNotes1 || waitTimeToAppeal.returnNotes || 'No reason provided.';
            document.getElementById('appealReturnReason').textContent = returnReason;

            // Set current time values
            const currentHours = waitTimeToAppeal.hours || 0;
            const currentMinutes = waitTimeToAppeal.minutes || 0;
            document.getElementById('appealHoursSelect').value = String(currentHours);
            document.getElementById('appealMinutesSelect').value = String(currentMinutes);
            updateAppealDurationDisplay();

            // Clear notes
            document.getElementById('appealNotesInput').value = '';

            document.getElementById('appealModal').classList.remove('hidden');

            // Update duration display immediately
            updateAppealDurationDisplay();
        }

        function closeAppealModal() {
            document.getElementById('appealModal').classList.add('hidden');
            waitTimeToAppeal = null;
            document.getElementById('appealNotesInput').value = '';
        }

        function updateAppealDurationDisplay() {
            const hours = parseInt(document.getElementById('appealHoursSelect').value, 10) || 0;
            const minutes = parseInt(document.getElementById('appealMinutesSelect').value, 10) || 0;
            const totalMinutes = (hours * 60) + minutes;
            document.getElementById('appealDurationDisplay').textContent = formatDuration(totalMinutes);
        }

        // Handle appeal form submission and duration changes
        document.addEventListener('DOMContentLoaded', () => {
            const appealForm = document.getElementById('appealForm');
            if (appealForm) {
                appealForm.addEventListener('submit', async (event) => {
                    event.preventDefault();
                    await submitAppeal();
                });
            }

            // Set up duration change listeners once
            const appealHoursSelect = document.getElementById('appealHoursSelect');
            const appealMinutesSelect = document.getElementById('appealMinutesSelect');
            if (appealHoursSelect) {
                appealHoursSelect.addEventListener('change', updateAppealDurationDisplay);
            }
            if (appealMinutesSelect) {
                appealMinutesSelect.addEventListener('change', updateAppealDurationDisplay);
            }
        });

        async function submitAppeal() {
            if (!waitTimeToAppeal) {
                notifyWarning('Wait time not found.');
                return;
            }

            const hours = parseInt(document.getElementById('appealHoursSelect').value, 10) || 0;
            const minutes = parseInt(document.getElementById('appealMinutesSelect').value, 10) || 0;
            const totalMinutes = (hours * 60) + minutes;
            const appealNotes = document.getElementById('appealNotesInput').value.trim();

            if (totalMinutes <= 0) {
                notifyWarning('Wait time must be at least 15 minutes.');
                return;
            }

            const submitBtn = document.getElementById('submitAppealBtn');
            submitBtn.disabled = true;
            const submitBtnSpan = submitBtn.querySelector('span');
            if (submitBtnSpan) {
                submitBtnSpan.textContent = 'Resubmitting...';
            }

            try {
                // Check if this wait time has been returned 3 times (cannot appeal)
                if (waitTimeToAppeal.returnNotes3) {
                    // Get office name
                    let officeName = 'your office';
                    try {
                        const officeId = waitTimeToAppeal.officeId || currentUser?.officeId;
                        if (officeId) {
                            const officeDoc = await window.getDoc(window.doc(window.db, 'offices', officeId));
                            if (officeDoc.exists()) {
                                const officeData = officeDoc.data();
                                officeName = officeData.name || 'your office';
                            }
                        }
                    } catch (error) {
                        console.warn('Error fetching office name:', error);
                    }
                    
                    notifyError(
                        `Unfortunately, you have appealed too many times. Please call ${officeName} to discuss this wait time further. Please discard this wait time submission.`,
                        'Maximum Appeals Reached'
                    );
                    submitBtn.disabled = false;
                    if (submitBtnSpan) {
                        submitBtnSpan.textContent = 'Resubmit Wait Time';
                    }
                    return;
                }
                
                // Check if this is the first or second appeal
                const hasFirstAppeal = !!(waitTimeToAppeal.appealNotes1);
                const hasSecondAppeal = !!waitTimeToAppeal.appealNotes2;
                const isSecondAppeal = hasFirstAppeal && !hasSecondAppeal;
                
                if (hasSecondAppeal) {
                    // Already has both appeals - cannot appeal again
                    notifyWarning('This wait time has already been appealed twice. Cannot appeal again.');
                    submitBtn.disabled = false;
                    if (submitBtnSpan) {
                        submitBtnSpan.textContent = 'Resubmit Wait Time';
                    }
                    return;
                }
                
                const updateData = {
                    hours,
                    minutes,
                    totalMinutes,
                    processingStatus: 'pending',
                    updatedAt: window.serverTimestamp()
                };
                
                // Keep original notes separate - don't combine with appeal notes
                // Only update notes if it was previously combined (for backward compatibility)
                if (waitTimeToAppeal.notes && !waitTimeToAppeal.notes.includes('[Appeal Notes:')) {
                    updateData.notes = waitTimeToAppeal.notes;
                } else if (waitTimeToAppeal.notes) {
                    // Extract original notes if they were combined
                    const notesMatch = waitTimeToAppeal.notes.match(/^(.+?)(?:\n\n\[Appeal Notes:)/);
                    updateData.notes = notesMatch ? notesMatch[1] : waitTimeToAppeal.notes;
                }
                
                if (isSecondAppeal) {
                    // Second appeal - use appealNotes2
                    updateData.appealNotes2 = appealNotes;
                    // Clear returnNotes2 for this round
                    updateData.returnNotes2 = null;
                } else {
                    // First appeal - use appealNotes1
                    updateData.appealNotes1 = appealNotes;
                    // Clear returnNotes1 (and migrate old returnNotes if needed)
                    updateData.returnNotes1 = null;
                    updateData.returnNotes = null; // Clear old field for backward compatibility
                }
                updateData.returnedAt = null;
                updateData.returnedBy = null;

                // Update the wait time with new values and reset status
                await window.updateDoc(window.doc(window.db, 'waitTimes', waitTimeToAppeal.id), updateData);

                notifySuccess('Wait time resubmitted successfully.');
                closeAppealModal();
            } catch (error) {
                console.error('Error submitting appeal:', error);
                notifyError('Unable to resubmit wait time. Please try again.');
            } finally {
                submitBtn.disabled = false;
                const submitBtnSpan = submitBtn.querySelector('span');
                if (submitBtnSpan) {
                    submitBtnSpan.textContent = 'Resubmit Wait Time';
                }
            }
        }

        // Discard returned wait time
        async function discardReturnedWaitTime(waitTimeId) {
            const allWaitTimes = [...localWaitTimes, ...remoteWaitTimes];
            const waitTime = allWaitTimes.find(item => item.id === waitTimeId);
            if (!waitTime) {
                notifyWarning('Wait time not found.');
                return;
            }

            const confirmed = window.showConfirmation ? await window.showConfirmation({
                title: 'Discard Returned Wait Time',
                message: 'Discard this returned wait time? This will permanently delete it and cannot be undone.',
                confirmText: 'Discard',
                cancelText: 'Cancel',
                tone: 'danger'
            }) : window.confirm('Discard this returned wait time? This cannot be undone.');

            if (!confirmed) {
                return;
            }

            try {
                await window.deleteDoc(window.doc(window.db, 'waitTimes', waitTimeId));
                notifySuccess('Wait time discarded.');
            } catch (error) {
                console.error('Error discarding wait time:', error);
                notifyError('Unable to discard wait time. Please try again.');
            }
        }
    </script>
</body>
</html>

