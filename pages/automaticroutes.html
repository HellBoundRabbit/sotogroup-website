<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automatic Routes - SOTO Routes</title>
    <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
    <link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/logos/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/logos/favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="/assets/logos/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/assets/logos/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/assets/logos/apple-touch-icon.png">
    <link rel="stylesheet" href="/assets/css/responsive-nav.css">
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/mobile-nav.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="/js/settings.js"></script>
    <script>
        tailwind.config = {
            plugins: {
                forms: {},
                containerQueries: {}
            }
        }
    </script>
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.firestore = db;
        window.firebaseDoc = doc;
        window.firebaseGetDoc = getDoc;
        window.auth = auth;
        window.functions = functions;
        window.firebase = {
            functions,
            httpsCallable
        };
        
        console.log('Firebase initialized successfully!');
    </script>
    <style>
        /* Loading spinner */
        .spinner-wrapper {
            width: 64px;
            height: 64px;
            position: relative;
        }
        .spinner {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 52px;
            height: 52px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="bg-[#111418] text-white" style='font-family: Inter, "Noto Sans", sans-serif;'>
<div class="relative flex h-auto min-h-screen w-full flex-col dark group/design-root overflow-x-hidden">
<div class="flex h-full grow flex-col">

<header class="relative flex items-center justify-between whitespace-nowrap border-b border-solid border-b-[#283039] px-6 py-3" data-soto-nav>
<div class="flex items-center gap-4">
<div class="size-8 text-[var(--primary-color)]">
<svg fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
<path d="M13.8261 17.4264C16.7203 18.1174 20.2244 18.5217 24 18.5217C27.7756 18.5217 31.2797 18.1174 34.1739 17.4264C36.9144 16.7722 39.9967 15.2331 41.3563 14.1648L24.8486 40.6391C24.4571 41.267 23.5429 41.267 23.1514 40.6391L6.64374 14.1648C8.00331 15.2331 11.0856 16.7722 13.8261 17.4264Z" fill="currentColor"></path>
<path clip-rule="evenodd" d="M39.998 12.236C39.9944 12.2537 39.9875 12.2845 39.9748 12.3294C39.9436 12.4399 39.8949 12.5741 39.8346 12.7175C39.8168 12.7597 39.7989 12.8007 39.7813 12.8398C38.5103 13.7113 35.9788 14.9393 33.7095 15.4811C30.9875 16.131 27.6413 16.5217 24 16.5217C20.3587 16.5217 17.0125 16.131 14.2905 15.4811C12.0012 14.9346 9.44505 13.6897 8.18538 12.8168C8.17384 12.7925 8.16216 12.767 8.15052 12.7408C8.09919 12.6249 8.05721 12.5114 8.02977 12.411C8.00356 12.3152 8.00039 12.2667 8.00004 12.2612C8.00004 12.261 8 12.2607 8.00004 12.2612C8.00004 12.2359 8.0104 11.9233 8.68485 11.3686C9.34546 10.8254 10.4222 10.2469 11.9291 9.72276C14.9242 8.68098 19.1919 8 24 8C28.8081 8 33.0758 8.68098 36.0709 9.72276C37.5778 10.2469 38.6545 10.8254 39.3151 11.3686C39.9006 11.8501 39.9857 12.1489 39.998 12.236ZM4.95178 15.2312L21.4543 41.6973C22.6288 43.5809 25.3712 43.5809 26.5457 41.6973L43.0534 15.223C43.0709 15.1948 43.0878 15.1662 43.104 15.1371L41.3563 14.1648C43.104 15.1371 43.1038 15.1374 43.104 15.1371L43.1051 15.135L43.1065 15.1325L43.1101 15.1261L43.1199 15.1082C43.1276 15.094 43.1377 15.0754 43.1497 15.0527C43.1738 15.0075 43.2062 14.9455 43.244 14.8701C43.319 14.7208 43.4196 14.511 43.5217 14.2683C43.6901 13.8679 44 13.0689 44 12.2609C44 10.5573 43.003 9.22254 41.8558 8.2791C40.6947 7.32427 39.1354 6.55361 37.385 5.94477C33.8654 4.72057 29.133 4 24 4C18.867 4 14.1346 4.72057 10.615 5.94478C8.86463 6.55361 7.30529 7.32428 6.14419 8.27911C4.99695 9.22255 3.99999 10.5573 3.99999 12.2609C3.99999 13.1275 4.29264 13.9078 4.49321 14.3607C4.60375 14.6102 4.71348 14.8196 4.79687 14.9689C4.83898 15.0444 4.87547 15.1065 4.9035 15.1529C4.91754 15.1762 4.92954 15.1957 4.93916 15.2111L4.94662 15.223L4.95178 15.2312ZM35.9868 18.996L24 38.22L12.0131 18.996C12.4661 19.1391 12.9179 19.2658 13.3617 19.3718C16.4281 20.1039 20.0901 20.5217 24 20.5217C27.9099 20.5217 31.5719 20.1039 34.6383 19.3718C35.082 19.2658 35.5339 19.1391 35.9868 18.996Z" fill="currentColor" fill-rule="evenodd"></path>
</svg>
</div>
<h2 class="text-xl font-bold">SOTO Routes</h2>
</div>
<nav class="flex flex-1 justify-center gap-2" data-soto-nav-links>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/soto-lp.html">Routes</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/optimisation.html">Optimisation</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/drivers.html">Drivers</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/availability.html">Availability</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/expenses.html">Expenses</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/wait-times.html">Wait Times</a>
<a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/messages.html">Messages</a>
</nav>
<div class="flex items-center gap-4">
<button type="button" class="mobile-nav-toggle" data-soto-nav-toggle aria-label="Toggle navigation" aria-expanded="false">
    <span class="material-symbols-outlined text-xl">menu</span>
</button>
<div class="relative">
    <button class="flex items-center justify-center rounded-full h-10 w-10 bg-[#283039] hover:bg-[#3a444e] transition-colors relative" onclick="showNotifications()">
        <span class="material-symbols-outlined text-xl">notifications</span>
        <!-- Notification Badge -->
        <span class="notification-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center font-bold hidden">0</span>
    </button>
    <!-- Notifications Dropdown -->
    <div id="notificationDropdown" class="hidden absolute right-0 mt-2 w-80 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto">
        <div class="px-4 py-3 border-b border-[#283039]">
            <h3 class="text-white font-semibold text-sm">Notifications</h3>
        </div>
        <div id="notificationsList" class="max-h-64 overflow-y-auto">
            <!-- Notifications will be loaded here -->
        </div>
    </div>
</div>
<div class="relative flex items-center gap-3">
    <span id="asanaUserEmail" class="text-xs text-gray-400 hidden flex items-center gap-1">
        <span class="material-symbols-outlined text-sm">account_circle</span>
        <span id="asanaUserEmailText"></span>
    </span>
    <button onclick="toggleProfileDropdown()" class="flex items-center justify-center rounded-full size-10 bg-[#283039] overflow-hidden hover:ring-2 hover:ring-blue-500 transition-all cursor-pointer">
        <img id="officeLogoImg" src="/assets/logos/favicon.svg" alt="Office Logo" class="w-full h-full object-cover" onerror="this.src='/assets/logos/favicon.svg'">
    </button>
    <!-- Profile Dropdown -->
    <div id="profileDropdown" class="hidden absolute right-0 mt-2 w-48 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50">
        <button onclick="showSettings()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors rounded-t-lg">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">settings</span>
            Settings
        </button>
        <button onclick="showChangePassword()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">lock</span>
            Change Password
        </button>
        <button onclick="viewUsage()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">calendar_month</span>
            View Usage
        </button>
        <button onclick="logout()" class="block w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-[#283039] transition-colors rounded-b-lg">
            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">logout</span>
            Logout
        </button>
    </div>
</div>
</div>
</header>

    <!-- Main Content -->
    <main class="flex-1 px-6 py-8 max-w-7xl mx-auto w-full">
        <!-- Asana Connection Screen -->
        <div id="asanaConnectionScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-md mx-auto">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white mb-2">Connect to Asana</h2>
                    <p class="text-gray-400 text-sm">Connect your Asana account to import routes automatically</p>
                </div>
                <button 
                    id="connectAsanaBtn" 
                    onclick="connectToAsana()"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                >
                    <span class="material-symbols-outlined">link</span>
                    Connect to Asana
                </button>
            </div>
        </div>

        <!-- Project Picker Screen -->
        <div id="projectPickerScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-md mx-auto">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white mb-2">Select Project</h2>
                    <p class="text-gray-400 text-sm">Choose the Asana project to import routes from</p>
                </div>
                <div class="mb-4">
                    <label for="projectSelect" class="block text-sm font-medium text-gray-300 mb-2">Project</label>
                    <select 
                        id="projectSelect" 
                        class="w-full px-4 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                    >
                        <option value="">Loading projects...</option>
                    </select>
                </div>
                <button 
                    id="selectProjectBtn" 
                    onclick="selectProject()"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                >
                    <span class="material-symbols-outlined">arrow_forward</span>
                    Continue
                </button>
            </div>
        </div>

        <!-- Day Picker Screen -->
        <div id="dayPickerScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-md mx-auto">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white mb-2">Select Date</h2>
                    <p class="text-gray-400 text-sm" id="selectedProjectText">Choose the date to import routes from Asana</p>
                </div>
                <div class="mb-4">
                    <label for="routeDate" class="block text-sm font-medium text-gray-300 mb-2">Date</label>
                    <input 
                        type="date" 
                        id="routeDate" 
                        class="w-full px-4 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                        required
                    >
                </div>
                <button 
                    id="checkTasksBtn" 
                    onclick="checkTasksForDate()"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                >
                    <span class="material-symbols-outlined">search</span>
                    Check Tasks
                </button>
                <button 
                    onclick="showScreen('projectPickerScreen')"
                    class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                >
                    Back
                </button>
            </div>
        </div>

        <!-- Tasks Count Screen -->
        <div id="tasksCountScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-lg mx-auto">
                <div class="text-center mb-6">
                    <h2 class="text-2xl font-bold text-white mb-2">Tasks Found</h2>
                    <p class="text-gray-400 text-sm" id="selectedDateText"></p>
                </div>
                <div class="mb-6 text-center">
                    <div class="text-4xl font-bold text-blue-500 mb-2" id="tasksCount">0</div>
                    <p class="text-gray-400 text-sm mb-4">tasks found for this date</p>
                </div>
                
                <!-- Task Titles List -->
                <div class="mb-6 max-h-64 overflow-y-auto">
                    <h3 class="text-sm font-semibold text-gray-300 mb-3">Task Titles:</h3>
                    <div id="taskTitlesList" class="space-y-2">
                        <!-- Task titles will be populated here -->
                    </div>
                </div>
                
                <button 
                    id="processJobsBtn" 
                    onclick="startRouteGrouping()"
                    class="w-full bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                >
                    <span class="material-symbols-outlined">play_arrow</span>
                    Group Jobs into Routes
                </button>
                <button 
                    onclick="showScreen('dayPickerScreen')"
                    class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                >
                    Back
                </button>
            </div>
        </div>

        <!-- Loading Screen -->
        <div id="loadingScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-md mx-auto text-center">
                <div class="spinner-wrapper mx-auto mb-4">
                    <div class="spinner"></div>
                    <div class="spinner1"></div>
                </div>
                <p class="text-white text-lg font-semibold" id="loadingText">Loading...</p>
            </div>
        </div>

        <!-- Route Grouping Instructions Screen -->
        <div id="routeGroupingInstructionsScreen" class="hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-2xl mx-auto">
                <div class="text-center mb-8">
                    <h2 class="text-3xl font-bold text-white mb-4">Group Jobs into Routes</h2>
                    <p class="text-gray-400 text-lg mb-6">Follow these simple steps to organize your jobs:</p>
                </div>
                
                <div class="space-y-6 mb-8">
                    <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                        <div class="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold">1</div>
                        <div>
                            <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">Space</kbd> to start</h3>
                            <p class="text-gray-400 text-sm">Begin grouping jobs into routes</p>
                        </div>
                    </div>
                    
                    <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                        <div class="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold">2</div>
                        <div>
                            <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">Space</kbd> on jobs to select</h3>
                            <p class="text-gray-400 text-sm">Select jobs to group together (they will be highlighted)</p>
                        </div>
                    </div>
                    
                    <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                        <div class="flex-shrink-0 w-10 h-10 rounded-full bg-green-600 flex items-center justify-center text-white font-bold">3</div>
                        <div>
                            <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">S</kbd> to group selected jobs</h3>
                            <p class="text-gray-400 text-sm">Selected jobs will be grouped into a route and disappear</p>
                        </div>
                    </div>
                    
                    <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                        <div class="flex-shrink-0 w-10 h-10 rounded-full bg-purple-600 flex items-center justify-center text-white font-bold">4</div>
                        <div>
                            <h3 class="text-white font-semibold mb-2">Repeat until all jobs are grouped</h3>
                            <p class="text-gray-400 text-sm">Continue grouping until all jobs are organized into routes</p>
                        </div>
                    </div>
                </div>
                
                <div class="text-center">
                    <button 
                        id="startGroupingBtn"
                        onclick="startRouteGrouping()"
                        class="px-8 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors font-medium text-lg flex items-center justify-center gap-2 mx-auto"
                    >
                        <span class="material-symbols-outlined">play_arrow</span>
                        Press Space to Begin
                    </button>
                    <p class="text-gray-400 text-sm mt-4">Or click the button above</p>
                </div>
            </div>
        </div>

        <!-- Route Grouping Screen -->
        <div id="routeGroupingScreen" class="hidden">
            <div class="mb-6 flex items-center justify-between">
                <div>
                    <h2 class="text-2xl font-bold text-white mb-2">Group Jobs into Routes</h2>
                    <p class="text-gray-400 text-sm" id="selectedDateDisplay"></p>
                </div>
                <div class="flex items-center gap-4">
                    <div class="bg-[#283039] px-4 py-2 rounded-lg flex items-center gap-2">
                        <span class="text-gray-400 text-sm">Routes:</span>
                        <span class="text-white font-bold text-lg" id="routesCount">0</span>
                    </div>
                    <button 
                        id="processRoutesBtn"
                        onclick="processRoutes()"
                        class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors font-medium"
                        disabled
                    >
                        Process Routes
                    </button>
                    <button 
                        onclick="showScreen('tasksCountScreen')"
                        class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors text-sm"
                    >
                        Back
                    </button>
                </div>
            </div>
            <div id="groupingJobsContainer" class="space-y-4 relative">
                <!-- Jobs will be displayed here for grouping -->
                <!-- Greyed out overlay when not started -->
                <div id="groupingStartOverlay" class="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 rounded-lg">
                    <div class="text-center">
                        <p class="text-white text-xl font-semibold mb-2">Press <kbd class="px-3 py-1 bg-[#1a1f24] rounded text-lg border border-gray-600">Space</kbd> to start</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Route Review Screen -->
        <div id="routeReviewScreen" class="hidden">
            <div class="mb-6 flex items-center justify-between">
                <div>
                    <h2 class="text-2xl font-bold text-white mb-2">Review & Edit Routes</h2>
                    <p class="text-gray-400 text-sm">Review parsed data and make corrections before saving</p>
                </div>
                <button 
                    onclick="saveAllRoutes()"
                    class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors font-medium flex items-center gap-2"
                >
                    <span class="material-symbols-outlined">save</span>
                    Save All Routes
                </button>
            </div>
            <div id="routeReviewContainer" class="space-y-4">
                <!-- Routes will be displayed here for review -->
            </div>
        </div>

        <!-- Jobs Display Screen -->
        <div id="jobsDisplayScreen" class="hidden">
            <div class="mb-6 flex items-center justify-between">
                <div>
                    <h2 class="text-2xl font-bold text-white mb-2">Parsed Jobs</h2>
                    <p class="text-gray-400 text-sm" id="selectedDateDisplay"></p>
                </div>
                <button 
                    onclick="showScreen('tasksCountScreen')"
                    class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors text-sm"
                >
                    Back
                </button>
            </div>
            <div id="jobsContainer" class="space-y-4">
                <!-- Jobs will be displayed here -->
            </div>
        </div>
    </main>
</div>
</div>

<script>
    let currentSession = null;

    // Load office logo from Firebase
    async function loadOfficeLogo(officeId) {
        if (!officeId) {
            console.log('No officeId provided, skipping logo load');
            return;
        }
        
        console.log('Loading office logo for officeId:', officeId);
        
        try {
            // Wait for Firebase to be ready with retries
            let attempts = 0;
            while (attempts < 20 && (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc)) {
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc) {
                console.error('Firebase not ready after waiting');
                return;
            }
            
            console.log('Fetching office document...');
            const officeDoc = await window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'offices', officeId));
            
            if (!officeDoc.exists()) {
                console.log('Office document does not exist');
                return;
            }
            
            const officeData = officeDoc.data();
            console.log('Office data:', officeData);
            console.log('Office logoUrl:', officeData.logoUrl);
            
            const logoImg = document.getElementById('officeLogoImg');
            if (!logoImg) {
                console.error('Logo image element not found');
                return;
            }
            
            if (officeData.logoUrl) {
                logoImg.src = officeData.logoUrl;
                logoImg.onerror = () => {
                    logoImg.src = '/assets/logos/favicon.svg';
                };
            }
        } catch (error) {
            console.error('Error loading office logo:', error);
        }
    }

    // Asana OAuth configuration
    const ASANA_CLIENT_ID = '1212057669835882';
    // Use exact URL including protocol - must match Asana app settings exactly
    const ASANA_REDIRECT_URI = window.location.origin + window.location.pathname;
    const ASANA_AUTH_URL = 'https://app.asana.com/-/oauth_authorize';
    const ASANA_TOKEN_URL = 'https://app.asana.com/-/oauth_token';
    const ASANA_API_BASE = 'https://app.asana.com/api/1.0';

    // Check for Asana OAuth callback
    function handleAsanaCallback() {
        const urlParams = new URLSearchParams(window.location.search);
        const code = urlParams.get('code');
        const error = urlParams.get('error');

        if (error) {
            console.error('Asana OAuth error:', error);
            showScreen('asanaConnectionScreen');
            return;
        }

        if (code) {
            // Exchange authorization code for access token
            exchangeCodeForToken(code);
            // Clean up URL
            window.history.replaceState({}, document.title, window.location.pathname);
        }
    }

    // Exchange authorization code for access token
    // NOTE: This should be done via Firebase Cloud Function for security
    async function exchangeCodeForToken(code) {
        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = 'Connecting to Asana...';

        try {
            // Use Firebase Cloud Function to exchange code for token (secure)
            if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                // Use the same redirect URI that was used in the authorization request
                const redirectUri = window.location.origin + window.location.pathname;
                console.log('Exchanging token with redirect_uri:', redirectUri);
                
                const exchangeTokenFunction = window.firebase.httpsCallable(window.firebase.functions, 'exchangeAsanaToken');
                const result = await exchangeTokenFunction({
                    code: code,
                    redirect_uri: redirectUri
                });

                if (result.data.success && result.data.access_token) {
                    const accessToken = result.data.access_token;

                    // Store token securely
                    if (currentSession && currentSession.officeId) {
                        const tokenKey = `asana_token_${currentSession.officeId}`;
                        localStorage.setItem(tokenKey, accessToken);
                    }

                    // Fetch Asana user info to display email
                    await fetchAndDisplayAsanaUser(accessToken);

                    // Show project picker
                    await loadProjects(accessToken);
                    showScreen('projectPickerScreen');
                } else {
                    throw new Error(result.data.error || 'Failed to exchange code for token');
                }
            } else {
                // Fallback: Direct API call (NOT RECOMMENDED for production)
                // This requires client secret which should never be exposed
                throw new Error('Firebase Functions not available. Please configure exchangeAsanaToken Cloud Function.');
            }
        } catch (error) {
            console.error('Error exchanging code for token:', error);
            alert('Failed to connect to Asana: ' + error.message);
            showScreen('asanaConnectionScreen');
        }
    }

    // Connect to Asana
    async function connectToAsana() {
        // Check if already connected
        if (currentSession && currentSession.officeId) {
            const tokenKey = `asana_token_${currentSession.officeId}`;
            const existingToken = localStorage.getItem(tokenKey);
            
            if (existingToken) {
                // Already connected, show project picker
                await loadProjects(existingToken);
                showScreen('projectPickerScreen');
                return;
            }
        }

        // Redirect to Asana OAuth
        // Note: If "Full permissions" is enabled in Asana app settings,
        // do not include scope parameter. If using specific scopes, register
        // them in the developer console first.
        const authUrl = new URL(ASANA_AUTH_URL);
        authUrl.searchParams.set('client_id', ASANA_CLIENT_ID);
        authUrl.searchParams.set('redirect_uri', ASANA_REDIRECT_URI);
        authUrl.searchParams.set('response_type', 'code');
        // Scope parameter removed - using "Full permissions" from app settings
        
        window.location.href = authUrl.toString();
    }

    // Show specific screen
    function showScreen(screenId) {
        const screens = ['asanaConnectionScreen', 'projectPickerScreen', 'dayPickerScreen', 'loadingScreen', 'routesDisplayScreen', 'tasksCountScreen', 'jobsDisplayScreen', 'routeGroupingInstructionsScreen', 'routeGroupingScreen', 'routeReviewScreen'];
        screens.forEach(id => {
            const screen = document.getElementById(id);
            if (screen) {
                screen.classList.add('hidden');
            }
        });
        
        const targetScreen = document.getElementById(screenId);
        if (targetScreen) {
            targetScreen.classList.remove('hidden');
        }
    }

    // Store tasks and selected date globally
    let currentTasks = [];
    let selectedDate = null;
    let selectedProjectId = null;
    let selectedProjectName = null;
    let availableProjects = [];

    // Load projects from Asana
    async function loadProjects(accessToken) {
        try {
            showScreen('loadingScreen');
            document.getElementById('loadingText').textContent = 'Loading projects...';

            // Use direct Asana API calls (simpler and was working before)
            // First, get workspaces
            const workspacesUrl = 'https://app.asana.com/api/1.0/workspaces';
            const workspacesResponse = await fetch(workspacesUrl, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            if (!workspacesResponse.ok) {
                if (workspacesResponse.status === 401) {
                    // Token expired - need to reconnect
                    if (currentSession && currentSession.officeId) {
                        localStorage.removeItem(`asana_token_${currentSession.officeId}`);
                    }
                    throw new Error('Asana connection expired. Please reconnect to Asana.');
                }
                throw new Error(`Failed to fetch workspaces: ${workspacesResponse.status}`);
            }

            const workspacesData = await workspacesResponse.json();
            const workspaceId = workspacesData.data?.[0]?.gid;

            if (!workspaceId) {
                throw new Error('No workspace found');
            }

            // Fetch projects from workspace
            const projectsUrl = `https://app.asana.com/api/1.0/workspaces/${workspaceId}/projects?opt_fields=gid,name&limit=100`;
            const projectsResponse = await fetch(projectsUrl, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            if (!projectsResponse.ok) {
                throw new Error(`Failed to fetch projects: ${projectsResponse.status}`);
            }

            const projectsData = await projectsResponse.json();
            availableProjects = projectsData.data || [];

            // Populate project select dropdown
            const projectSelect = document.getElementById('projectSelect');
            if (projectSelect) {
                projectSelect.innerHTML = '<option value="">Select a project...</option>';

                availableProjects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.gid;
                    option.textContent = project.name;
                    projectSelect.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading projects:', error);
            alert('Failed to load projects: ' + error.message);
            // If token expired, show connection screen
            if (error.message.includes('expired') || error.message.includes('401')) {
                showScreen('asanaConnectionScreen');
            }
        }
    }

    // Select project and move to date picker
    function selectProject() {
        const projectSelect = document.getElementById('projectSelect');
        const projectId = projectSelect.value;
        
        if (!projectId) {
            alert('Please select a project');
            return;
        }

        selectedProjectId = projectId;
        selectedProjectName = availableProjects.find(p => p.gid === projectId)?.name || 'Selected Project';
        
        // Update the date picker screen to show selected project
        const projectText = document.getElementById('selectedProjectText');
        if (projectText) {
            projectText.textContent = `Choose the date to import routes from "${selectedProjectName}"`;
        }
        
        showScreen('dayPickerScreen');
    }

    // Check tasks for selected date
    async function checkTasksForDate() {
        const dateInput = document.getElementById('routeDate');
        selectedDate = dateInput.value;

        if (!selectedDate) {
            alert('Please select a date');
            return;
        }

        if (!selectedProjectId) {
            alert('Please select a project first');
            showScreen('projectPickerScreen');
            return;
        }

        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = 'Checking tasks in Asana...';

        try {
            // Get stored token
            if (!currentSession || !currentSession.officeId) {
                throw new Error('Session not available');
            }

            const tokenKey = `asana_token_${currentSession.officeId}`;
            const accessToken = localStorage.getItem(tokenKey);

            if (!accessToken) {
                throw new Error('Not connected to Asana');
            }

            // Fetch tasks from Asana with project ID
            currentTasks = await fetchAsanaTasks(accessToken, selectedDate, selectedProjectId);

            // Display task count with titles
            displayTaskCount(currentTasks.length, selectedDate);
        } catch (error) {
            console.error('Error checking tasks:', error);
            alert('Failed to check tasks: ' + error.message);
            showScreen('dayPickerScreen');
        }
    }

    // Extract driver name from task title
    // Examples: "Chris (1) Deliver Carryover" -> "Chris"
    //          "Chris Free" -> "Chris"
    //          "Martin (2) United Rental..." -> "Martin"
    function extractDriverName(taskName) {
        if (!taskName) return 'Unknown';
        
        // Remove leading/trailing whitespace
        const trimmed = taskName.trim();
        
        // Match pattern: Name followed by space and either:
        // - (number) or (number)
        // - "Free"
        // - Just the name if no pattern matches
        const match = trimmed.match(/^([^\(]+?)(?:\s*\(?\d+\)?|\s+Free|$)/i);
        if (match && match[1]) {
            return match[1].trim();
        }
        
        // Fallback: return first word or first few words before any number
        const beforeNumber = trimmed.split(/\s*\(?\d/)[0].trim();
        if (beforeNumber) {
            return beforeNumber;
        }
        
        return trimmed.split(' ')[0] || 'Unknown';
    }

    // Sort tasks by driver name, then by job number
    function sortTasksByDriver(tasks) {
        return [...tasks].sort((a, b) => {
            const nameA = extractDriverName(a.name || '');
            const nameB = extractDriverName(b.name || '');
            
            // First sort by driver name (case-insensitive)
            const nameCompare = nameA.localeCompare(nameB, undefined, { sensitivity: 'base' });
            if (nameCompare !== 0) {
                return nameCompare;
            }
            
            // If same driver, sort by job number (extract number from title)
            const getJobNumber = (taskName) => {
                const match = taskName.match(/\((\d+)\)/);
                return match ? parseInt(match[1], 10) : 999; // Put items without numbers at end
            };
            
            const numA = getJobNumber(a.name || '');
            const numB = getJobNumber(b.name || '');
            
            return numA - numB;
        });
    }

    // Display task count with titles
    function displayTaskCount(count, date) {
        const countElement = document.getElementById('tasksCount');
        const dateText = document.getElementById('selectedDateText');
        const titlesList = document.getElementById('taskTitlesList');
        
        if (countElement) {
            countElement.textContent = count;
        }
        
        if (dateText) {
            const dateObj = new Date(date);
            const formattedDate = dateObj.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
            dateText.textContent = `Tasks for ${formattedDate} in "${selectedProjectName}"`;
        }
        
        // Display task titles (sorted by driver)
        if (titlesList) {
            titlesList.innerHTML = '';
            if (currentTasks.length === 0) {
                titlesList.innerHTML = '<p class="text-gray-400 text-sm">No tasks found</p>';
            } else {
                // Sort tasks by driver name
                const sortedTasks = sortTasksByDriver(currentTasks);
                
                sortedTasks.forEach((task, index) => {
                    const taskItem = document.createElement('div');
                    taskItem.className = 'bg-[#283039] rounded-lg p-3 text-sm text-white';
                    taskItem.textContent = `${index + 1}. ${task.name || 'Untitled Task'}`;
                    titlesList.appendChild(taskItem);
                });
            }
        }
        
        showScreen('tasksCountScreen');
    }

    // Process jobs - parse all tasks
    async function processJobs() {
        if (!currentTasks || currentTasks.length === 0) {
            alert('No tasks to process');
            return;
        }

        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = `Processing ${currentTasks.length} jobs...`;

        try {
            // Parse all tasks using the parseJobText function
            const parsedJobs = [];
            
            for (let i = 0; i < currentTasks.length; i++) {
                const task = currentTasks[i];
                const taskText = `${task.name || ''}\n${task.notes || ''}`;
                
                // Use Firebase Cloud Function to parse job text
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    try {
                        const parseFunction = window.firebase.httpsCallable(window.firebase.functions, 'parseJobText');
                        const result = await parseFunction({
                            rawText: taskText
                        });

                        if (result.data && result.data.success && result.data.parsed_data) {
                            const parsedData = result.data.parsed_data;
                            parsedJobs.push({
                                task: task,
                                parsedData: parsedData,
                                confidence: parsedData.overall_confidence || 0
                            });
                        } else {
                            // If parsing fails, still add the task with empty data
                            parsedJobs.push({
                                task: task,
                                parsedData: {
                                    collection_address: 'Not found',
                                    postcode_delivery: 'Not found',
                                    price: 0,
                                    reg_number: 'Not found',
                                    confidence_scores: {
                                        collection: 0,
                                        delivery: 0,
                                        price: 0,
                                        reg: 0
                                    },
                                    overall_confidence: 0
                                },
                                confidence: 0
                            });
                        }
                    } catch (parseError) {
                        console.error('Error parsing task:', parseError);
                        // Fallback: basic parsing
                        parsedJobs.push({
                            task: task,
                            parsedData: {
                                ...parseTaskBasic(task),
                                confidence_scores: {
                                    collection: 40,
                                    delivery: 40,
                                    price: 40,
                                    reg: 40
                                },
                                overall_confidence: 40
                            },
                            confidence: 40
                        });
                    }
                } else {
                    // Fallback: basic parsing
                    const basicParsed = parseTaskBasic(task);
                    parsedJobs.push({
                        task: task,
                        parsedData: {
                            ...basicParsed,
                            confidence_scores: {
                                collection: 40,
                                delivery: 40,
                                price: 40,
                                reg: 40
                            },
                            overall_confidence: 40
                        },
                        confidence: 40
                    });
                }
            }

            // Store parsed jobs globally
            parsedJobsData = parsedJobs;
            
            // Display parsed jobs
            displayParsedJobs(parsedJobs, selectedDate);
            
            // Show route grouping instructions screen
            showScreen('routeGroupingInstructionsScreen');
        } catch (error) {
            console.error('Error processing jobs:', error);
            alert('Failed to process jobs: ' + error.message);
            showScreen('tasksCountScreen');
        }
    }

    // Basic task parsing (fallback)
    function parseTaskBasic(task) {
        const notes = task.notes || '';
        const name = task.name || '';
        const text = `${name}\n${notes}`.toUpperCase();
        
        // Simple regex patterns
        const postcodeRegex = /\b([A-Z]{1,2}\d{1,2}[A-Z]?\s?\d[A-Z]{2})\b/g;
        const postcodes = [];
        let match;
        while ((match = postcodeRegex.exec(text)) !== null) {
            postcodes.push(match[1]);
        }
        
        const priceRegex = /Â£?\s?(\d+(?:[.,]\d{2})?)/g;
        const prices = [];
        while ((match = priceRegex.exec(text)) !== null) {
            const price = parseFloat(match[1].replace(',', '.'));
            if (price >= 20 && price <= 1000) {
                prices.push(price);
            }
        }
        
        const regRegex = /\b([A-Z]{1,2}\d{1,2}\s?[A-Z]{3}|[A-Z]{1,3}\d{1,3}\s?[A-Z]{0,3})\b/g;
        const regs = [];
        while ((match = regRegex.exec(text)) !== null) {
            regs.push(match[1]);
        }
        
        return {
            collection_address: postcodes[0] || 'Not found',
            postcode_delivery: postcodes[1] || postcodes[0] || 'Not found',
            price: prices[0] || 0,
            reg_number: regs[0] || 'Not found'
        };
    }

    // Fetch Asana user info and display email
    async function fetchAndDisplayAsanaUser(accessToken) {
        try {
            // Use Firebase Cloud Function to fetch user info (recommended for security)
            if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                const fetchUserFunction = window.firebase.httpsCallable(window.firebase.functions, 'fetchAsanaUser');
                const result = await fetchUserFunction({
                    access_token: accessToken
                });

                if (result.data.success && result.data.user) {
                    const userEmail = result.data.user.email || result.data.user.name || 'Asana User';
                    displayAsanaUserEmail(userEmail);
                    
                    // Store email for later use
                    if (currentSession && currentSession.officeId) {
                        const emailKey = `asana_email_${currentSession.officeId}`;
                        localStorage.setItem(emailKey, userEmail);
                    }
                }
            } else {
                // Fallback: Direct API call
                const response = await fetch(`${ASANA_API_BASE}/users/me`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (response.ok) {
                    const userData = await response.json();
                    const userEmail = userData.data?.email || userData.data?.name || 'Asana User';
                    displayAsanaUserEmail(userEmail);
                    
                    // Store email for later use
                    if (currentSession && currentSession.officeId) {
                        const emailKey = `asana_email_${currentSession.officeId}`;
                        localStorage.setItem(emailKey, userEmail);
                    }
                }
            }
        } catch (error) {
            console.error('Error fetching Asana user info:', error);
            // Don't block the flow if user info fetch fails
        }
    }

    // Display Asana user email in header
    function displayAsanaUserEmail(email) {
        const emailContainer = document.getElementById('asanaUserEmail');
        const emailText = document.getElementById('asanaUserEmailText');
        if (emailContainer && emailText) {
            emailText.textContent = email;
            emailContainer.classList.remove('hidden');
        }
    }

    // Fetch tasks from Asana API
    async function fetchAsanaTasks(accessToken, date, projectId) {
        try {
            // Use Firebase Cloud Function to fetch tasks (recommended for security)
            if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                const fetchTasksFunction = window.firebase.httpsCallable(window.firebase.functions, 'fetchAsanaTasks');
                const result = await fetchTasksFunction({
                    access_token: accessToken,
                    date: date,
                    project_id: projectId
                });

                if (result.data && result.data.success) {
                    return result.data.tasks || [];
                } else {
                    throw new Error(result.data?.error || 'Failed to fetch tasks');
                }
            } else {
                // Fallback: Direct API call
                // Note: You may need to specify workspace/project IDs
                // Adjust the query parameters based on your Asana setup
                const response = await fetch(`${ASANA_API_BASE}/tasks?opt_fields=name,due_on,notes,assignee,projects,custom_fields&due_on=${date}&limit=100`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        // Token expired or invalid
                        if (currentSession && currentSession.officeId) {
                            localStorage.removeItem(`asana_token_${currentSession.officeId}`);
                        }
                        throw new Error('Asana connection expired. Please reconnect.');
                    }
                    throw new Error(`Asana API error: ${response.status}`);
                }

                const data = await response.json();
                return data.data || [];
            }
        } catch (error) {
            console.error('Error fetching Asana tasks:', error);
            throw error;
        }
    }

    // Display parsed jobs with confidence ratings
    function displayParsedJobs(parsedJobs, selectedDate) {
        const container = document.getElementById('jobsContainer');
        const dateDisplay = document.getElementById('selectedDateDisplay');
        
        // Format date for display
        const dateObj = new Date(selectedDate);
        const formattedDate = dateObj.toLocaleDateString('en-US', { 
            weekday: 'long', 
            year: 'numeric', 
            month: 'long', 
            day: 'numeric' 
        });
        dateDisplay.textContent = `Jobs for ${formattedDate}`;

        // Clear container
        container.innerHTML = '';

        if (parsedJobs.length === 0) {
            container.innerHTML = `
                <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 text-center">
                    <p class="text-gray-400">No jobs to display.</p>
                </div>
            `;
            showScreen('jobsDisplayScreen');
            return;
        }

        // Display each parsed job
        parsedJobs.forEach((jobData, index) => {
            const jobCard = createParsedJobCard(jobData, index + 1);
            container.appendChild(jobCard);
        });

        showScreen('jobsDisplayScreen');
    }

    // Create job card with parsed data and confidence ratings
    function createParsedJobCard(jobData, jobNumber) {
        const { task, parsedData, confidence } = jobData;
        const card = document.createElement('div');
        card.className = 'bg-[#1a1f24] border border-[#283039] rounded-lg p-6';
        card.dataset.jobIndex = jobNumber - 1;
        
        // Get confidence scores
        const confScores = parsedData.confidence_scores || {};
        const collectionConf = confScores.collection || confScores.collection_address || 0;
        const deliveryConf = confScores.delivery || confScores.postcode_delivery || 0;
        const priceConf = confScores.price || 0;
        const regConf = confScores.reg || confScores.reg_number || 0;
        
        // Get parsed values
        const collection = parsedData.collection_address || 'Not found';
        const delivery = parsedData.postcode_delivery || 'Not found';
        const price = parsedData.price || 0;
        const reg = parsedData.reg_number || 'Not found';
        
        // Confidence color helper
        const getConfidenceColor = (conf) => {
            if (conf >= 80) return 'text-green-400';
            if (conf >= 60) return 'text-yellow-400';
            return 'text-red-400';
        };
        
        // Confidence badge helper
        const getConfidenceBadge = (conf) => {
            const color = getConfidenceColor(conf);
            return `<span class="text-xs ${color} font-semibold">${conf}%</span>`;
        };

        card.innerHTML = `
            <div class="flex items-start justify-between mb-4">
                <div class="flex-1">
                    <div class="flex items-center gap-2 mb-1">
                        <h3 class="text-lg font-semibold text-white">Job ${jobNumber}</h3>
                        <span class="px-2 py-1 rounded text-xs font-semibold ${getConfidenceColor(confidence)} bg-opacity-20">
                            ${confidence}% Confidence
                        </span>
                    </div>
                    <p class="text-sm text-gray-400">${task.name || 'Untitled Task'}</p>
                </div>
                <button 
                    onclick="editJob(${jobNumber - 1})"
                    class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white text-xs rounded transition-colors flex items-center gap-1"
                >
                    <span class="material-symbols-outlined text-sm">edit</span>
                    Edit
                </button>
            </div>
            <div class="grid grid-cols-2 gap-4 mt-4">
                <div class="bg-[#283039] rounded-lg p-3">
                    <div class="flex items-center justify-between mb-1">
                        <p class="text-xs text-gray-400">Collection Postcode</p>
                        ${getConfidenceBadge(collectionConf)}
                    </div>
                    <p class="text-sm text-white font-medium" id="job-${jobNumber}-collection">${collection}</p>
                </div>
                <div class="bg-[#283039] rounded-lg p-3">
                    <div class="flex items-center justify-between mb-1">
                        <p class="text-xs text-gray-400">Delivery Postcode</p>
                        ${getConfidenceBadge(deliveryConf)}
                    </div>
                    <p class="text-sm text-white font-medium" id="job-${jobNumber}-delivery">${delivery}</p>
                </div>
                <div class="bg-[#283039] rounded-lg p-3">
                    <div class="flex items-center justify-between mb-1">
                        <p class="text-xs text-gray-400">Price</p>
                        ${getConfidenceBadge(priceConf)}
                    </div>
                    <p class="text-sm text-white font-medium" id="job-${jobNumber}-price">Â£${price.toFixed(2)}</p>
                </div>
                <div class="bg-[#283039] rounded-lg p-3">
                    <div class="flex items-center justify-between mb-1">
                        <p class="text-xs text-gray-400">REG</p>
                        ${getConfidenceBadge(regConf)}
                    </div>
                    <p class="text-sm text-white font-medium" id="job-${jobNumber}-reg">${reg}</p>
                </div>
            </div>
        `;

        return card;
    }

    // Store parsed jobs globally for editing
    let parsedJobsData = [];
    
    // Route grouping state
    let routeGroupingMode = false;
    let selectedJobsForRoute = [];
    let currentFocusedJobIndex = -1; // Track which job the cursor is on (for navigation)
    let routeGroupingStarted = false; // Track if user has pressed Space to start
    let routeCounter = 0;
    let ungroupedJobs = [];
    let savedRoutes = []; // Store routes that have been created
    let routeReviewData = []; // Store routes for review

    // Edit job data
    function editJob(jobIndex) {
        if (!parsedJobsData || jobIndex >= parsedJobsData.length) {
            alert('Job not found');
            return;
        }

        const jobData = parsedJobsData[jobIndex];
        showEditJobModal(jobData, jobIndex);
    }

    // Store current editing job index
    let currentEditingJobIndex = null;

    // Show edit job modal
    function showEditJobModal(jobData, jobIndex) {
        const { task, parsedData } = jobData;
        const confScores = parsedData.confidence_scores || {};
        currentEditingJobIndex = jobIndex;
        
        // Create or get modal
        let modal = document.getElementById('editJobModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'editJobModal';
            modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden';
            modal.innerHTML = `
                <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Edit Job</h3>
                        <button onclick="closeEditJobModal()" class="text-gray-400 hover:text-white">
                            <span class="material-symbols-outlined">close</span>
                        </button>
                    </div>
                    <div id="editJobForm" class="space-y-4">
                        <!-- Form will be populated here -->
                    </div>
                    <div class="mt-6 flex justify-end gap-3">
                        <button onclick="closeEditJobModal()" class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button onclick="saveJobEdits()" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors">
                            Save Changes
                        </button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        // Escape HTML for safe display
        const escapeHtml = (text) => {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        };

        // Populate form
        const form = document.getElementById('editJobForm');
        form.innerHTML = `
            <div>
                <label class="block text-sm font-medium text-gray-300 mb-2">Task Name</label>
                <input type="text" id="editJobName" value="${escapeHtml(task.name || '')}" 
                    class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white" readonly>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        Collection Postcode 
                        <span class="text-xs text-gray-400">(${confScores.collection || confScores.collection_address || 0}% confidence)</span>
                    </label>
                    <input type="text" id="editJobCollection" value="${escapeHtml(parsedData.collection_address || '')}" 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        Delivery Postcode 
                        <span class="text-xs text-gray-400">(${confScores.delivery || confScores.postcode_delivery || 0}% confidence)</span>
                    </label>
                    <input type="text" id="editJobDelivery" value="${escapeHtml(parsedData.postcode_delivery || '')}" 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        Price 
                        <span class="text-xs text-gray-400">(${confScores.price || 0}% confidence)</span>
                    </label>
                    <input type="number" step="0.01" id="editJobPrice" value="${parsedData.price || 0}" 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-2">
                        REG 
                        <span class="text-xs text-gray-400">(${confScores.reg || confScores.reg_number || 0}% confidence)</span>
                    </label>
                    <input type="text" id="editJobReg" value="${escapeHtml(parsedData.reg_number || '')}" 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
        `;

        modal.classList.remove('hidden');
    }

    // Close edit job modal
    function closeEditJobModal() {
        const modal = document.getElementById('editJobModal');
        if (modal) {
            modal.classList.add('hidden');
        }
    }

    // Save job edits
    function saveJobEdits() {
        if (currentEditingJobIndex === null) {
            alert('No job selected for editing');
            return;
        }

        const jobIndex = currentEditingJobIndex;
        const collection = document.getElementById('editJobCollection').value;
        const delivery = document.getElementById('editJobDelivery').value;
        const price = parseFloat(document.getElementById('editJobPrice').value) || 0;
        const reg = document.getElementById('editJobReg').value;

        if (!parsedJobsData || jobIndex >= parsedJobsData.length) {
            alert('Job not found');
            return;
        }

        // Update parsed data
        parsedJobsData[jobIndex].parsedData.collection_address = collection;
        parsedJobsData[jobIndex].parsedData.postcode_delivery = delivery;
        parsedJobsData[jobIndex].parsedData.price = price;
        parsedJobsData[jobIndex].parsedData.reg_number = reg;

        // Update display
        updateJobDisplay(jobIndex);
        closeEditJobModal();
        currentEditingJobIndex = null;
    }

    // Update job display after editing
    function updateJobDisplay(jobIndex) {
        const jobData = parsedJobsData[jobIndex];
        const { parsedData } = jobData;
        const jobNumber = jobIndex + 1;

        // Update the displayed values
        const collectionEl = document.getElementById(`job-${jobNumber}-collection`);
        const deliveryEl = document.getElementById(`job-${jobNumber}-delivery`);
        const priceEl = document.getElementById(`job-${jobNumber}-price`);
        const regEl = document.getElementById(`job-${jobNumber}-reg`);

        if (collectionEl) collectionEl.textContent = parsedData.collection_address || 'Not found';
        if (deliveryEl) deliveryEl.textContent = parsedData.postcode_delivery || 'Not found';
        if (priceEl) priceEl.textContent = `Â£${(parsedData.price || 0).toFixed(2)}`;
        if (regEl) regEl.textContent = parsedData.reg_number || 'Not found';
    }

    // Start route grouping mode
    function startRouteGrouping() {
        if (!currentTasks || currentTasks.length === 0) {
            alert('No tasks to group. Please check tasks first.');
            return;
        }

        routeGroupingMode = true;
        routeGroupingStarted = false; // Not started until Space is pressed
        selectedJobsForRoute = [];
        currentFocusedJobIndex = -1; // No job focused until started
        routeCounter = 0;
        // Use unparsed tasks - parsing will happen later when routes are processed
        ungroupedJobs = currentTasks.map(task => ({
            task: task,
            parsedData: null // Will be parsed later
        }));
        
        // Display jobs for grouping
        displayJobsForGrouping();
        
        // Set up keyboard listeners
        setupRouteGroupingKeyboard();
        
        showScreen('routeGroupingScreen');
    }

    // Display jobs for grouping (smaller cards, grouped by driver)
    function displayJobsForGrouping() {
        const container = document.getElementById('groupingJobsContainer');
        if (!container) return;
        
        // Show or hide the start overlay
        const overlay = document.getElementById('groupingStartOverlay');
        if (overlay) {
            overlay.style.display = routeGroupingStarted ? 'none' : 'flex';
        }
        
        // Clear jobs container (but keep overlay)
        const jobsList = container.querySelector('.jobs-list');
        if (jobsList) {
            jobsList.remove();
        }
        
        const jobsListDiv = document.createElement('div');
        jobsListDiv.className = 'jobs-list';
        container.appendChild(jobsListDiv);
        
        if (ungroupedJobs.length === 0) {
            jobsListDiv.innerHTML = `
                <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 text-center">
                    <h3 class="text-xl font-bold text-white mb-2">All Jobs Grouped!</h3>
                    <p class="text-gray-400 mb-4">You've successfully organized all ${parsedJobsData.length} jobs into ${routeCounter} routes.</p>
                    <button 
                        onclick="finishRouteGrouping()"
                        class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors font-medium"
                    >
                        Finish & Save Routes
                    </button>
                </div>
            `;
            return;
        }
        
        // Sort jobs by driver name so they appear together (but no visual grouping)
        const jobsWithIndices = ungroupedJobs.map((jobData, index) => ({
            jobData,
            originalIndex: index,
            driverName: extractDriverName(jobData.task.name || '')
        }));
        
        // Sort by driver name, then by job number within driver
        jobsWithIndices.sort((a, b) => {
            const nameCompare = a.driverName.localeCompare(b.driverName, undefined, { sensitivity: 'base' });
            if (nameCompare !== 0) return nameCompare;
            
            // If same driver, sort by job number
            const getJobNumber = (taskName) => {
                const match = taskName.match(/\((\d+)\)/);
                return match ? parseInt(match[1], 10) : 999;
            };
            return getJobNumber(a.jobData.task.name || '') - getJobNumber(b.jobData.task.name || '');
        });
        
        // Display jobs in continuous list (grouped by driver but no headers)
        jobsWithIndices.forEach(({ jobData, originalIndex }) => {
            const { task } = jobData;
            const isSelected = selectedJobsForRoute.includes(originalIndex);
            const isFocused = currentFocusedJobIndex === originalIndex;
            
            const jobCard = document.createElement('div');
            let cardClasses = 'bg-[#1a1f24] border-2 rounded-lg p-2 cursor-pointer transition-all mb-2 ';
            if (isSelected) {
                cardClasses += 'border-green-500 bg-[#283039] shadow-lg shadow-green-500/20';
            } else if (isFocused) {
                cardClasses += 'border-blue-500 bg-[#283039] shadow-lg shadow-blue-500/20';
            } else {
                cardClasses += 'border-[#283039] hover:border-gray-600';
            }
            jobCard.className = cardClasses;
            jobCard.dataset.jobIndex = originalIndex;
            jobCard.onclick = () => toggleJobSelection(originalIndex);
            
            // Display only task name since parsing hasn't happened yet
            jobCard.innerHTML = `
                <div class="flex items-center justify-between gap-2">
                    <div class="flex-1 min-w-0">
                        <h4 class="text-sm font-semibold text-white truncate mb-1">${task.name || 'Untitled Task'}</h4>
                        <p class="text-xs text-gray-400">Parsing will occur after routes are created</p>
                    </div>
                    ${isSelected ? '<span class="material-symbols-outlined text-green-500 text-xl flex-shrink-0">check_circle</span>' : ''}
                </div>
            `;
            
            jobsListDiv.appendChild(jobCard);
        });
        
        // Update routes count and enable process button
        const routesCountEl = document.getElementById('routesCount');
        if (routesCountEl) {
            routesCountEl.textContent = routeCounter;
        }
        
        const processBtn = document.getElementById('processRoutesBtn');
        if (processBtn) {
            processBtn.disabled = routeCounter === 0;
        }
    }

    // Toggle job selection
    function toggleJobSelection(jobIndex) {
        const index = selectedJobsForRoute.indexOf(jobIndex);
        if (index > -1) {
            selectedJobsForRoute.splice(index, 1);
        } else {
            selectedJobsForRoute.push(jobIndex);
        }
        displayJobsForGrouping();
    }

    // Group selected jobs into a route
    async function groupSelectedJobs() {
        if (selectedJobsForRoute.length === 0) {
            alert('Please select at least one job to group');
            return;
        }
        
        // Get selected jobs
        const selectedJobs = selectedJobsForRoute.map(idx => ungroupedJobs[idx]);
        
        // Before removing, find the last selected job's position in sorted order
        // This will help us find the next job after grouping
        const sortedIndicesBefore = ungroupedJobs.map((_, idx) => idx).sort((a, b) => {
            const aDriver = extractDriverName(ungroupedJobs[a].task.name || '');
            const bDriver = extractDriverName(ungroupedJobs[b].task.name || '');
            const nameCompare = aDriver.localeCompare(bDriver, undefined, { sensitivity: 'base' });
            if (nameCompare !== 0) return nameCompare;
            const getJobNum = (name) => {
                const match = name.match(/\((\d+)\)/);
                return match ? parseInt(match[1], 10) : 999;
            };
            return getJobNum(ungroupedJobs[a].task.name || '') - getJobNum(ungroupedJobs[b].task.name || '');
        });
        
        // Find the last selected job in the sorted order
        const lastSelectedIndex = Math.max(...selectedJobsForRoute);
        const lastSelectedPosition = sortedIndicesBefore.indexOf(lastSelectedIndex);
        
        // Create route
        routeCounter++;
        const routeId = routeCounter;
        
        // Save route to Firebase (similar to soto-lp)
        await saveRouteToFirebase(routeId, selectedJobs);
        
        // Remove grouped jobs from ungrouped list
        // Sort indices in descending order to remove from end first
        const indicesToRemove = [...selectedJobsForRoute].sort((a, b) => b - a);
        indicesToRemove.forEach(idx => {
            ungroupedJobs.splice(idx, 1);
        });
        
        // Clear selection and move focus to next job
        selectedJobsForRoute = [];
        
        // After removing jobs, find the next job in sorted order
        if (ungroupedJobs.length > 0) {
            // Get sorted indices after removal (same sorting logic)
            const sortedIndicesAfter = ungroupedJobs.map((_, idx) => idx).sort((a, b) => {
                const aDriver = extractDriverName(ungroupedJobs[a].task.name || '');
                const bDriver = extractDriverName(ungroupedJobs[b].task.name || '');
                const nameCompare = aDriver.localeCompare(bDriver, undefined, { sensitivity: 'base' });
                if (nameCompare !== 0) return nameCompare;
                const getJobNum = (name) => {
                    const match = name.match(/\((\d+)\)/);
                    return match ? parseInt(match[1], 10) : 999;
                };
                return getJobNum(ungroupedJobs[a].task.name || '') - getJobNum(ungroupedJobs[b].task.name || '');
            });
            
            // Find the next job: the one that comes after the last selected in sorted order
            // Iterate through the old sorted list starting from after the last selected
            let foundNextJob = false;
            for (let pos = lastSelectedPosition + 1; pos < sortedIndicesBefore.length; pos++) {
                const oldIndex = sortedIndicesBefore[pos];
                // Check if this job wasn't removed
                if (!indicesToRemove.includes(oldIndex)) {
                    // This job still exists - find its new index after removal
                    // Count how many jobs before it were removed
                    let removedBefore = 0;
                    for (const removedIdx of indicesToRemove) {
                        if (removedIdx < oldIndex) {
                            removedBefore++;
                        }
                    }
                    const newIndex = oldIndex - removedBefore;
                    // Find this job in the sorted list by matching task
                    const targetTask = ungroupedJobs[newIndex];
                    if (targetTask) {
                        // Find its position in sortedIndicesAfter
                        const positionInSorted = sortedIndicesAfter.findIndex(idx => {
                            return ungroupedJobs[idx].task.gid === targetTask.task.gid;
                        });
                        if (positionInSorted !== -1) {
                            currentFocusedJobIndex = sortedIndicesAfter[positionInSorted];
                            foundNextJob = true;
                            break;
                        }
                    }
                }
            }
            
            // If no next job found (last selected was at the end), wrap to first
            if (!foundNextJob && sortedIndicesAfter.length > 0) {
                currentFocusedJobIndex = sortedIndicesAfter[0];
            } else if (!foundNextJob) {
                currentFocusedJobIndex = -1;
            }
        } else {
            currentFocusedJobIndex = -1;
        }
        
        // Animate removal
        animateJobGrouping(selectedJobs);
        
        // Update display
        setTimeout(() => {
            displayJobsForGrouping();
        }, 500);
    }

    // Animate job grouping
    function animateJobGrouping(jobs) {
        selectedJobsForRoute.forEach(idx => {
            const jobCard = document.querySelector(`[data-job-index="${idx}"]`);
            if (jobCard) {
                jobCard.style.transition = 'all 0.5s ease-out';
                jobCard.style.opacity = '0';
                jobCard.style.transform = 'scale(0.8) translateY(-20px)';
                setTimeout(() => {
                    if (jobCard.parentNode) {
                        jobCard.parentNode.removeChild(jobCard);
                    }
                }, 500);
            }
        });
    }

    // Save route to Firebase (temporary - will be saved after review)
    async function saveRouteToFirebase(routeId, jobs) {
        // Store route data locally (don't save to Firebase yet - wait for review)
        savedRoutes.push({
            routeId: routeId,
            jobs: jobs,
            createdAt: new Date()
        });
        
        console.log(`Route ${routeId} prepared with ${jobs.length} jobs (will be saved after review)`);
    }

    // Process routes - parse all job details and show review screen
    async function processRoutes() {
        console.log('processRoutes called, savedRoutes:', savedRoutes);
        if (!savedRoutes || savedRoutes.length === 0) {
            alert('No routes to process. Please create some routes first.');
            return;
        }

        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = 'Processing routes and parsing job details...';

        try {
            routeReviewData = [];
            
            // Process each route
            for (const route of savedRoutes) {
                const routeJobs = [];
                let minConfidence = 100;
                
                // Parse each job in the route
                for (const jobData of route.jobs) {
                    const taskText = `${jobData.task.name || ''}\n${jobData.task.notes || ''}`;
                    
                    // Parse job text using Firebase Cloud Function (parsing happens here, not earlier)
                    let parsedData = {
                        collection_address: 'Not found',
                        postcode_delivery: 'Not found',
                        price: 0,
                        reg_number: 'Not found',
                        confidence_scores: {
                            collection: 0,
                            delivery: 0,
                            price: 0,
                            reg: 0
                        },
                        overall_confidence: 0
                    };
                    let confidence = 0;
                    
                    if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                        try {
                            const parseFunction = window.firebase.httpsCallable(window.firebase.functions, 'parseJobText');
                            const result = await parseFunction({
                                rawText: taskText
                            });
                            
                            if (result.data && result.data.success && result.data.parsed_data) {
                                parsedData = result.data.parsed_data;
                                confidence = parsedData.overall_confidence || 50;
                            }
                        } catch (error) {
                            console.warn('Error parsing job text:', error);
                        }
                    }
                    
                    if (confidence < minConfidence) {
                        minConfidence = confidence;
                    }
                    
                    routeJobs.push({
                        task: jobData.task,
                        parsedData: parsedData,
                        confidence: confidence,
                        rawText: taskText
                    });
                }
                
                routeReviewData.push({
                    routeId: route.routeId,
                    jobs: routeJobs,
                    minConfidence: minConfidence,
                    jobCount: routeJobs.length
                });
            }
            
            // Sort by confidence (worst first)
            routeReviewData.sort((a, b) => a.minConfidence - b.minConfidence);
            
            // Display review screen
            displayRouteReview();
            
        } catch (error) {
            console.error('Error processing routes:', error);
            alert('Failed to process routes: ' + error.message);
            showScreen('routeGroupingScreen');
        }
    }

    // Display route review screen
    function displayRouteReview() {
        const container = document.getElementById('routeReviewContainer');
        if (!container) return;
        
        container.innerHTML = '';
        
        // Helper function to get ordinal suffix (1st, 2nd, 3rd, etc.)
        function getOrdinalSuffix(num) {
            const j = num % 10;
            const k = num % 100;
            if (j === 1 && k !== 11) return num + 'st';
            if (j === 2 && k !== 12) return num + 'nd';
            if (j === 3 && k !== 13) return num + 'rd';
            return num + 'th';
        }
        
        // Helper function to get confidence color
        function getConfidenceColor(score) {
            if (score < 60) return 'text-red-400';
            if (score < 80) return 'text-yellow-400';
            return 'text-green-400';
        }
        
        // Helper function to get confidence background color
        function getConfidenceBgColor(score) {
            if (score < 60) return 'bg-red-500/30 border-red-500/50';
            if (score < 80) return 'bg-yellow-500/30 border-yellow-500/50';
            return 'bg-green-500/30 border-green-500/50';
        }
        
        // Function to highlight parsed values in raw text
        function highlightParsedText(rawText, parsedData, confidenceScores) {
            // First escape HTML to prevent XSS
            let highlightedText = rawText
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
            
            const highlights = [];
            
            // Helper to escape special regex characters
            function escapeRegex(str) {
                return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
            
            // Track positions to avoid double-highlighting
            const usedPositions = new Set();
            
            // Highlight REG number
            if (parsedData.reg_number && parsedData.reg_number !== 'Not found' && parsedData.reg_number.trim()) {
                const regScore = confidenceScores.reg || 0;
                const regEscaped = escapeRegex(parsedData.reg_number);
                const regRegex = new RegExp(regEscaped, 'gi');
                const matches = [...highlightedText.matchAll(regRegex)];
                matches.forEach(match => {
                    if (!usedPositions.has(match.index)) {
                        highlights.push({
                            start: match.index,
                            end: match.index + match[0].length,
                            text: match[0],
                            score: regScore
                        });
                        usedPositions.add(match.index);
                    }
                });
            }
            
            // Highlight collection address/postcode
            // ONLY highlight postcodes that come AFTER "Collection" keyword
            if (parsedData.collection_address && parsedData.collection_address !== 'Not found' && parsedData.collection_address.trim()) {
                const collScore = confidenceScores.collection || 0;
                // Remove spaces from parsed postcode to match both "CV37 8QR" and "CV378QR"
                const collNormalized = parsedData.collection_address.replace(/\s+/g, '').toUpperCase();
                
                // Find "Collection" keyword position
                const collectionKeywordIndex = highlightedText.toLowerCase().indexOf('collection');
                
                if (collectionKeywordIndex !== -1) {
                    // Only search in text after "Collection"
                    const textAfterCollection = highlightedText.substring(collectionKeywordIndex + 'collection'.length);
                    
                    // Create regex that matches postcode with or without spaces
                    // Pattern: letters + digits + optional letter + optional space + digit + letters
                    const collPattern = collNormalized.replace(/([A-Z]{1,2})(\d{1,2})([A-Z]?)(\d)([A-Z]{2})/, '$1$2$3\\s?$4$5');
                    const collRegex = new RegExp(collPattern, 'gi');
                    const matches = [...textAfterCollection.matchAll(collRegex)];
                    
                    // Only use the first match (the one after "Collection")
                    if (matches.length > 0) {
                        const match = matches[0];
                        const absoluteIndex = collectionKeywordIndex + 'collection'.length + match.index;
                        if (!usedPositions.has(absoluteIndex)) {
                            highlights.push({
                                start: absoluteIndex,
                                end: absoluteIndex + match[0].length,
                                text: match[0],
                                score: collScore
                            });
                            usedPositions.add(absoluteIndex);
                        }
                    }
                }
            }
            
            // Highlight delivery postcode
            // ONLY highlight postcodes that come AFTER the collection postcode
            if (parsedData.postcode_delivery && parsedData.postcode_delivery !== 'Not found' && parsedData.postcode_delivery.trim()) {
                const delScore = confidenceScores.delivery || 0;
                // Remove spaces from parsed postcode to match both "SK4 2PD" and "SK42PD"
                const delNormalized = parsedData.postcode_delivery.replace(/\s+/g, '').toUpperCase();
                
                // Find collection postcode position first
                let collectionPostcodeEndIndex = -1;
                if (parsedData.collection_address && parsedData.collection_address !== 'Not found') {
                    const collNormalized = parsedData.collection_address.replace(/\s+/g, '').toUpperCase();
                    const collectionKeywordIndex = highlightedText.toLowerCase().indexOf('collection');
                    
                    if (collectionKeywordIndex !== -1) {
                        const textAfterCollection = highlightedText.substring(collectionKeywordIndex + 'collection'.length);
                        const collPattern = collNormalized.replace(/([A-Z]{1,2})(\d{1,2})([A-Z]?)(\d)([A-Z]{2})/, '$1$2$3\\s?$4$5');
                        const collRegex = new RegExp(collPattern, 'gi');
                        const collMatch = collRegex.exec(textAfterCollection);
                        
                        if (collMatch) {
                            collectionPostcodeEndIndex = collectionKeywordIndex + 'collection'.length + collMatch.index + collMatch[0].length;
                        }
                    }
                }
                
                // If we found collection postcode, search after it; otherwise search after "Collection"
                let searchStartIndex = 0;
                if (collectionPostcodeEndIndex >= 0) {
                    searchStartIndex = collectionPostcodeEndIndex;
                } else {
                    const collectionKeywordIndex = highlightedText.toLowerCase().indexOf('collection');
                    if (collectionKeywordIndex !== -1) {
                        searchStartIndex = collectionKeywordIndex + 'collection'.length;
                    }
                }
                
                if (searchStartIndex > 0) {
                    const textAfterCollectionPostcode = highlightedText.substring(searchStartIndex);
                    
                    // Create regex that matches postcode with or without spaces
                    const delPattern = delNormalized.replace(/([A-Z]{1,2})(\d{1,2})([A-Z]?)(\d)([A-Z]{2})/, '$1$2$3\\s?$4$5');
                    const delRegex = new RegExp(delPattern, 'gi');
                    const matches = [...textAfterCollectionPostcode.matchAll(delRegex)];
                    
                    // Only use the first match (the one after collection postcode)
                    if (matches.length > 0) {
                        const match = matches[0];
                        const absoluteIndex = searchStartIndex + match.index;
                        if (!usedPositions.has(absoluteIndex)) {
                            highlights.push({
                                start: absoluteIndex,
                                end: absoluteIndex + match[0].length,
                                text: match[0],
                                score: delScore
                            });
                            usedPositions.add(absoluteIndex);
                        }
                    }
                }
            }
            
            // Highlight price (try multiple formats)
            if (parsedData.price && parsedData.price > 0) {
                const priceScore = confidenceScores.price || 0;
                const priceFormats = [
                    `Â£${parsedData.price}`,
                    `Â£${parsedData.price.toFixed(2)}`,
                    `${parsedData.price}`,
                    `${parsedData.price.toFixed(2)}`
                ];
                
                priceFormats.forEach(priceStr => {
                    const priceEscaped = escapeRegex(priceStr);
                    const priceRegex = new RegExp(priceEscaped, 'gi');
                    const matches = [...highlightedText.matchAll(priceRegex)];
                    matches.forEach(match => {
                        if (!usedPositions.has(match.index)) {
                            highlights.push({
                                start: match.index,
                                end: match.index + match[0].length,
                                text: match[0],
                                score: priceScore
                            });
                            usedPositions.add(match.index);
                        }
                    });
                });
            }
            
            // Sort highlights by position (from end to start to avoid index shifting)
            highlights.sort((a, b) => b.start - a.start);
            
            // Apply highlights
            highlights.forEach(highlight => {
                const bgColor = getConfidenceBgColor(highlight.score);
                const before = highlightedText.substring(0, highlight.start);
                const match = highlightedText.substring(highlight.start, highlight.end);
                const after = highlightedText.substring(highlight.end);
                highlightedText = before + `<span class="px-1 rounded border ${bgColor} font-semibold">${match}</span>` + after;
            });
            
            return highlightedText;
        }
        
        routeReviewData.forEach((routeData, routeIndex) => {
            const routeCard = document.createElement('div');
            routeCard.className = 'bg-[#1a1f24] border border-[#283039] rounded-lg p-6 mb-4';
            
            let jobsHtml = '';
            routeData.jobs.forEach((job, jobIndex) => {
                const jobKey = `${routeData.routeId}-${jobIndex}`;
                const jobNumber = getOrdinalSuffix(jobIndex + 1);
                const confidenceScores = job.parsedData.confidence_scores || {};
                
                // Highlight parsed text
                const highlightedText = highlightParsedText(job.rawText, job.parsedData, confidenceScores);
                
                jobsHtml += `
                    <div class="bg-[#283039] rounded-lg p-4 mb-3">
                        <h4 class="text-sm font-semibold text-white mb-3">${jobNumber} Job</h4>
                        <div class="grid grid-cols-2 gap-6">
                            <!-- Left side: Raw task text with highlights -->
                            <div>
                                <label class="text-xs text-gray-400 mb-2 block">Complete Task Info</label>
                                <div class="bg-[#1a1f24] border border-gray-600 rounded p-4 text-sm text-gray-300 whitespace-pre-wrap max-h-96 overflow-y-auto">
                                    ${highlightedText}
                                </div>
                            </div>
                            <!-- Right side: Editable fields -->
                            <div>
                                <label class="text-xs text-gray-400 mb-2 block">Parsed Details</label>
                                <div class="space-y-3">
                                    <div>
                                        <label class="text-xs text-gray-400 mb-1 block">REG</label>
                                        <div class="flex items-center gap-2">
                                            <input 
                                                type="text" 
                                                id="${jobKey}-reg"
                                                value="${job.parsedData.reg_number || ''}"
                                                class="flex-1 px-3 py-2 bg-[#1a1f24] border border-gray-600 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                            <span class="text-xs ${getConfidenceColor(confidenceScores.reg || 0)} font-semibold">
                                                ${confidenceScores.reg || 0}%
                                            </span>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-xs text-gray-400 mb-1 block">Collection Postcode</label>
                                        <div class="flex items-center gap-2">
                                            <input 
                                                type="text" 
                                                id="${jobKey}-collection"
                                                value="${job.parsedData.collection_address || ''}"
                                                class="flex-1 px-3 py-2 bg-[#1a1f24] border border-gray-600 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                            <span class="text-xs ${getConfidenceColor(confidenceScores.collection || 0)} font-semibold">
                                                ${confidenceScores.collection || 0}%
                                            </span>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-xs text-gray-400 mb-1 block">Delivery Postcode</label>
                                        <div class="flex items-center gap-2">
                                            <input 
                                                type="text" 
                                                id="${jobKey}-delivery"
                                                value="${job.parsedData.postcode_delivery || ''}"
                                                class="flex-1 px-3 py-2 bg-[#1a1f24] border border-gray-600 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                            <span class="text-xs ${getConfidenceColor(confidenceScores.delivery || 0)} font-semibold">
                                                ${confidenceScores.delivery || 0}%
                                            </span>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="text-xs text-gray-400 mb-1 block">Price</label>
                                        <div class="flex items-center gap-2">
                                            <input 
                                                type="number" 
                                                step="0.01"
                                                id="${jobKey}-price"
                                                value="${job.parsedData.price || 0}"
                                                class="flex-1 px-3 py-2 bg-[#1a1f24] border border-gray-600 rounded text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                            <span class="text-xs ${getConfidenceColor(confidenceScores.price || 0)} font-semibold">
                                                ${confidenceScores.price || 0}%
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            routeCard.innerHTML = `
                <div class="flex items-center justify-between mb-4 pb-3 border-b border-[#283039]">
                    <h3 class="text-xl font-bold text-white">
                        Route ${routeIndex + 1}
                    </h3>
                    <div class="flex items-center gap-2">
                        <span class="text-xs text-gray-400">Overall Confidence:</span>
                        <span class="px-3 py-1 rounded text-sm font-semibold ${
                            routeData.minConfidence < 60 ? 'bg-red-500/20 text-red-400' :
                            routeData.minConfidence < 80 ? 'bg-yellow-500/20 text-yellow-400' :
                            'bg-green-500/20 text-green-400'
                        }">
                            ${routeData.minConfidence}%
                        </span>
                    </div>
                </div>
                ${jobsHtml}
            `;
            
            container.appendChild(routeCard);
        });
        
        // Add event listeners to update confidence to 100% when fields are edited
        routeReviewData.forEach((routeData, routeIndex) => {
            routeData.jobs.forEach((job, jobIndex) => {
                const jobKey = `${routeData.routeId}-${jobIndex}`;
                
                // REG field
                const regInput = document.getElementById(`${jobKey}-reg`);
                if (regInput) {
                    const regContainer = regInput.closest('.flex.items-center');
                    const regConfidence = regContainer?.querySelector('span');
                    if (regConfidence) {
                        regInput.addEventListener('input', () => {
                            regConfidence.textContent = '100%';
                            regConfidence.className = 'text-xs text-green-400 font-semibold';
                            // Update the confidence in the data
                            if (!job.parsedData.confidence_scores) {
                                job.parsedData.confidence_scores = {};
                            }
                            job.parsedData.confidence_scores.reg = 100;
                        });
                    }
                }
                
                // Collection field
                const collectionInput = document.getElementById(`${jobKey}-collection`);
                if (collectionInput) {
                    const collectionContainer = collectionInput.closest('.flex.items-center');
                    const collectionConfidence = collectionContainer?.querySelector('span');
                    if (collectionConfidence) {
                        collectionInput.addEventListener('input', () => {
                            collectionConfidence.textContent = '100%';
                            collectionConfidence.className = 'text-xs text-green-400 font-semibold';
                            // Update the confidence in the data
                            if (!job.parsedData.confidence_scores) {
                                job.parsedData.confidence_scores = {};
                            }
                            job.parsedData.confidence_scores.collection = 100;
                        });
                    }
                }
                
                // Delivery field
                const deliveryInput = document.getElementById(`${jobKey}-delivery`);
                if (deliveryInput) {
                    const deliveryContainer = deliveryInput.closest('.flex.items-center');
                    const deliveryConfidence = deliveryContainer?.querySelector('span');
                    if (deliveryConfidence) {
                        deliveryInput.addEventListener('input', () => {
                            deliveryConfidence.textContent = '100%';
                            deliveryConfidence.className = 'text-xs text-green-400 font-semibold';
                            // Update the confidence in the data
                            if (!job.parsedData.confidence_scores) {
                                job.parsedData.confidence_scores = {};
                            }
                            job.parsedData.confidence_scores.delivery = 100;
                        });
                    }
                }
                
                // Price field
                const priceInput = document.getElementById(`${jobKey}-price`);
                if (priceInput) {
                    const priceContainer = priceInput.closest('.flex.items-center');
                    const priceConfidence = priceContainer?.querySelector('span');
                    if (priceConfidence) {
                        priceInput.addEventListener('input', () => {
                            priceConfidence.textContent = '100%';
                            priceConfidence.className = 'text-xs text-green-400 font-semibold';
                            // Update the confidence in the data
                            if (!job.parsedData.confidence_scores) {
                                job.parsedData.confidence_scores = {};
                            }
                            job.parsedData.confidence_scores.price = 100;
                        });
                    }
                }
            });
        });
        
        showScreen('routeReviewScreen');
    }

    // Save all routes to Firebase
    async function saveAllRoutes() {
        if (!currentSession || !currentSession.officeId) {
            alert('Session not available');
            return;
        }

        showScreen('loadingScreen');
        document.getElementById('loadingText').textContent = 'Saving all routes to database...';

        try {
            const officeId = currentSession.officeId;
            
            // Save each route
            for (const routeData of routeReviewData) {
                const savedJobIds = [];
                
                // Save each job
                routeData.jobs.forEach((job, jobIndex) => {
                    const jobKey = `${routeData.routeId}-${jobIndex}`;
                    
                    // Get updated values from inputs
                    const regEl = document.getElementById(`${jobKey}-reg`);
                    const collectionEl = document.getElementById(`${jobKey}-collection`);
                    const deliveryEl = document.getElementById(`${jobKey}-delivery`);
                    const priceEl = document.getElementById(`${jobKey}-price`);
                    
                    // Update parsed data with edited values
                    job.parsedData.reg_number = regEl ? regEl.value : job.parsedData.reg_number;
                    job.parsedData.collection_address = collectionEl ? collectionEl.value : job.parsedData.collection_address;
                    job.parsedData.postcode_delivery = deliveryEl ? deliveryEl.value : job.parsedData.postcode_delivery;
                    job.parsedData.price = priceEl ? parseFloat(priceEl.value) || 0 : job.parsedData.price;
                });
                
                // Save jobs to Firebase
                for (let i = 0; i < routeData.jobs.length; i++) {
                    const job = routeData.jobs[i];
                    const jobKey = `${routeData.routeId}-${i}`;
                    
                    // Get final values
                    const regEl = document.getElementById(`${jobKey}-reg`);
                    const collectionEl = document.getElementById(`${jobKey}-collection`);
                    const deliveryEl = document.getElementById(`${jobKey}-delivery`);
                    const priceEl = document.getElementById(`${jobKey}-price`);
                    
                    const firebaseJobData = {
                        routeId: routeData.routeId,
                        jobNumber: i + 1,
                        rawText: job.rawText,
                        parsedData: {
                            ...job.parsedData,
                            reg_number: regEl ? regEl.value : job.parsedData.reg_number,
                            collection_address: collectionEl ? collectionEl.value : job.parsedData.collection_address,
                            postcode_delivery: deliveryEl ? deliveryEl.value : job.parsedData.postcode_delivery,
                            price: priceEl ? parseFloat(priceEl.value) || 0 : job.parsedData.price
                        },
                        status: 'parsed',
                        createdAt: new Date(),
                        assignedRouteId: routeData.routeId,
                        officeId: officeId
                    };
                    
                    if (window.firebaseAddDoc && window.firebaseCollection && window.firestore) {
                        const docRef = await window.firebaseAddDoc(
                            window.firebaseCollection(window.firestore, 'jobs'),
                            firebaseJobData
                        );
                        savedJobIds.push(docRef.id);
                    }
                }
                
                // Create route summary
                if (window.firebaseAddDoc && window.firebaseCollection && window.firestore) {
                    const routeSummary = {
                        routeId: routeData.routeId,
                        jobCount: routeData.jobs.length,
                        jobs: routeData.jobs.map((job, idx) => ({
                            jobNumber: idx + 1
                        })),
                        createdAt: new Date(),
                        status: 'active',
                        officeId: officeId
                    };
                    
                    await window.firebaseAddDoc(
                        window.firebaseCollection(window.firestore, 'routes'),
                        routeSummary
                    );
                }
            }
            
            // Success - redirect to routes page
            alert(`Successfully saved ${routeReviewData.length} routes!`);
            window.location.href = '/pages/soto-lp.html';
            
        } catch (error) {
            console.error('Error saving routes:', error);
            alert('Failed to save routes: ' + error.message);
            showScreen('routeReviewScreen');
        }
    }

    // Setup keyboard handlers for route grouping
    function setupRouteGroupingKeyboard() {
        const handleKeyPress = (e) => {
            if (!routeGroupingMode) return;
            
            // Handle Space key
            if (e.key === ' ') {
                e.preventDefault();
                if (!routeGroupingStarted) {
                    // Start grouping - focus first job in sorted display order
                    routeGroupingStarted = true;
                    // Find first job in sorted order (same sorting logic as displayJobsForGrouping)
                    const sortedIndices = ungroupedJobs.map((_, idx) => idx).sort((a, b) => {
                        const aDriver = extractDriverName(ungroupedJobs[a].task.name || '');
                        const bDriver = extractDriverName(ungroupedJobs[b].task.name || '');
                        const nameCompare = aDriver.localeCompare(bDriver, undefined, { sensitivity: 'base' });
                        if (nameCompare !== 0) return nameCompare;
                        const getJobNum = (name) => {
                            const match = name.match(/\((\d+)\)/);
                            return match ? parseInt(match[1], 10) : 999;
                        };
                        return getJobNum(ungroupedJobs[a].task.name || '') - getJobNum(ungroupedJobs[b].task.name || '');
                    });
                    currentFocusedJobIndex = sortedIndices.length > 0 ? sortedIndices[0] : -1;
                    displayJobsForGrouping(); // Update display to hide overlay and show focus
                    // Scroll first job into view
                    setTimeout(() => {
                        if (currentFocusedJobIndex >= 0) {
                            const jobCard = document.querySelector(`[data-job-index="${currentFocusedJobIndex}"]`);
                            if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 100);
                } else {
                    // Toggle selection of currently focused job
                    if (currentFocusedJobIndex >= 0 && currentFocusedJobIndex < ungroupedJobs.length) {
                        toggleJobSelection(currentFocusedJobIndex);
                    }
                }
                return;
            }
            
            // Only handle arrow keys and S if grouping has started
            if (!routeGroupingStarted) return;
            
            // Prevent default for arrow keys to stop scrolling
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                e.preventDefault();
                // Handle arrow key navigation (only move cursor, don't select)
                if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                    // Move to next job
                    const sortedIndices = ungroupedJobs.map((_, idx) => idx).sort((a, b) => {
                        const aDriver = extractDriverName(ungroupedJobs[a].task.name || '');
                        const bDriver = extractDriverName(ungroupedJobs[b].task.name || '');
                        const nameCompare = aDriver.localeCompare(bDriver, undefined, { sensitivity: 'base' });
                        if (nameCompare !== 0) return nameCompare;
                        const getJobNum = (name) => {
                            const match = name.match(/\((\d+)\)/);
                            return match ? parseInt(match[1], 10) : 999;
                        };
                        return getJobNum(ungroupedJobs[a].task.name || '') - getJobNum(ungroupedJobs[b].task.name || '');
                    });
                    const currentIndex = sortedIndices.indexOf(currentFocusedJobIndex);
                    const nextIndex = currentIndex < sortedIndices.length - 1 ? sortedIndices[currentIndex + 1] : sortedIndices[0];
                    if (nextIndex !== undefined) {
                        currentFocusedJobIndex = nextIndex;
                        displayJobsForGrouping(); // Update display to show new focus
                        // Scroll into view
                        const jobCard = document.querySelector(`[data-job-index="${nextIndex}"]`);
                        if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                    // Move to previous job
                    const sortedIndices = ungroupedJobs.map((_, idx) => idx).sort((a, b) => {
                        const aDriver = extractDriverName(ungroupedJobs[a].task.name || '');
                        const bDriver = extractDriverName(ungroupedJobs[b].task.name || '');
                        const nameCompare = aDriver.localeCompare(bDriver, undefined, { sensitivity: 'base' });
                        if (nameCompare !== 0) return nameCompare;
                        const getJobNum = (name) => {
                            const match = name.match(/\((\d+)\)/);
                            return match ? parseInt(match[1], 10) : 999;
                        };
                        return getJobNum(ungroupedJobs[a].task.name || '') - getJobNum(ungroupedJobs[b].task.name || '');
                    });
                    const currentIndex = sortedIndices.indexOf(currentFocusedJobIndex);
                    const prevIndex = currentIndex > 0 ? sortedIndices[currentIndex - 1] : sortedIndices[sortedIndices.length - 1];
                    if (prevIndex !== undefined) {
                        currentFocusedJobIndex = prevIndex;
                        displayJobsForGrouping(); // Update display to show new focus
                        const jobCard = document.querySelector(`[data-job-index="${prevIndex}"]`);
                        if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
                return;
            }
            
            // Prevent default only for keys we handle
            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                // Group selected jobs
                if (selectedJobsForRoute.length > 0) {
                    groupSelectedJobs();
                }
            }
        };
        
        // Remove existing listener if any
        if (window.routeGroupingKeyHandler) {
            document.removeEventListener('keydown', window.routeGroupingKeyHandler);
        }
        
        // Add new listener
        window.routeGroupingKeyHandler = handleKeyPress;
        document.addEventListener('keydown', handleKeyPress);
    }

    // Add Enter key handler for instructions screen
    document.addEventListener('DOMContentLoaded', () => {
        const startBtn = document.getElementById('startGroupingBtn');
        if (startBtn) {
            document.addEventListener('keydown', (e) => {
                const instructionsScreen = document.getElementById('routeGroupingInstructionsScreen');
                if (instructionsScreen && !instructionsScreen.classList.contains('hidden') && e.key === 'Enter') {
                    e.preventDefault();
                    startRouteGrouping();
                }
            });
        }
    });

    // Finish route grouping
    function finishRouteGrouping() {
        routeGroupingMode = false;
        if (window.routeGroupingKeyHandler) {
            document.removeEventListener('keydown', window.routeGroupingKeyHandler);
        }
        
        // Enable process routes button
        const processBtn = document.getElementById('processRoutesBtn');
        if (processBtn) {
            processBtn.disabled = false;
        }
        
        // Show message and stay on grouping screen
        alert(`Successfully created ${routeCounter} routes! Click "Process Routes" to review and save.`);
    }

    async function initializePage() {
        try {
            // Check session
            currentSession = await window.sotoSession?.bootstrap();
            if (!currentSession) {
                window.location.href = '/pages/soto-routes-login.html';
                return;
            }
            
            // Load office logo if officeId is available
            if (currentSession.officeId) {
                await loadOfficeLogo(currentSession.officeId);
            }

            // Handle Asana OAuth callback
            handleAsanaCallback();

            // Check if already connected to Asana
            if (currentSession && currentSession.officeId) {
                const tokenKey = `asana_token_${currentSession.officeId}`;
                const existingToken = localStorage.getItem(tokenKey);
                const emailKey = `asana_email_${currentSession.officeId}`;
                const existingEmail = localStorage.getItem(emailKey);
                
                if (existingToken) {
                    // Already connected, try to load projects
                    try {
                        await loadProjects(existingToken);
                        showScreen('projectPickerScreen');
                    } catch (error) {
                        // If loading fails (e.g., token expired), show connection screen
                        console.error('Failed to load projects with existing token:', error);
                        const errorMessage = error.message || error.toString() || '';
                        if (errorMessage.includes('expired') || errorMessage.includes('401') || errorMessage.includes('Unauthorized')) {
                            // Clear expired token
                            localStorage.removeItem(tokenKey);
                            localStorage.removeItem(emailKey);
                            showScreen('asanaConnectionScreen');
                        } else {
                            // Other error - still show connection screen as fallback
                            showScreen('asanaConnectionScreen');
                        }
                    }
                    
                    // Display stored email if available
                    if (existingEmail) {
                        displayAsanaUserEmail(existingEmail);
                    } else {
                        // Fetch user info if email not stored
                        await fetchAndDisplayAsanaUser(existingToken);
                    }
                } else {
                    // Not connected, show connection screen
                    showScreen('asanaConnectionScreen');
                }
            } else {
                showScreen('asanaConnectionScreen');
            }
        } catch (error) {
            console.error('Failed to initialize page:', error);
            window.location.href = '/pages/soto-routes-login.html';
        }
    }

    function toggleProfileDropdown() {
        const dropdown = document.getElementById('profileDropdown');
        dropdown.classList.toggle('hidden');
    }

    function showChangePassword() {
        // TODO: Implement change password
        console.log('Change password clicked');
    }

    // Settings functions
    function showSettings() {
        const modal = document.getElementById('settingsModal');
        const dropdown = document.getElementById('profileDropdown');
        dropdown.classList.add('hidden');
        modal.classList.remove('hidden');
        
        // Load current setting value
        const useAsanaApi = window.sotoSettings?.getUseAsanaApiForRoutes() || false;
        const toggle = document.getElementById('useAsanaApiToggle');
        if (toggle) {
            toggle.checked = useAsanaApi;
        }
    }

    function hideSettings() {
        document.getElementById('settingsModal').classList.add('hidden');
    }

    function handleAsanaApiToggle(checked) {
        if (window.sotoSettings) {
            window.sotoSettings.setUseAsanaApiForRoutes(checked);
            console.log('Asana API for routes setting updated:', checked);
        }
    }

    function viewUsage() {
        // TODO: Implement view usage
        console.log('View usage clicked');
    }

    async function logout() {
        try {
            await window.sotoSession?.logout();
        } catch (error) {
            console.warn('Logout error:', error);
        }
        window.location.href = '/pages/soto-routes-login.html';
    }

    async function showNotifications() {
        const dropdown = document.getElementById('notificationDropdown');
        if (!dropdown) return;
        
        dropdown.classList.toggle('hidden');
        
        if (!dropdown.classList.contains('hidden')) {
            // TODO: Load notifications
            console.log('Loading notifications...');
        }
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        const profileDropdown = document.getElementById('profileDropdown');
        const profileButton = e.target.closest('button[onclick="toggleProfileDropdown()"]');
        if (profileDropdown && !profileDropdown.contains(e.target) && !profileButton) {
            profileDropdown.classList.add('hidden');
        }

        const notificationDropdown = document.getElementById('notificationDropdown');
        const notificationButton = e.target.closest('button[onclick="showNotifications()"]');
        if (notificationDropdown && !notificationDropdown.contains(e.target) && !notificationButton) {
            notificationDropdown.classList.add('hidden');
        }
    });

    // Make functions globally available
    window.toggleProfileDropdown = toggleProfileDropdown;
    window.showChangePassword = showChangePassword;
    window.showSettings = showSettings;
    window.hideSettings = hideSettings;
    window.handleAsanaApiToggle = handleAsanaApiToggle;
    window.viewUsage = viewUsage;
    window.logout = logout;
    window.showNotifications = showNotifications;
    window.checkTasksForDate = checkTasksForDate;
    window.processJobs = processJobs;
    window.editJob = editJob;
    window.closeEditJobModal = closeEditJobModal;
    window.saveJobEdits = saveJobEdits;
    window.selectProject = selectProject;
    window.startRouteGrouping = startRouteGrouping;
    window.finishRouteGrouping = finishRouteGrouping;
    window.processRoutes = processRoutes;
    window.saveAllRoutes = saveAllRoutes;

    // Initialize on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializePage);
    } else {
        initializePage();
    }
</script>

<!-- Settings Modal -->
<div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
    <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-md">
        <div class="flex justify-between items-center mb-4">
            <h3 class="text-xl font-bold text-white">Settings</h3>
            <button onclick="hideSettings()" class="text-gray-400 hover:text-white">
                <span class="material-symbols-outlined">close</span>
            </button>
        </div>
        
        <div class="space-y-4">
            <div class="flex items-center justify-between py-3 border-b border-[#283039]">
                <div class="flex-1">
                    <label for="useAsanaApiToggle" class="block text-sm font-medium text-white mb-1">
                        Use Asana API for route input
                    </label>
                    <p class="text-xs text-gray-400">When enabled, routes button will redirect to automatic routes page</p>
                </div>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input 
                        type="checkbox" 
                        id="useAsanaApiToggle" 
                        class="sr-only peer"
                        onchange="handleAsanaApiToggle(this.checked)"
                    >
                    <div class="w-11 h-6 bg-[#283039] peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>
        </div>
        
        <div class="mt-6 flex justify-end">
            <button 
                onclick="hideSettings()"
                class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors font-medium"
            >
                Close
            </button>
        </div>
    </div>
</div>
</body>
</html>

