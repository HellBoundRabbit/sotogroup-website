<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
    <link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/logos/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/logos/favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="/assets/logos/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/assets/logos/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/logos/apple-touch-icon.png">
    <link rel="stylesheet" href="/assets/css/responsive-nav.css">
<title>SOTO Routes - Logistics Planning</title>
    <link href="data:image/x-icon;base64," rel="icon" type="image/x-icon"/>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/mobile-nav.js"></script>
    <script src="/js/session-manager.js"></script>
    <script src="/js/settings.js"></script>
    <script>
        tailwind.config = {
            plugins: {
                forms: {},
                containerQueries: {}
            }
        }
    </script>
    <!-- Google Maps API -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDTbiSXo9tg1Tx8SlZCZKsR_R0zIQ4N1VA&libraries=geometry&callback=initGoogleMaps"></script>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, getDoc, doc, query, orderBy, limit, where, setDoc, updateDoc, deleteDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.firebase = { functions: functions, httpsCallable: httpsCallable };
        window.firestore = db;
        window.auth = auth;
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseGetDoc = getDoc;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseDeleteDoc = deleteDoc;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.signInWithEmailAndPassword = signInWithEmailAndPassword;
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
        window.signOut = signOut;
        window.onAuthStateChanged = onAuthStateChanged;
        
        console.log('Firebase initialized successfully!');
        
        // Hide loading overlay after Firebase is ready and page content loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                    loadingOverlay.style.transition = 'opacity 0.3s ease-out';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 300);
                }
            }, 500);
        });
    </script>
    <style type="text/tailwindcss">
        :root {
            --primary-color: #0d7ff2;
            --success-color: #22c55e;
        }
        
        /* Loading spinner */
        .spinner-wrapper {
            width: 64px;
            height: 64px;
            position: relative;
        }
        .spinner {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            position: absolute;
            top: 0;
            left: 0;
            animation: spinning82341 1.7s linear infinite;
            filter: blur(1px);
        }
        .spinner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-image: linear-gradient(rgb(186, 66, 255) 35%, rgb(0, 225, 255));
            box-shadow: 0px -5px 20px 0px rgb(186, 66, 255), 0px 5px 20px 0px rgb(0, 225, 255);
        }
        .spinner1 {
            background-color: rgb(36, 36, 36);
            width: 52px;
            height: 52px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }
        @keyframes spinning82341 {
            to {
                transform: rotate(360deg);
            }
        }
    </style>
</head>
<body class="bg-[#111418] text-white" style='font-family: Inter, "Noto Sans", sans-serif;'>
    <div class="relative flex h-auto min-h-screen w-full flex-col dark group/design-root overflow-x-hidden">
        <div class="flex h-full grow flex-col">
        <header class="relative flex items-center justify-between whitespace-nowrap border-b border-solid border-b-[#283039] px-6 py-3" data-soto-nav>
            <div class="flex items-center gap-4">
                <div class="size-8 text-[var(--primary-color)]">
                    <svg fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                        <path d="M13.8261 17.4264C16.7203 18.1174 20.2244 18.5217 24 18.5217C27.7756 18.5217 31.2797 18.1174 34.1739 17.4264C36.9144 16.7722 39.9967 15.2331 41.3563 14.1648L24.8486 40.6391C24.4571 41.267 23.5429 41.267 23.1514 40.6391L6.64374 14.1648C8.00331 15.2331 11.0856 16.7722 13.8261 17.4264Z" fill="currentColor"></path>
                        <path clip-rule="evenodd" d="M39.998 12.236C39.9944 12.2537 39.9875 12.2845 39.9748 12.3294C39.9436 12.4399 39.8949 12.5741 39.8346 12.7175C39.8168 12.7597 39.7989 12.8007 39.7813 12.8398C38.5103 13.7113 35.9788 14.9393 33.7095 15.4811C30.9875 16.131 27.6413 16.5217 24 16.5217C20.3587 16.5217 17.0125 16.131 14.2905 15.4811C12.0012 14.9346 9.44505 13.6897 8.18538 12.8168C8.17384 12.7925 8.16216 12.767 8.15052 12.7408C8.09919 12.6249 8.05721 12.5114 8.02977 12.411C8.00356 12.3152 8.00039 12.2667 8.00004 12.2612C8.00004 12.261 8 12.2607 8.00004 12.2612C8.00004 12.2359 8.0104 11.9233 8.68485 11.3686C9.34546 10.8254 10.4222 10.2469 11.9291 9.72276C14.9242 8.68098 19.1919 8 24 8C28.8081 8 33.0758 8.68098 36.0709 9.72276C37.5778 10.2469 38.6545 10.8254 39.3151 11.3686C39.9006 11.8501 39.9857 12.1489 39.998 12.236ZM4.95178 15.2312L21.4543 41.6973C22.6288 43.5809 25.3712 43.5809 26.5457 41.6973L43.0534 15.223C43.0709 15.1948 43.0878 15.1662 43.104 15.1371L41.3563 14.1648C43.104 15.1371 43.1038 15.1374 43.104 15.1371L43.1051 15.135L43.1065 15.1325L43.1101 15.1261L43.1199 15.1082C43.1276 15.094 43.1377 15.0754 43.1497 15.0527C43.1738 15.0075 43.2062 14.9455 43.244 14.8701C43.319 14.7208 43.4196 14.511 43.5217 14.2683C43.6901 13.8679 44 13.0689 44 12.2609C44 10.5573 43.003 9.22254 41.8558 8.2791C40.6947 7.32427 39.1354 6.55361 37.385 5.94477C33.8654 4.72057 29.133 4 24 4C18.867 4 14.1346 4.72057 10.615 5.94478C8.86463 6.55361 7.30529 7.32428 6.14419 8.27911C4.99695 9.22255 3.99999 10.5573 3.99999 12.2609C3.99999 13.1275 4.29264 13.9078 4.49321 14.3607C4.60375 14.6102 4.71348 14.8196 4.79687 14.9689C4.83898 15.0444 4.87547 15.1065 4.9035 15.1529C4.91754 15.1762 4.92954 15.1957 4.93916 15.2111L4.94662 15.223L4.95178 15.2312ZM35.9868 18.996L24 38.22L12.0131 18.996C12.4661 19.1391 12.9179 19.2658 13.3617 19.3718C16.4281 20.1039 20.0901 20.5217 24 20.5217C27.9099 20.5217 31.5719 20.1039 34.6383 19.3718C35.082 19.2658 35.5339 19.1391 35.9868 18.996Z" fill="currentColor" fill-rule="evenodd"></path>
                    </svg>
                </div>
                <h2 class="text-xl font-bold">SOTO Routes</h2>
            </div>
            <nav class="flex flex-1 justify-center gap-2" data-soto-nav-links>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/soto-lp.html">Routes</a>
                <a class="bg-[#283039] text-white text-xs font-medium rounded-md px-3 py-2" href="#">Optimisation</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/drivers.html">Drivers</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/availability.html">Availability</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/expenses.html">Expenses</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/wait-times.html">Wait Times</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="/pages/messages.html">Messages</a>
                <a class="text-xs font-medium rounded-md px-3 py-2 hover:bg-[#283039] transition-colors" href="#">Authorization</a>
            </nav>
            <div class="flex items-center gap-4">
                <button type="button" class="mobile-nav-toggle" data-soto-nav-toggle aria-label="Toggle navigation" aria-expanded="false">
                    <span class="material-symbols-outlined text-xl">menu</span>
                </button>
                <div class="relative">
                    <button class="flex items-center justify-center rounded-full h-10 w-10 bg-[#283039] hover:bg-[#3a444e] transition-colors relative" onclick="showNotifications()">
                        <span class="material-symbols-outlined text-xl">notifications</span>
                        <!-- Notification Badge -->
                        <span class="notification-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center font-bold hidden">0</span>
                    </button>
                    <!-- Notifications Dropdown -->
                    <div id="notificationDropdown" class="hidden absolute right-0 mt-2 w-80 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto">
                        <div class="px-4 py-3 border-b border-[#283039]">
                            <h3 class="text-white font-semibold text-sm">Notifications</h3>
                        </div>
                        <div id="notificationsList" class="max-h-64 overflow-y-auto">
                            <!-- Notifications will be loaded here -->
                        </div>
                    </div>
                </div>
                <div class="relative">
                    <button onclick="toggleProfileDropdown()" class="flex items-center justify-center rounded-full size-10 bg-black overflow-hidden hover:ring-2 hover:ring-blue-500 transition-all cursor-pointer">
                        <img id="officeLogoImg" src="/assets/logos/favicon.svg" alt="Office Logo" class="w-full h-full object-cover" onerror="this.src='/assets/logos/favicon.svg'">
                    </button>
                    <!-- Profile Dropdown -->
                    <div id="profileDropdown" class="hidden absolute right-0 mt-2 w-48 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50">
                        <button onclick="showSettings()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors rounded-t-lg">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">settings</span>
                            Settings
                        </button>
                        <button onclick="showChangePassword()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">lock</span>
                            Change Password
                        </button>
                        <button onclick="viewUsage()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">calendar_month</span>
                            View Usage
                        </button>
                        <button onclick="logout()" class="block w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-[#283039] transition-colors rounded-b-lg">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">logout</span>
                            Logout
                        </button>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="fixed inset-0 bg-[#0f1419] bg-opacity-95 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="spinner-wrapper mx-auto mb-4">
                    <div class="spinner"></div>
                    <div class="spinner1"></div>
                </div>
                <p class="text-white text-lg font-semibold">Loading Optimisation...</p>
                <p class="text-gray-400 text-sm mt-1">Please wait</p>
            </div>
        </div>

        <!-- Port Jobs Modal Overlay -->
        <div id="portJobsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 max-w-4xl w-full mx-4 max-h-[90vh] overflow-y-auto relative">
                <!-- Close Button -->
                <button onclick="closePortJobsModal()" class="absolute top-4 right-4 text-gray-400 hover:text-white transition-colors">
                    <span class="material-symbols-outlined text-2xl">close</span>
                </button>
                
                <!-- Manual Entry Screen -->
                <div id="manualEntryScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Manual Job Entry</h2>
                        <p class="text-gray-400 text-sm">Paste job details below and they will be automatically parsed</p>
                    </div>
                    <div class="mb-4">
                        <label for="manualJobText" class="block text-sm font-medium text-gray-300 mb-2">Job Details</label>
                        <textarea 
                            id="manualJobText" 
                            rows="10"
                            class="w-full px-4 py-3 bg-[#283039] border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono"
                            placeholder="Paste job details here...&#10;&#10;Example:&#10;Collection: BH15 2AL&#10;Delivery: B8 2SL&#10;Price: Â£84.60&#10;REG: KS17NCN"
                        ></textarea>
                    </div>
                    <div class="flex gap-3">
                        <button 
                            onclick="processManualJob()"
                            class="flex-1 bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                        >
                            <span class="material-symbols-outlined">arrow_upward</span>
                            Parse & Add Job
                        </button>
                        <button 
                            onclick="closePortJobsModal()"
                            class="px-6 py-3 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors font-medium"
                        >
                            Cancel
                        </button>
                    </div>
                    <div id="manualJobResults" class="mt-4 space-y-2">
                        <!-- Parsed job results will appear here -->
                    </div>
                </div>
                
                <!-- Asana Connection Screen -->
                <div id="asanaConnectionScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Connect to Asana</h2>
                        <p class="text-gray-400 text-sm">Connect your Asana account to import routes automatically</p>
                    </div>
                    <button 
                        id="connectAsanaBtn" 
                        onclick="connectToAsana()"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                    >
                        <span class="material-symbols-outlined">link</span>
                        Connect to Asana
                    </button>
                    <button 
                        onclick="showManualEntry()"
                        class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                    >
                        Use Manual Entry Instead
                    </button>
                </div>


                <!-- Project Picker Screen -->
                <div id="projectPickerScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Select Project</h2>
                        <p class="text-gray-400 text-sm">Choose the Asana project to import routes from</p>
                    </div>
                    <div class="mb-4">
                        <label for="projectSelect" class="block text-sm font-medium text-gray-300 mb-2">Project</label>
                        <select 
                            id="projectSelect" 
                            class="w-full px-4 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                            required
                        >
                            <option value="">Loading projects...</option>
                        </select>
                    </div>
                    <button 
                        id="selectProjectBtn" 
                        onclick="selectProject()"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                    >
                        <span class="material-symbols-outlined">arrow_forward</span>
                        Continue
                    </button>
                    <button 
                        onclick="closePortJobsModal()"
                        class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                    >
                        Cancel
                    </button>
                </div>

                <!-- Day Picker Screen -->
                <div id="dayPickerScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Select Date</h2>
                        <p class="text-gray-400 text-sm" id="selectedProjectText">Choose the date to import routes from Asana</p>
                    </div>
                    <div class="mb-4">
                        <label for="routeDate" class="block text-sm font-medium text-gray-300 mb-2">Date</label>
                        <input 
                            type="date" 
                            id="routeDate" 
                            class="w-full px-4 py-2 bg-[#283039] border border-gray-600 rounded-md text-white focus:outline-none focus:ring-2 focus:ring-blue-500"
                            required
                        >
                    </div>
                    <button 
                        id="checkTasksBtn" 
                        onclick="checkTasksForDate()"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                    >
                        <span class="material-symbols-outlined">search</span>
                        Check Tasks
                    </button>
                    <button 
                        onclick="showScreen('projectPickerScreen')"
                        class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                    >
                        Back
                    </button>
                </div>

                <!-- Tasks Count Screen -->
                <div id="tasksCountScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Tasks Found</h2>
                        <p class="text-gray-400 text-sm" id="selectedDateText"></p>
                    </div>
                    <div class="mb-6 text-center">
                        <div class="text-4xl font-bold text-blue-500 mb-2" id="tasksCount">0</div>
                        <p class="text-gray-400 text-sm mb-4">tasks found for this date</p>
                    </div>
                    <div id="taskTitlesList" class="mb-6 max-h-64 overflow-y-auto space-y-2">
                        <!-- Task titles will be displayed here -->
                    </div>
                    <button 
                        onclick="processJobs()"
                        class="w-full bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                    >
                        <span class="material-symbols-outlined">arrow_forward</span>
                        Process Jobs
                    </button>
                    <button 
                        onclick="showScreen('dayPickerScreen')"
                        class="w-full mt-3 bg-[#283039] hover:bg-[#3a444e] text-white px-6 py-3 rounded-lg transition-colors font-medium"
                    >
                        Back
                    </button>
                </div>

                <!-- Route Grouping Instructions Screen -->
                <div id="routeGroupingInstructionsScreen" class="hidden">
                    <div class="text-center mb-6">
                        <h2 class="text-2xl font-bold text-white mb-2">Route Grouping Instructions</h2>
                        <p class="text-gray-400 text-sm">Learn how to group jobs into routes</p>
                    </div>
                    <div class="space-y-4 mb-6">
                        <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold">1</div>
                            <div>
                                <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">Space</kbd> to start</h3>
                                <p class="text-gray-400 text-sm">Begin grouping jobs into routes</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-blue-600 flex items-center justify-center text-white font-bold">2</div>
                            <div>
                                <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">Space</kbd> on jobs to select <span class="text-yellow-400">(in order)</span></h3>
                                <p class="text-gray-400 text-sm">Select jobs in the order you want them in the route. Selected jobs will show numbers (1, 2, 3...) indicating their position.</p>
                            </div>
                        </div>
                        <div class="flex items-start gap-4 bg-[#283039] rounded-lg p-4">
                            <div class="flex-shrink-0 w-10 h-10 rounded-full bg-green-600 flex items-center justify-center text-white font-bold">3</div>
                            <div>
                                <h3 class="text-white font-semibold mb-2">Press <kbd class="px-2 py-1 bg-[#1a1f24] rounded text-sm">S</kbd> to group selected jobs</h3>
                                <p class="text-gray-400 text-sm">Selected jobs will be grouped into a route</p>
                            </div>
                        </div>
                    </div>
                    <button 
                        id="startGroupingBtn"
                        onclick="startRouteGrouping()"
                        class="w-full bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2"
                    >
                        <span class="material-symbols-outlined">play_arrow</span>
                        Start Grouping
                    </button>
                </div>

                <!-- Route Grouping Screen -->
                <div id="routeGroupingScreen" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <h2 class="text-xl font-bold text-white">Group Jobs into Routes</h2>
                        <div class="flex items-center gap-4">
                            <span class="text-sm text-gray-400">Routes Created: <span id="routesCount" class="text-white font-bold">0</span></span>
                            <button 
                                id="processRoutesBtn"
                                onclick="processRoutes()"
                                disabled
                                class="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-4 py-2 rounded-lg transition-colors font-medium"
                            >
                                Process Routes
                            </button>
                        </div>
                    </div>
                    <div id="groupingStartOverlay" class="absolute inset-0 bg-[#1a1f24] bg-opacity-95 flex items-center justify-center z-10 rounded-lg">
                        <div class="text-center">
                            <p class="text-white text-lg font-semibold mb-2">Press <kbd class="px-3 py-1 bg-[#283039] rounded">Space</kbd> to start</p>
                            <p class="text-gray-400 text-sm">Begin selecting jobs to group into routes</p>
                        </div>
                    </div>
                    <div id="groupingJobsContainer" class="relative max-h-96 overflow-y-auto">
                        <!-- Jobs will be displayed here -->
                    </div>
                </div>

                <!-- Loading Screen -->
                <div id="loadingScreen" class="hidden">
                    <div class="text-center">
                        <div class="spinner-wrapper mx-auto mb-4">
                            <div class="spinner"></div>
                            <div class="spinner1"></div>
                        </div>
                        <p class="text-white text-lg font-semibold" id="loadingText">Loading...</p>
                    </div>
                </div>
            </div>
        </div>
        
        <main class="flex-1 px-6 py-4">
            <div class="max-w-6xl mx-auto">
                <div class="flex justify-between items-center mb-4">
                    <h1 class="text-2xl font-bold tracking-tight">Optimisation</h1>
                    <div class="flex items-center gap-3">
                        <button onclick="portJobs()" class="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-bold flex items-center gap-2">
                            <span class="material-symbols-outlined text-sm">upload</span>
                            Port Jobs
                        </button>
                        <button onclick="showOptimiseSettings()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-bold">
                            <span class="truncate">Optimise</span>
                        </button>
                        <button onclick="deleteAllRoutes()" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-bold flex items-center gap-2">
                            <span class="material-symbols-outlined text-sm">delete</span>
                            Delete All Routes
                        </button>
                    </div>
                </div>
                
                <!-- Routes Requiring Authorization Section -->
                <div id="authorization-routes-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-yellow-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">warning</span>
                        Routes Requiring Authorization
                    </h2>
                    <p class="text-sm text-gray-400 mb-4">These routes require driving to a train station as no direct transit is available.</p>
                    <div id="authorization-routes-container" class="grid grid-cols-1 gap-4">
                        <!-- Routes requiring authorization will be displayed here -->
                    </div>
                </div>

                <!-- Jobless Drivers Section -->
                <div id="jobless-drivers-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-red-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">person_off</span>
                        Jobless Drivers
                    </h2>
                    <div id="jobless-drivers-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <!-- Unassigned drivers will be displayed here -->
                    </div>
                </div>

                <!-- Driverless Routes Section -->
                <div id="driverless-routes-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-orange-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">route</span>
                        Driverless Routes
                    </h2>
                    <div id="driverless-routes-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <!-- Unassigned routes will be displayed here -->
                    </div>
                </div>

                <!-- Assigned Routes Section -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4" id="routes-container">
                        <!-- Routes will be dynamically loaded here -->
                        <div id="no-routes-message" class="col-span-full text-center py-12 text-gray-400">
                            <div class="spinner-wrapper mx-auto mb-4" style="width: 32px; height: 32px;">
                                <div class="spinner" style="width: 32px; height: 32px;"></div>
                                <div class="spinner1" style="width: 26px; height: 26px;"></div>
                            </div>
                            <p class="text-lg mb-2">Loading routes...</p>
                            <p class="text-sm">Please wait while we load your saved routes</p>
                        </div>
                        
                        <!-- Demo Route 1 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-1" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-1-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-1-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">M1 4AN</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-1-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-1-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-1-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-1-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>

                        <!-- Demo Route 2 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-2" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-2-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-2-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">B775JA</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-2-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-2-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-2-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-2-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>

                        <!-- Demo Route 3 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-3" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-3-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-3-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">LS1 4DY</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-3-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-3-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-3-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-3-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>
            </div>
        </main>
        </div>
    </div>

    <script>
        // Check authentication first
        async function checkAuthentication() {
            try {
                const session = await window.sotoSession.bootstrap(['office', 'admin']);
                if (!session) {
                window.location.href = '/pages/soto-routes-login.html';
                return false;
            }

                currentSession = session;
                currentUserId = session.uid;

                try {
                    const userRef = window.firebaseDoc(window.firestore, 'users', session.uid);
                    const userDoc = await window.firebaseGetDoc(userRef);
                    if (userDoc.exists()) {
                        currentUser = { uid: session.uid, ...session, ...userDoc.data() };
                    } else {
                        currentUser = { uid: session.uid, ...session };
                    }
                } catch (userError) {
                    console.warn('Unable to load user profile, using session only:', userError);
                    currentUser = { uid: session.uid, ...session };
                }

            return true;
            } catch (error) {
                console.error('Authentication failed:', error);
                window.location.href = '/pages/soto-routes-login.html';
                return false;
            }
        }

        // CloudKit functionality removed
        let savedRoutes = [];
        let currentSession = null;
        let currentUser = null;
        let currentUserId = 'default_user'; // Placeholder for user authentication
        const getCurrentOfficeId = () => currentUser?.officeId || currentSession?.officeId || null;

        // Driver data loaded from Firebase
        let drivers = [];

        // Port Jobs functionality
        const ASANA_API_BASE = 'https://app.asana.com/api/1.0';
        let currentTasks = [];
        let selectedDate = null;
        let selectedProjectId = null;
        let selectedProjectName = null;
        let availableProjects = [];
        let parsedJobsData = [];
        let routeGroupingMode = false;
        let selectedJobsForRoute = [];
        let currentFocusedJobIndex = -1;
        let routeGroupingStarted = false;
        let routeCounter = 0;
        let ungroupedJobs = [];
        let savedRoutesForPort = [];
        let routeReviewData = [];

        // Port Jobs modal functions
        function portJobs() {
            const modal = document.getElementById('portJobsModal');
            if (!modal) return;
            
            modal.classList.remove('hidden');
            
            // Check if Asana API setting is enabled
            const useAsanaApi = window.sotoSettings?.getUseAsanaApiForRoutes() || false;
            
            if (!useAsanaApi) {
                // Asana API disabled - show manual entry
                showScreen('manualEntryScreen');
                // Clear any previous results
                document.getElementById('manualJobResults').innerHTML = '';
                document.getElementById('manualJobText').value = '';
                return;
            }
            
            // Asana API enabled - check if connected
            if (currentSession && currentSession.officeId) {
                const tokenKey = `asana_token_${currentSession.officeId}`;
                const existingToken = localStorage.getItem(tokenKey);
                
                if (existingToken) {
                    // Already connected, show project picker
                    loadProjects(existingToken).catch(() => {
                        // If loading fails, show connection screen
                        showScreen('asanaConnectionScreen');
                    });
                } else {
                    // Not connected, show connection screen
                    showScreen('asanaConnectionScreen');
                }
            } else {
                showScreen('asanaConnectionScreen');
            }
        }

        function closePortJobsModal() {
            const modal = document.getElementById('portJobsModal');
            if (modal) {
                modal.classList.add('hidden');
            }
            // Clean up route grouping
            routeGroupingMode = false;
            if (window.routeGroupingKeyHandler) {
                document.removeEventListener('keydown', window.routeGroupingKeyHandler);
            }
        }

        function showScreen(screenId) {
            const screens = ['asanaConnectionScreen', 'manualEntryScreen', 'projectPickerScreen', 'dayPickerScreen', 'tasksCountScreen', 'routeGroupingInstructionsScreen', 'routeGroupingScreen', 'loadingScreen'];
            screens.forEach(id => {
                const screen = document.getElementById(id);
                if (screen) {
                    screen.classList.add('hidden');
                }
            });
            
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.remove('hidden');
            }
        }

        function showManualEntry() {
            showScreen('manualEntryScreen');
        }

        // Manual job entry variables
        let manualJobCounter = 0;
        let manualJobs = [];

        async function processManualJob() {
            const jobText = document.getElementById('manualJobText').value.trim();
            if (!jobText) {
                alert('Please enter job details');
                return;
            }

            const resultsContainer = document.getElementById('manualJobResults');
            const jobItem = document.createElement('div');
            jobItem.className = 'bg-[#283039] rounded-lg p-4';
            jobItem.id = `manual-job-${manualJobCounter}`;
            jobItem.innerHTML = `
                <div class="flex items-center justify-between mb-2">
                    <span class="text-sm font-semibold text-white">Job ${manualJobCounter + 1}</span>
                    <span class="text-xs text-gray-400">Processing...</span>
                </div>
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div>
                        <span class="text-gray-400">Collection:</span>
                        <span class="text-green-400 ml-2" id="manual-job-${manualJobCounter}-collection">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Delivery:</span>
                        <span class="text-red-400 ml-2" id="manual-job-${manualJobCounter}-delivery">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">Price:</span>
                        <span class="text-white ml-2" id="manual-job-${manualJobCounter}-price">-</span>
                    </div>
                    <div>
                        <span class="text-gray-400">REG:</span>
                        <span class="text-white ml-2" id="manual-job-${manualJobCounter}-reg">-</span>
                    </div>
                </div>
            `;
            resultsContainer.appendChild(jobItem);

            try {
                // Parse the job text
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    const parseFunction = window.firebase.httpsCallable(window.firebase.functions, 'parseJobText');
                    const result = await parseFunction({
                        rawText: jobText
                    });

                    if (result.data && result.data.success && result.data.parsed_data) {
                        const parsedData = result.data.parsed_data;
                        
                        // Update display
                        document.getElementById(`manual-job-${manualJobCounter}-collection`).textContent = parsedData.collection_address || 'Not found';
                        document.getElementById(`manual-job-${manualJobCounter}-delivery`).textContent = parsedData.postcode_delivery || 'Not found';
                        document.getElementById(`manual-job-${manualJobCounter}-price`).textContent = `Â£${(parsedData.price || 0).toFixed(2)}`;
                        document.getElementById(`manual-job-${manualJobCounter}-reg`).textContent = parsedData.reg_number || 'Not found';

                        // Store job
                        manualJobs.push({
                            rawText: jobText,
                            parsedData: parsedData,
                            jobNumber: manualJobCounter + 1
                        });

                        // Clear textarea
                        document.getElementById('manualJobText').value = '';
                        manualJobCounter++;

                        // Update status
                        const statusEl = jobItem.querySelector('.text-gray-400');
                        if (statusEl) {
                            statusEl.textContent = 'Parsed â';
                            statusEl.className = 'text-xs text-green-400';
                        }

                        // Add save button if this is the first job or if we have multiple jobs
                        if (manualJobs.length > 0) {
                            const saveButton = document.getElementById('saveManualJobsBtn');
                            if (!saveButton) {
                                const saveBtn = document.createElement('button');
                                saveBtn.id = 'saveManualJobsBtn';
                                saveBtn.onclick = saveManualJobs;
                                saveBtn.className = 'w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg transition-colors font-medium flex items-center justify-center gap-2';
                                saveBtn.innerHTML = `
                                    <span class="material-symbols-outlined">save</span>
                                    Save ${manualJobs.length} Job${manualJobs.length === 1 ? '' : 's'} to Routes
                                `;
                                resultsContainer.appendChild(saveBtn);
                            } else {
                                saveButton.innerHTML = `
                                    <span class="material-symbols-outlined">save</span>
                                    Save ${manualJobs.length} Job${manualJobs.length === 1 ? '' : 's'} to Routes
                                `;
                            }
                        }
                    } else {
                        throw new Error('Failed to parse job');
                    }
                } else {
                    throw new Error('Firebase functions not available');
                }
            } catch (error) {
                console.error('Error parsing manual job:', error);
                const statusEl = jobItem.querySelector('.text-gray-400');
                if (statusEl) {
                    statusEl.textContent = 'Error parsing';
                    statusEl.className = 'text-xs text-red-400';
                }
                alert('Error parsing job: ' + error.message);
            }
        }

        async function saveManualJobs() {
            if (manualJobs.length === 0) {
                alert('No jobs to save');
                return;
            }

            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    throw new Error('No office context available');
                }

                // Create a route for these jobs
                routeCounter++;
                const routeId = routeCounter;

                // Save each job to Firebase
                const savedJobIds = [];
                for (let i = 0; i < manualJobs.length; i++) {
                    const job = manualJobs[i];
                    const jobData = {
                        routeId: `route_${routeId}`,
                        jobNumber: i + 1,
                        rawText: job.rawText,
                        parsedData: job.parsedData,
                        status: 'parsed',
                        createdAt: new Date(),
                        assignedRouteId: `route_${routeId}`,
                        officeId: officeId
                    };

                    const jobsCollection = window.firebaseCollection(window.firestore, 'jobs');
                    const docRef = await window.firebaseAddDoc(jobsCollection, jobData);
                    savedJobIds.push(docRef.id);
                }

                // Create route summary
                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                const routeData = {
                    routeId: `route_${routeId}`,
                    officeId: officeId,
                    createdAt: new Date(),
                    jobCount: manualJobs.length,
                    status: 'pending'
                };
                await window.firebaseAddDoc(routesCollection, routeData);

                // Reload routes on the page
                await displayRoutesFromFirebase();

                // Close modal and show success
                closePortJobsModal();
                alert(`Successfully saved ${manualJobs.length} job${manualJobs.length === 1 ? '' : 's'} to route ${routeId}!`);

                // Reset state
                manualJobs = [];
                manualJobCounter = 0;

            } catch (error) {
                console.error('Error saving manual jobs:', error);
                alert('Failed to save jobs: ' + error.message);
            }
        }

        // Handle Asana OAuth callback
        function handleAsanaCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');
            const errorDescription = urlParams.get('error_description');
            
            // Handle OAuth errors
            if (error) {
                console.error('Asana OAuth error:', error, errorDescription);
                let errorMessage = 'Failed to connect to Asana. ';
                
                if (error === 'access_denied') {
                    errorMessage += 'You denied access to the application.';
                } else if (error === 'invalid_request') {
                    errorMessage += 'The redirect URI may not be registered in your Asana app settings. Please check that https://sotogroup.uk/pages/optimisation.html is registered as a redirect URI.';
                } else {
                    errorMessage += errorDescription || error;
                }
                
                alert(errorMessage);
                showScreen('asanaConnectionScreen');
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            if (code && state) {
                // Verify state matches officeId
                if (currentSession && currentSession.officeId && state === currentSession.officeId) {
                    // Exchange code for token
                    exchangeCodeForToken(code, state);
                } else {
                    console.error('State mismatch or session not available');
                    alert('Session expired. Please try connecting again.');
                    showScreen('asanaConnectionScreen');
                    // Clean URL
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }
        }

        async function exchangeCodeForToken(code, officeId) {
            try {
                showScreen('loadingScreen');
                document.getElementById('loadingText').textContent = 'Connecting to Asana...';
                
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    // Use the same redirect_uri that was used in the authorization request
                    const redirectUri = window.location.origin + window.location.pathname;
                    console.log('Exchanging token with redirect_uri:', redirectUri);
                    
                    // Use the same function name as automaticroutes.html
                    const exchangeFunction = window.firebase.httpsCallable(window.firebase.functions, 'exchangeAsanaToken');
                    const result = await exchangeFunction({
                        code: code,
                        redirect_uri: redirectUri  // Must match the redirect_uri used in authorization
                    });
                    
                    if (result.data && result.data.success && result.data.access_token) {
                        const tokenKey = `asana_token_${officeId}`;
                        localStorage.setItem(tokenKey, result.data.access_token);
                        
                        if (result.data.user_email) {
                            const emailKey = `asana_email_${officeId}`;
                            localStorage.setItem(emailKey, result.data.user_email);
                        }
                        
                        // Load projects
                        await loadProjects(result.data.access_token);
                        showScreen('projectPickerScreen');
                        
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                    } else {
                        throw new Error(result.data?.error || 'Failed to connect to Asana');
                    }
                } else {
                    throw new Error('Firebase functions not available');
                }
            } catch (error) {
                console.error('Error exchanging code for token:', error);
                alert('Failed to connect to Asana: ' + error.message);
                showScreen('asanaConnectionScreen');
            }
        }

        async function connectToAsana() {
            if (!currentSession || !currentSession.officeId) {
                alert('Session not available. Please refresh the page.');
                return;
            }
            
            // Redirect to Asana OAuth
            // Note: redirect_uri must match exactly what's registered in Asana app settings
            const clientId = '1212057669835882'; // Asana OAuth client ID (matches automaticroutes.html)
            const redirectUri = window.location.origin + window.location.pathname;
            const state = currentSession.officeId; // Use officeId as state
            
            // Build URL properly with required scope parameters
            const authUrl = new URL('https://app.asana.com/-/oauth_authorize');
            authUrl.searchParams.set('client_id', clientId);
            authUrl.searchParams.set('redirect_uri', redirectUri);
            authUrl.searchParams.set('response_type', 'code');
            authUrl.searchParams.set('state', state);
            // Include scope parameters for OAuth 2.0
            authUrl.searchParams.set('scope', 'openid email profile default identity');
            
            console.log('Redirecting to Asana OAuth');
            console.log('Redirect URI:', redirectUri);
            console.log('Make sure this exact URI is registered in your Asana app settings at: https://app.asana.com/0/developer-console');
            
            // Note: If you get a 400 error, the redirect_uri is not registered in Asana app settings
            // Go to https://app.asana.com/0/developer-console and add this exact redirect_uri
            window.location.href = authUrl.toString();
        }

        async function loadProjects(accessToken) {
            try {
                showScreen('loadingScreen');
                document.getElementById('loadingText').textContent = 'Loading projects...';

                const workspacesUrl = 'https://app.asana.com/api/1.0/workspaces';
                const workspacesResponse = await fetch(workspacesUrl, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!workspacesResponse.ok) {
                    if (workspacesResponse.status === 401) {
                        if (currentSession && currentSession.officeId) {
                            localStorage.removeItem(`asana_token_${currentSession.officeId}`);
                        }
                        throw new Error('Asana connection expired. Please reconnect to Asana.');
                    }
                    throw new Error(`Failed to fetch workspaces: ${workspacesResponse.status}`);
                }

                const workspacesData = await workspacesResponse.json();
                const workspaceId = workspacesData.data?.[0]?.gid;

                if (!workspaceId) {
                    throw new Error('No workspace found');
                }

                const projectsUrl = `https://app.asana.com/api/1.0/workspaces/${workspaceId}/projects?opt_fields=gid,name&limit=100`;
                const projectsResponse = await fetch(projectsUrl, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!projectsResponse.ok) {
                    throw new Error(`Failed to fetch projects: ${projectsResponse.status}`);
                }

                const projectsData = await projectsResponse.json();
                availableProjects = projectsData.data || [];

                const projectSelect = document.getElementById('projectSelect');
                if (projectSelect) {
                    projectSelect.innerHTML = '<option value="">Select a project...</option>';

                    availableProjects.forEach(project => {
                        const option = document.createElement('option');
                        option.value = project.gid;
                        option.textContent = project.name;
                        projectSelect.appendChild(option);
                    });
                }
                
                showScreen('projectPickerScreen');
            } catch (error) {
                console.error('Error loading projects:', error);
                alert('Failed to load projects: ' + error.message);
                if (error.message.includes('expired') || error.message.includes('401')) {
                    showScreen('asanaConnectionScreen');
                }
            }
        }

        function selectProject() {
            const projectSelect = document.getElementById('projectSelect');
            const projectId = projectSelect.value;
            
            if (!projectId) {
                alert('Please select a project');
                return;
            }

            selectedProjectId = projectId;
            selectedProjectName = availableProjects.find(p => p.gid === projectId)?.name || 'Selected Project';
            
            const projectText = document.getElementById('selectedProjectText');
            if (projectText) {
                projectText.textContent = `Choose the date to import routes from "${selectedProjectName}"`;
            }
            
            showScreen('dayPickerScreen');
        }

        async function checkTasksForDate() {
            const dateInput = document.getElementById('routeDate');
            selectedDate = dateInput.value;

            if (!selectedDate) {
                alert('Please select a date');
                return;
            }

            if (!selectedProjectId) {
                alert('Please select a project first');
                showScreen('projectPickerScreen');
                return;
            }

            showScreen('loadingScreen');
            document.getElementById('loadingText').textContent = 'Checking tasks in Asana...';

            try {
                if (!currentSession || !currentSession.officeId) {
                    throw new Error('Session not available');
                }

                const tokenKey = `asana_token_${currentSession.officeId}`;
                const accessToken = localStorage.getItem(tokenKey);

                if (!accessToken) {
                    throw new Error('Not connected to Asana');
                }

                currentTasks = await fetchAsanaTasks(accessToken, selectedDate, selectedProjectId);
                displayTaskCount(currentTasks.length, selectedDate);
            } catch (error) {
                console.error('Error checking tasks:', error);
                alert('Failed to check tasks: ' + error.message);
                showScreen('dayPickerScreen');
            }
        }

        // ASANA SAFETY: This function ONLY reads task data from Asana - no writes, updates, or deletes
        // All Asana API calls in this codebase are READ-ONLY (GET requests only)
        async function fetchAsanaTasks(accessToken, date, projectId) {
            try {
                // Use direct API call for faster loading (only fetching task names)
                // This is much faster than going through Firebase function for simple GET requests
                console.log('Fetching task names directly from Asana API...');
                const startTime = Date.now();
                
                // Query tasks by project and due date - only request name field for speed
                const response = await fetch(`https://app.asana.com/api/1.0/projects/${projectId}/tasks?opt_fields=name,due_on&due_on=${date}&limit=100`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 401) {
                        // Token expired or invalid
                        if (currentSession && currentSession.officeId) {
                            localStorage.removeItem(`asana_token_${currentSession.officeId}`);
                        }
                        throw new Error('Asana connection expired. Please reconnect.');
                    }
                    throw new Error(`Asana API error: ${response.status}`);
                }

                const data = await response.json();
                const tasks = data.data || [];
                const elapsed = Date.now() - startTime;
                console.log(`Fetched ${tasks.length} task names in ${elapsed}ms`);
                return tasks;
                
            } catch (error) {
                console.error('Error fetching Asana tasks:', error);
                // Fallback to Firebase function if direct API fails
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    console.log('Falling back to Firebase function...');
                    const fetchTasksFunction = window.firebase.httpsCallable(window.firebase.functions, 'fetchAsanaTasks');
                    const result = await fetchTasksFunction({
                        access_token: accessToken,
                        date: date,
                        project_id: projectId
                    });

                    if (result.data && result.data.success) {
                        return result.data.tasks || [];
                    } else {
                        throw new Error(result.data?.error || 'Failed to fetch tasks');
                    }
                } else {
                    throw error;
                }
            }
        }

        function displayTaskCount(count, date) {
            const countElement = document.getElementById('tasksCount');
            const dateText = document.getElementById('selectedDateText');
            const titlesList = document.getElementById('taskTitlesList');
            
            if (countElement) {
                countElement.textContent = count;
            }
            
            if (dateText) {
                const dateObj = new Date(date);
                const formattedDate = dateObj.toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                });
                dateText.textContent = `Tasks for ${formattedDate} in "${selectedProjectName}"`;
            }
            
            if (titlesList) {
                titlesList.innerHTML = '';
                if (currentTasks.length === 0) {
                    titlesList.innerHTML = '<p class="text-gray-400 text-sm">No tasks found</p>';
                } else {
                    currentTasks.forEach((task, index) => {
                        const taskItem = document.createElement('div');
                        taskItem.className = 'bg-[#283039] rounded-lg p-3 text-sm text-white';
                        taskItem.textContent = `${index + 1}. ${task.name || 'Untitled Task'}`;
                        titlesList.appendChild(taskItem);
                    });
                }
            }
            
            showScreen('tasksCountScreen');
        }

        // Skip processing - go straight to grouping (parsing happens after selection)
        async function processJobs() {
            if (!currentTasks || currentTasks.length === 0) {
                alert('No tasks to process');
                return;
            }

            // No parsing needed here - just go to grouping screen
            // Full parsing will happen after jobs are selected and "Process Routes" is clicked
            showScreen('routeGroupingInstructionsScreen');
        }

        function extractDriverName(taskName) {
            const trimmed = (taskName || '').trim();
            const match = trimmed.match(/^([^\(]+?)(?:\s*\(?\d+\)?|\s+Free|$)/i);
            if (match && match[1]) {
                return match[1].trim();
            }
            const beforeNumber = trimmed.split(/\s*\(?\d/)[0].trim();
            if (beforeNumber) {
                return beforeNumber;
            }
            return trimmed.split(' ')[0] || 'Unknown';
        }

        function startRouteGrouping() {
            if (!currentTasks || currentTasks.length === 0) {
                alert('No tasks to group. Please check tasks first.');
                return;
            }

            routeGroupingMode = true;
            routeGroupingStarted = false;
            selectedJobsForRoute = [];
            currentFocusedJobIndex = -1;
            routeCounter = 0;
            // Store tasks with minimal data (just name and gid) - full details fetched later when processing
            ungroupedJobs = currentTasks.map(task => ({
                task: {
                    gid: task.gid,
                    name: task.name
                    // notes will be fetched later when processing routes
                },
                parsedData: null
            }));
            
            displayJobsForGrouping();
            setupRouteGroupingKeyboard();
            showScreen('routeGroupingScreen');
        }

        function displayJobsForGrouping() {
            const container = document.getElementById('groupingJobsContainer');
            if (!container) return;
            
            const overlay = document.getElementById('groupingStartOverlay');
            if (overlay) {
                overlay.style.display = routeGroupingStarted ? 'none' : 'flex';
            }
            
            const jobsList = container.querySelector('.jobs-list');
            if (jobsList) {
                jobsList.remove();
            }
            
            const jobsListDiv = document.createElement('div');
            jobsListDiv.className = 'jobs-list';
            container.appendChild(jobsListDiv);
            
            if (ungroupedJobs.length === 0) {
                jobsListDiv.innerHTML = `
                    <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-8 text-center">
                        <h3 class="text-xl font-bold text-white mb-2">All Jobs Grouped!</h3>
                        <p class="text-gray-400 mb-4">You've successfully organized all jobs into ${routeCounter} routes.</p>
                        <button 
                            onclick="finishRouteGrouping()"
                            class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg transition-colors font-medium"
                        >
                            Finish & Save Routes
                        </button>
                    </div>
                `;
                return;
            }
            
            // Display jobs in the same order as they appear in Asana (no sorting)
            const jobsWithIndices = ungroupedJobs.map((jobData, index) => ({
                jobData,
                originalIndex: index
            }));
            
            jobsWithIndices.forEach(({ jobData, originalIndex }) => {
                const { task } = jobData;
                const isSelected = selectedJobsForRoute.includes(originalIndex);
                const isFocused = currentFocusedJobIndex === originalIndex;
                
                // Get selection order number (1, 2, 3...)
                const selectionOrder = isSelected ? selectedJobsForRoute.indexOf(originalIndex) + 1 : null;
                
                const jobCard = document.createElement('div');
                let cardClasses = 'bg-[#1a1f24] border-2 rounded-lg p-2 cursor-pointer transition-all mb-2 ';
                if (isSelected) {
                    cardClasses += 'border-green-500 bg-[#283039] shadow-lg shadow-green-500/20';
                } else if (isFocused) {
                    cardClasses += 'border-blue-500 bg-[#283039] shadow-lg shadow-blue-500/20';
                } else {
                    cardClasses += 'border-[#283039] hover:border-gray-600';
                }
                jobCard.className = cardClasses;
                jobCard.dataset.jobIndex = originalIndex;
                jobCard.onclick = () => toggleJobSelection(originalIndex);
                
                jobCard.innerHTML = `
                    <div class="flex items-center justify-between gap-2">
                        <div class="flex-1 min-w-0">
                            <div class="flex items-center gap-2 mb-1">
                                <h4 class="text-sm font-semibold text-white truncate">${task.name || 'Untitled Task'}</h4>
                                ${selectionOrder ? `<span class="flex-shrink-0 bg-green-500 text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center" title="Job ${selectionOrder} in route">${selectionOrder}</span>` : ''}
                            </div>
                            <p class="text-xs text-gray-400">${isSelected ? `Will be saved as Job ${selectionOrder} in route` : 'Click to select'}</p>
                        </div>
                        ${isSelected ? '<span class="material-symbols-outlined text-green-500 text-xl flex-shrink-0">check_circle</span>' : ''}
                    </div>
                `;
                
                jobsListDiv.appendChild(jobCard);
            });
            
            const routesCountEl = document.getElementById('routesCount');
            if (routesCountEl) {
                routesCountEl.textContent = routeCounter;
            }
            
            const processBtn = document.getElementById('processRoutesBtn');
            if (processBtn) {
                processBtn.disabled = routeCounter === 0;
            }
        }

        function toggleJobSelection(jobIndex) {
            const index = selectedJobsForRoute.indexOf(jobIndex);
            if (index > -1) {
                selectedJobsForRoute.splice(index, 1);
            } else {
                selectedJobsForRoute.push(jobIndex);
            }
            displayJobsForGrouping();
        }

        async function groupSelectedJobs() {
            if (selectedJobsForRoute.length === 0) {
                alert('Please select at least one job to group');
                return;
            }
            
            const selectedJobs = selectedJobsForRoute.map(idx => ungroupedJobs[idx]);
            
            routeCounter++;
            const routeId = routeCounter;
            
            savedRoutesForPort.push({
                routeId: routeId,
                jobs: selectedJobs,
                createdAt: new Date()
            });
            
            const indicesToRemove = [...selectedJobsForRoute].sort((a, b) => b - a);
            indicesToRemove.forEach(idx => {
                ungroupedJobs.splice(idx, 1);
            });
            
            selectedJobsForRoute = [];
            
            // Keep focus on first job in Asana order (no sorting)
            if (ungroupedJobs.length > 0) {
                currentFocusedJobIndex = 0; // First job in Asana order
            } else {
                currentFocusedJobIndex = -1;
            }
            
            setTimeout(() => {
                displayJobsForGrouping();
            }, 500);
        }

        function setupRouteGroupingKeyboard() {
            const handleKeyPress = (e) => {
                if (!routeGroupingMode) return;
                
                if (e.key === ' ') {
                    e.preventDefault();
                    if (!routeGroupingStarted) {
                        routeGroupingStarted = true;
                        // Start with first job in Asana order (no sorting)
                        currentFocusedJobIndex = ungroupedJobs.length > 0 ? 0 : -1;
                        displayJobsForGrouping();
                        setTimeout(() => {
                            if (currentFocusedJobIndex >= 0) {
                                const jobCard = document.querySelector(`[data-job-index="${currentFocusedJobIndex}"]`);
                                if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            }
                        }, 100);
                    } else {
                        if (currentFocusedJobIndex >= 0 && currentFocusedJobIndex < ungroupedJobs.length) {
                            toggleJobSelection(currentFocusedJobIndex);
                        }
                    }
                    return;
                }
                
                if (!routeGroupingStarted) return;
                
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    // Navigate in Asana order (no sorting)
                    if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                        // Move to next job in Asana order
                        if (currentFocusedJobIndex < ungroupedJobs.length - 1) {
                            currentFocusedJobIndex++;
                        } else {
                            currentFocusedJobIndex = 0; // Wrap to first
                        }
                        displayJobsForGrouping();
                        const jobCard = document.querySelector(`[data-job-index="${currentFocusedJobIndex}"]`);
                        if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
                        // Move to previous job in Asana order
                        if (currentFocusedJobIndex > 0) {
                            currentFocusedJobIndex--;
                        } else {
                            currentFocusedJobIndex = ungroupedJobs.length - 1; // Wrap to last
                        }
                        displayJobsForGrouping();
                        const jobCard = document.querySelector(`[data-job-index="${currentFocusedJobIndex}"]`);
                        if (jobCard) jobCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                    return;
                }
                
                if (e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    if (selectedJobsForRoute.length > 0) {
                        groupSelectedJobs();
                    }
                }
            };
            
            if (window.routeGroupingKeyHandler) {
                document.removeEventListener('keydown', window.routeGroupingKeyHandler);
            }
            
            window.routeGroupingKeyHandler = handleKeyPress;
            document.addEventListener('keydown', handleKeyPress);
        }

        // ASANA SAFETY: This function ONLY reads full task details from Asana - no writes, updates, or deletes
        async function fetchFullTaskDetails(taskGid, accessToken) {
            try {
                // Use direct API call for faster loading (same approach as fetchAsanaTasks)
                // This avoids CORS issues and is much faster than Firebase Functions
                const response = await fetch(`https://app.asana.com/api/1.0/tasks/${taskGid}?opt_fields=name,notes`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        // Token expired or invalid
                        if (currentSession && currentSession.officeId) {
                            localStorage.removeItem(`asana_token_${currentSession.officeId}`);
                        }
                        throw new Error('Asana connection expired. Please reconnect.');
                    }
                    throw new Error(`Failed to fetch task: ${response.status}`);
                }
                
                const data = await response.json();
                return data.data;
                
            } catch (error) {
                console.error('Error fetching full task details:', error);
                // Fallback to Firebase function only if direct API fails
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    console.log('Falling back to Firebase function for task details...');
                    const fetchTaskFunction = window.firebase.httpsCallable(window.firebase.functions, 'fetchAsanaTaskDetails');
                    const result = await fetchTaskFunction({
                        access_token: accessToken,
                        task_gid: taskGid
                    });
                    
                    if (result.data && result.data.success) {
                        return result.data.task;
                    } else {
                        throw new Error(result.data?.error || 'Failed to fetch task details');
                    }
                } else {
                    throw error;
                }
            }
        }

        async function processRoutes() {
            if (!savedRoutesForPort || savedRoutesForPort.length === 0) {
                alert('No routes to process. Please create some routes first.');
                return;
            }

            showScreen('loadingScreen');
            document.getElementById('loadingText').textContent = 'Fetching full job details and parsing...';

            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    throw new Error('No office context available');
                }

                // Get Asana access token
                const tokenKey = `asana_token_${officeId}`;
                const accessToken = localStorage.getItem(tokenKey);
                if (!accessToken) {
                    throw new Error('Not connected to Asana');
                }

                for (const route of savedRoutesForPort) {
                    const routeJobs = [];
                    
                    for (let i = 0; i < route.jobs.length; i++) {
                        const jobData = route.jobs[i];
                        const task = jobData.task;
                        
                        // Fetch full task details (name + notes) from Asana
                        let fullTask = task;
                        if (task.gid) {
                            try {
                                fullTask = await fetchFullTaskDetails(task.gid, accessToken);
                            } catch (error) {
                                console.warn(`Failed to fetch full details for task ${task.gid}, using name only:`, error);
                                // Fallback to just the name we already have
                            }
                        }
                        
                        const taskText = `${fullTask.name || ''}\n${fullTask.notes || ''}`;
                        
                        let parsedData = {
                            collection_address: 'Not found',
                            postcode_delivery: 'Not found',
                            price: 0,
                            reg_number: 'Not found',
                            confidence_scores: { collection: 0, delivery: 0, price: 0, reg: 0 },
                            overall_confidence: 0
                        };
                        
                        if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                            try {
                                const parseFunction = window.firebase.httpsCallable(window.firebase.functions, 'parseJobText');
                                const result = await parseFunction({ rawText: taskText });
                                
                                if (result.data && result.data.success && result.data.parsed_data) {
                                    parsedData = result.data.parsed_data;
                                }
                            } catch (error) {
                                console.warn('Error parsing job text:', error);
                            }
                        }
                        
                        const jobDataToSave = {
                            routeId: `route_${route.routeId}`,
                            jobNumber: i + 1, // Use order from selection (1, 2, 3...)
                            rawText: taskText,
                            parsedData: parsedData,
                            status: 'parsed',
                            createdAt: new Date(),
                            assignedRouteId: `route_${route.routeId}`,
                            officeId: officeId
                        };

                        const jobsCollection = window.firebaseCollection(window.firestore, 'jobs');
                        await window.firebaseAddDoc(jobsCollection, jobDataToSave);
                        
                        routeJobs.push(jobDataToSave);
                    }
                    
                    // Create route summary
                    const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                    const routeData = {
                        routeId: `route_${route.routeId}`,
                        officeId: officeId,
                        createdAt: new Date(),
                        jobCount: routeJobs.length,
                        status: 'pending'
                    };
                    await window.firebaseAddDoc(routesCollection, routeData);
                }
                
                // Reload routes on the page
                await displayRoutesFromFirebase();
                
                // Close modal and show success
                closePortJobsModal();
                alert(`Successfully created ${savedRoutesForPort.length} routes!`);
                
                // Reset state
                savedRoutesForPort = [];
                routeCounter = 0;
                
            } catch (error) {
                console.error('Error processing routes:', error);
                alert('Failed to process routes: ' + error.message);
            }
        }

        function finishRouteGrouping() {
            routeGroupingMode = false;
            if (window.routeGroupingKeyHandler) {
                document.removeEventListener('keydown', window.routeGroupingKeyHandler);
            }
            
            const processBtn = document.getElementById('processRoutesBtn');
            if (processBtn) {
                processBtn.disabled = false;
            }
            
            alert(`Successfully created ${routeCounter} routes! Click "Process Routes" to save them.`);
        }

        // Navigation functions
        // Calculate working hours between two dates (8am-5pm Mon-Fri only)
        function calculateWorkingHours(startDate, endDate) {
            let currentDate = new Date(startDate);
            let workingHours = 0;
            
            while (currentDate < endDate) {
                const dayOfWeek = currentDate.getDay();
                const hour = currentDate.getHours();
                
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    if (hour >= 8 && hour < 17) {
                        workingHours += 1;
                    }
                }
                
                currentDate.setHours(currentDate.getHours() + 1);
            }
            
            return workingHours;
        }

        // Check for expenses over 24 working hours old
        async function checkOldExpenses(officeId) {
            try {
                const batchesQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'expenseBatches'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const batchesSnapshot = await window.firebaseGetDocs(batchesQuery);
                const now = new Date();
                let oldExpenseCount = 0;
                
                batchesSnapshot.docs.forEach(doc => {
                    const batch = doc.data();
                    if (batch.status === 'pending' || batch.status === 'validated') {
                        const submittedAt = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                        if (submittedAt) {
                            const workingHours = calculateWorkingHours(submittedAt, now);
                            if (workingHours > 24) {
                                oldExpenseCount++;
                            }
                        }
                    }
                });
                
                return oldExpenseCount;
            } catch (error) {
                console.error('Error checking old expenses:', error);
                return 0;
            }
        }
        
        // Update notification count across all office pages
        async function updateNotificationCount() {
            try {
                console.log('[OPTIMISATION] updateNotificationCount called');
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.log('[OPTIMISATION] No office context available');
                    return;
                }
                console.log('[OPTIMISATION] Office ID:', officeId);
                
                // Get all availability change notifications for this office that haven't been seen
                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);
                console.log('[OPTIMISATION] Total notifications found:', notificationsSnapshot.docs.length);
                
                // Count unique drivers with unread changes
                const driverChanges = {};
                // Filter to only unseen notifications and convert dates
                const allNotifications = notificationsSnapshot.docs
                    .map(doc => {
                        const data = doc.data();
                        return {
                            id: doc.id,
                            ...data,
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt)
                        };
                    })
                    .filter(notification => notification.seen !== true) // Only include unseen notifications
                    .sort((a, b) => b.createdAt - a.createdAt); // Sort by date (most recent first)
                
                // Group by driver and only count the most recent batch (within 1 hour of latest)
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    
                    if (!driverChanges[driverId]) {
                        // This is the first (most recent) unseen notification for this driver
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName,
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [notification],
                            latestDate: notification.createdAt,
                            earliestDate: notification.createdAt
                        };
                        
                        // Count this first notification
                        if (notification.changeType === 'unavailable') {
                            driverChanges[driverId].daysOff = 1;
                        } else {
                            driverChanges[driverId].daysAvailable = 1;
                        }
                    } else {
                        // Check if this notification is within 1 hour of the latest (most recent) one
                        // This ensures we only count the most recent batch, not old unseen notifications
                        const timeDiffFromLatest = Math.abs(driverChanges[driverId].latestDate - notification.createdAt);
                        const oneHour = 60 * 60 * 1000; // 1 hour in milliseconds
                        
                        if (timeDiffFromLatest <= oneHour) {
                            // Same batch - add to counts
                            if (notification.changeType === 'unavailable') {
                                driverChanges[driverId].daysOff++;
                            } else {
                                driverChanges[driverId].daysAvailable++;
                            }
                            driverChanges[driverId].notifications.push(notification);
                            // Update earliest date if this is older
                            if (notification.createdAt < driverChanges[driverId].earliestDate) {
                                driverChanges[driverId].earliestDate = notification.createdAt;
                            }
                            // latestDate stays as the most recent (first one we found)
                        }
                        // If outside the batch window (more than 1 hour from latest), ignore it
                    }
                });
                
                // Count total number of drivers with changes
                const availabilityCount = Object.keys(driverChanges).length;
                console.log('[OPTIMISATION] Drivers with changes:', availabilityCount);
                
                // Check for old expenses (>24 working hours)
                const oldExpenseCount = await checkOldExpenses(officeId);
                console.log('[OPTIMISATION] Old expenses count:', oldExpenseCount);
                
                // Total notification count (availability changes + old expenses)
                const unreadCount = availabilityCount + (oldExpenseCount > 0 ? 1 : 0);
                console.log('[OPTIMISATION] Total unread count:', unreadCount);
                
                // Update notification badge on all pages
                updateNotificationBadge(unreadCount);
                console.log('[OPTIMISATION] Badge updated');
                
            } catch (error) {
                console.error('[OPTIMISATION] Error updating notification count:', error);
            }
        }

        // Update notification badge display
        function updateNotificationBadge(count) {
            console.log('[OPTIMISATION] updateNotificationBadge called with count:', count);
            const badgeElements = document.querySelectorAll('.notification-badge');
            console.log('[OPTIMISATION] Found badge elements:', badgeElements.length);
            badgeElements.forEach((badge, index) => {
                console.log(`[OPTIMISATION] Badge ${index}:`, badge);
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.classList.remove('hidden');
                    console.log(`[OPTIMISATION] Badge ${index} shown with count:`, badge.textContent);
                } else {
                    badge.classList.add('hidden');
                    console.log(`[OPTIMISATION] Badge ${index} hidden`);
                }
            });
        }

        // Show notifications dropdown
        async function showNotifications() {
            const dropdown = document.getElementById('notificationDropdown');
            if (!dropdown) return;
            
            // Toggle dropdown visibility
            dropdown.classList.toggle('hidden');
            
            if (!dropdown.classList.contains('hidden')) {
                // Load and display notifications
                await loadNotifications();
            }
        }

        // Load notifications for dropdown (aggregated by driver)
        async function loadNotifications() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) return;
                
                // Get all unseen availability change notifications for this office
                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);
                const notificationsList = document.getElementById('notificationsList');
                
                const oldExpenseCount = await checkOldExpenses(officeId);
                
                // Aggregate notifications by driver
                const driverChanges = {};
                const allNotifications = notificationsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    if (!driverChanges[driverId]) {
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName,
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [],
                            latestDate: null
                        };
                    }
                    
                    if (notification.changeType === 'unavailable') {
                        driverChanges[driverId].daysOff++;
                    } else {
                        driverChanges[driverId].daysAvailable++;
                    }
                    
                    driverChanges[driverId].notifications.push(notification);
                    
                    // Track latest notification date
                    const notifDate = notification.createdAt?.toDate ? notification.createdAt.toDate() : new Date(notification.createdAt);
                    if (!driverChanges[driverId].latestDate || notifDate > driverChanges[driverId].latestDate) {
                        driverChanges[driverId].latestDate = notifDate;
                    }
                });
                
                // Sort by latest date (most recent first)
                const sortedDrivers = Object.values(driverChanges).sort((a, b) => b.latestDate - a.latestDate);
                
                // Clear existing notifications
                notificationsList.innerHTML = '';
                
                if (oldExpenseCount > 0) {
                    const expenseNotification = createOldExpenseNotificationElement(oldExpenseCount);
                    notificationsList.appendChild(expenseNotification);
                }
                
                sortedDrivers.forEach(driverData => {
                    const notificationElement = createAggregatedNotificationElement(driverData);
                    notificationsList.appendChild(notificationElement);
                });
                
                if (oldExpenseCount === 0 && sortedDrivers.length === 0) {
                    notificationsList.innerHTML = `
                        <div class="px-4 py-3 text-gray-400 text-sm text-center">
                            No notifications yet
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error loading notifications:', error);
            }
        }

        // Create aggregated notification element for dropdown
        function createOldExpenseNotificationElement(count) {
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => {
                document.getElementById('notificationDropdown').classList.add('hidden');
                window.location.href = '/pages/expenses.html';
            };
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">There are ${count} ${count === 1 ? 'expense' : 'expenses'} that are 24 working hours old</div>
                        <div class="text-[#9cabba] text-xs mt-1">Click to view expenses</div>
                    </div>
                    <div class="w-2 h-2 bg-red-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }
        
        function createAggregatedNotificationElement(driverData) {
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => handleAggregatedNotificationClick(driverData);
            
            // Build message based on changes
            let message = '';
            if (driverData.daysOff > 0 && driverData.daysAvailable > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off and changed ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'} back to available`;
            } else if (driverData.daysOff > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off`;
            } else if (driverData.daysAvailable > 0) {
                message = `${driverData.driverName} has changed ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'} back to available`;
            }
            
            const timeAgo = getTimeAgo(driverData.latestDate);
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">${message}</div>
                        <div class="text-[#9cabba] text-xs mt-1">${timeAgo}</div>
                    </div>
                    <div class="w-2 h-2 bg-blue-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }

        // Handle aggregated notification click (navigate to availability page)
        async function handleAggregatedNotificationClick(driverData) {
            try {
                document.getElementById('notificationDropdown').classList.add('hidden');
                const dates = driverData.notifications.map(n => n.date).sort();
                const earliestDate = dates[0] ? new Date(dates[0]) : new Date();
                const year = earliestDate.getFullYear();
                const month = earliestDate.getMonth() + 1;
                window.location.href = `/pages/availability.html?year=${year}&month=${month}&showChanges=${driverData.driverId}`;
            } catch (error) {
                console.error('Error handling aggregated notification click:', error);
            }
        }

        // Handle notification click
        async function handleNotificationClick(notificationId, notification) {
            try {
                // Mark notification as read
                const notificationRef = window.firebaseDoc(window.firestore, 'availabilityNotifications', notificationId);
                await window.firebaseUpdateDoc(notificationRef, { seen: true });
                
                // Hide dropdown
                document.getElementById('notificationDropdown').classList.add('hidden');
                
                // Navigate to availability page with specific date
                const date = new Date(notification.date);
                const year = date.getFullYear();
                const month = date.getMonth() + 1; // JavaScript months are 0-indexed
                
                // Navigate to availability page with date parameters
                window.location.href = `/pages/availability.html?year=${year}&month=${month}&openDate=${notification.date}`;
                
            } catch (error) {
                console.error('Error handling notification click:', error);
            }
        }

        // Get time ago string
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return date.toLocaleDateString();
        }

        // Initialize notification system
        async function initializeNotifications() {
            // Update notification count on page load
            await updateNotificationCount();
            
            // Set up click outside to close dropdown
            document.addEventListener('click', function(event) {
                const dropdown = document.getElementById('notificationDropdown');
                const button = event.target.closest('button[onclick="showNotifications()"]');
                
                if (!button && !dropdown.contains(event.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        async function logout() {
            if (confirm('Are you sure you want to logout?')) {
                try {
                    // Sign out from Firebase
                    await window.signOut(window.auth);
                    
                    console.log('User logged out successfully');
                    
                    window.sotoSession?.clearSession();
                    
                    // Redirect to login page
                    window.location.href = '/pages/soto-routes-login.html';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.sotoSession?.clearSession();
                    window.location.href = '/pages/soto-routes-login.html';
                }
            }
        }

        // Load routes from Firebase (with localStorage fallback)
        async function loadRoutesFromFirebase() {
            try {
                // Check if Firebase is available
                if (!window.firestore || !window.firebaseCollection) {
                    console.log('Firebase not available, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }

                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context when loading routes. Falling back to localStorage.');
                    return loadRoutesFromLocalStorage();
                }

                console.log('Loading routes and jobs from Firebase...');
                
                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                const jobsCollection = window.firebaseCollection(window.firestore, 'jobs');

                const officeRoutesQuery = window.firebaseQuery(routesCollection, window.firebaseWhere('officeId', '==', officeId));
                const officeJobsQuery = window.firebaseQuery(jobsCollection, window.firebaseWhere('officeId', '==', officeId));

                const [routesSnapshot, jobsSnapshot, legacyRoutesSnapshot, legacyJobsSnapshot] = await Promise.all([
                    window.firebaseGetDocs(officeRoutesQuery),
                    window.firebaseGetDocs(officeJobsQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(routesCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy routes query failed (likely none remaining):', legacyError);
                            return { docs: [] };
                        }
                    })(),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(jobsCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy jobs query failed (likely none remaining):', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);
                
                savedRoutes = [];
                
                const routeDocs = [...routesSnapshot.docs, ...(legacyRoutesSnapshot?.docs || [])];

                if (routeDocs.length === 0) {
                    console.log('No routes found in Firebase, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }
                
                const jobsByRoute = {};
                const jobDocs = [...jobsSnapshot.docs, ...(legacyJobsSnapshot?.docs || [])];

                await Promise.all(jobDocs.map(async jobDoc => {
                    const jobData = jobDoc.data();

                    if (jobData.officeId && jobData.officeId !== officeId) {
                        return;
                    }

                    if (!jobData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(jobDoc.ref, { officeId });
                            jobData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for job ${jobDoc.id}:`, error);
                            return;
                        }
                    }

                    const routeId = jobData.assignedRouteId;
                    if (!routeId) {
                        return;
                    }

                        if (!jobsByRoute[routeId]) {
                            jobsByRoute[routeId] = [];
                        }
                        jobsByRoute[routeId].push({
                            id: jobDoc.id,
                            ...jobData
                        });
                }));
                    
                // Sort jobs within each route by jobNumber
                Object.keys(jobsByRoute).forEach(routeId => {
                    jobsByRoute[routeId].sort((a, b) => (a.jobNumber || 0) - (b.jobNumber || 0));
                });
                
                // Process routes and attach their jobs
                for (const routeDoc of routeDocs) {
                    const routeData = routeDoc.data();
                    const routeId = routeData.routeId || routeDoc.id;
                    
                    if (routeData.officeId && routeData.officeId !== officeId) {
                        continue;
                    }

                    if (!routeData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(routeDoc.ref, { officeId });
                            routeData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for route ${routeDoc.id}:`, error);
                            continue;
                        }
                    }

                    // Get jobs for this route
                    let jobs = jobsByRoute[routeId] || [];
                    
                    // If route has a jobs array with firebaseIds, filter to only those jobs
                    // This ensures we only show jobs that are explicitly linked to this route version
                    if (routeData.jobs && Array.isArray(routeData.jobs) && routeData.jobs.length > 0) {
                        const routeJobIds = new Set(
                            routeData.jobs
                                .map(job => job.firebaseId || job.id)
                                .filter(id => id)
                        );
                        
                        if (routeJobIds.size > 0) {
                            // Filter jobs to only those explicitly linked in the route document
                            jobs = jobs.filter(job => routeJobIds.has(job.id));
                            console.log(`Route ${routeId}: Filtered to ${jobs.length} jobs from route document (had ${jobsByRoute[routeId]?.length || 0} total jobs with this routeId)`);
                        }
                    }
                    
                    // If no jobs found but route has jobCount, log a warning
                    if (jobs.length === 0 && routeData.jobCount > 0) {
                        console.warn(`Route ${routeId} has jobCount ${routeData.jobCount} but no matching jobs found`);
                    }
                    
                    const routeWithJobs = {
                        route: {
                            id: routeDoc.id,
                            ...(routeData.route || routeData)  // Spread nested route if exists, otherwise spread routeData
                        },
                        jobs: jobs
                    };
                    
                    routeWithJobs.route.officeId = routeWithJobs.route.officeId || officeId;
                    savedRoutes.push(routeWithJobs);
                }

                if (savedRoutes.length === 0) {
                    console.log('No routes matched office filter, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }

                console.log(`Loaded ${savedRoutes.length} routes with jobs from Firebase (optimized)`);
                return savedRoutes;
            } catch (error) {
                console.error('Error loading routes from Firebase:', error);
                console.log('Falling back to localStorage...');
                return loadRoutesFromLocalStorage();
            }
        }

        // Save routes to Firebase
        async function saveRoutesToFirebase() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] Cannot save routes without office context.');
                    return;
                }

                const user = window.auth.currentUser;
                const userId = currentSession?.uid || user?.uid;
                if (!userId) {
                    console.error('No authenticated user found for saving routes');
                    return;
                }

                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                
                // Save each route with its assignments using the original route ID
                for (let i = 0; i < savedRoutes.length; i++) {
                    const routeData = savedRoutes[i];
                    const originalRouteId = routeData.route.id; // Use the original Firebase document ID
                    const routeDocRef = window.firebaseDoc(routesCollection, originalRouteId);
                    
                    // Save driver assignments if they exist
                    const routeWithAssignments = { ...routeData.route };
                    routeWithAssignments.officeId = routeWithAssignments.officeId || officeId;
                    
                    const jobsWithOffice = (routeData.jobs || []).map(job => ({
                        ...job,
                        officeId: job.officeId || officeId
                    }));
                    
                    await window.firebaseSetDoc(routeDocRef, {
                        routeId: routeData.route.routeId || originalRouteId,
                        route: routeWithAssignments, // Include driver assignments
                        jobs: jobsWithOffice,
                        officeId: officeId,
                        lastUpdated: new Date(),
                        userId: userId
                    });
                }
                
                console.log(`Updated ${savedRoutes.length} routes in Firebase (with driver assignments)`);
            } catch (error) {
                console.error('Error saving routes to Firebase:', error);
            }
        }

        // Load drivers from Firebase
        async function loadDriversFromFirebase() {
            try {
                // Check if Firebase is available
                if (!window.firestore || !window.firebaseCollection) {
                    console.log('Firebase not available for drivers');
                    return [];
                }

                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context when loading drivers.');
                    drivers = [];
                    return drivers;
                }

                // Get all drivers from Firebase
                const driversCollection = window.firebaseCollection(window.firestore, 'drivers');
                const driversQuery = window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', officeId));

                let [driversSnapshot, legacySnapshot] = await Promise.all([
                    window.firebaseGetDocs(driversQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy drivers query (global) failed:', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);

                const driverDocs = [...driversSnapshot.docs, ...(legacySnapshot?.docs || [])];
                
                drivers = [];
                
                for (const driverDoc of driverDocs) {
                    const driverData = driverDoc.data();
                    
                    if (driverData.officeId && driverData.officeId !== officeId) {
                        continue;
                    }
                    
                    if (!driverData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(driverDoc.ref, { officeId });
                            driverData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for driver ${driverDoc.id}:`, error);
                            continue;
                        }
                    }
                    
                    console.log('Driver data from Firebase:', driverData);
                    
                    // Use the correct field names from the drivers page: firstName, lastName, homePostcode
                    const firstName = driverData.firstName || '';
                    const lastName = driverData.lastName || '';
                    const name = `${firstName} ${lastName}`.trim() || 'Unknown Driver';
                    const postcode = driverData.homePostcode || 'Unknown Postcode';
                    
                    drivers.push({
                        id: driverDoc.id,
                        name: name,
                        postcode: postcode,
                        ...driverData
                    });
                    
                    console.log('Processed driver:', { name, postcode });
                }

                console.log('Loaded drivers from Firebase:', drivers);
                return drivers;
            } catch (error) {
                console.error('Error loading drivers from Firebase:', error);
                // Fallback to demo drivers if Firebase fails
                drivers = [
                    { name: "John Smith", postcode: "B775JA" },
                    { name: "Sarah Johnson", postcode: "M1 4AN" },
                    { name: "Mike Wilson", postcode: "LS1 4DY" },
                    { name: "Emma Brown", postcode: "B797RU" },
                    { name: "David Taylor", postcode: "SW1A 0AA" }
                ];
                return drivers;
            }
        }

        // Load routes from localStorage (fallback)
        function loadRoutesFromLocalStorage() {
            try {
                const savedRoutesData = JSON.parse(localStorage.getItem('savedRoutes') || '[]');
                savedRoutes = [];
                
                for (const routeData of savedRoutesData) {
                    // Convert localStorage data to CloudKit-like format
                    const routeRecord = {
                        fields: {
                            routeIdString: { value: routeData.routeId },
                            userIdString: { value: routeData.userId },
                            routeNameString: { value: routeData.routeName },
                            driverNameString: { value: routeData.driverName },
                            driverLocationString: { value: routeData.driverLocation },
                            totalJobsInt64: { value: routeData.totalJobs },
                            totalDistanceDouble: { value: routeData.totalDistance },
                            estimatedDurationInt64: { value: routeData.estimatedDuration },
                            statusString: { value: routeData.status }
                        }
                    };
                    
                    const jobs = routeData.jobs.map(job => ({
                        fields: {
                            jobIdString: { value: job.jobId || `job_${routeData.routeId}_${job.jobNumber}` },
                            routeIdString: { value: routeData.routeId },
                            jobNumberInt64: { value: job.jobNumber },
                            collectionAddressString: { value: job.collectionAddress },
                            deliveryAddressString: { value: job.deliveryAddress },
                            collectionPostcodeString: { value: job.collectionPostcode },
                            deliveryPostcodeString: { value: job.deliveryPostcode },
                            jobPriceDouble: { value: job.price },
                            jobDistanceDouble: { value: job.distance },
                            jobDurationInt64: { value: job.duration },
                            jobNotesString: { value: job.notes },
                            isCompletedBoolean: { value: job.isCompleted ? 1 : 0 }
                        }
                    }));
                    
                    savedRoutes.push({
                        route: routeRecord,
                        jobs: jobs
                    });
                }
                
                console.log('Loaded routes from localStorage:', savedRoutes);
                return savedRoutes;
            } catch (error) {
                console.error('Error loading routes from localStorage:', error);
                return [];
            }
        }

        // Display routes from Firebase
        async function displayRoutesFromFirebase() {
            try {
                console.log('Loading routes from Firebase...');
                await loadRoutesFromFirebase();
                
                const routesContainer = document.getElementById('routes-container');
                const noRoutesMessage = document.getElementById('no-routes-message');
                
                if (savedRoutes.length === 0) {
                    noRoutesMessage.style.display = 'block';
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2">No saved routes available</p>
                        <p class="text-sm">Go to the Routes page to create and save routes first</p>
                    `;
                    hideDemoRoutes();
                    return;
                }
                
                console.log(`Found ${savedRoutes.length} routes, displaying...`);
                noRoutesMessage.style.display = 'none';
                hideDemoRoutes();
                
                // Clear existing dynamic routes
                const existingDynamicRoutes = routesContainer.querySelectorAll('.dynamic-route');
                existingDynamicRoutes.forEach(route => route.remove());
                
                // Display each saved route (display all routes with jobs, regardless of driver assignment)
                savedRoutes.forEach((routeData, index) => {
                    const route = routeData.route;
                    const jobs = routeData.jobs;
                    
                    // Display routes that have jobs (driver assignment is optional - can be assigned later)
                    if (jobs.length > 0) {
                        const firstJob = jobs[0];
                        const routeElement = createRouteElement(route, jobs, index + 1);
                        routesContainer.appendChild(routeElement);
                    }
                });
                
                // Populate driver assignments and REG numbers for all routes
                savedRoutes.forEach((routeData, index) => {
                    const routeNumber = index + 1;
                    const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                    const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                    const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                    
                    // Always populate REG from first job (even if no driver assigned)
                    if (regElement && routeData.jobs.length > 0) {
                        const firstJob = routeData.jobs[0];
                        const regNumber = firstJob?.parsedData?.reg_number || '-';
                        regElement.textContent = regNumber;
                    }
                    
                    // Populate driver information if assigned
                    if (routeData.route.assignedDriverName) {
                        if (driverElement) {
                            driverElement.textContent = routeData.route.assignedDriverName;
                        }
                        
                        if (locationElement) {
                            locationElement.textContent = routeData.route.assignedDriverPostcode || '-';
                        }
                        
                        // Restore carryover information if it exists
                        if (routeData.route.carryoverPostcode) {
                            const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                            const carryoverPostcode = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                            if (carryoverDisplay) carryoverDisplay.classList.remove('hidden');
                            if (carryoverPostcode) carryoverPostcode.textContent = routeData.route.carryoverPostcode;
                        }
                        
                        // Restore route score if it exists
                        if (routeData.route.routeScore) {
                            const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                            const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                            
                            if (scoreElement) {
                                scoreElement.textContent = routeData.route.routeScore.score;
                            }
                            
                            if (scoreContainer) {
                                if (routeData.route.routeScore.color === 'green') {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                                } else if (routeData.route.routeScore.color === 'orange') {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                                } else {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                                }
                            }
                        }
                        
                        console.log(`â Loaded assignment: ${routeData.route.assignedDriverName} to route ${routeNumber}`);
                    }
                });
                
                console.log(`Displayed ${savedRoutes.length} routes successfully`);
                
            } catch (error) {
                console.error('Error displaying routes:', error);
                const noRoutesMessage = document.getElementById('no-routes-message');
                if (noRoutesMessage) {
                    noRoutesMessage.style.display = 'block';
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2 text-red-400">Error loading routes</p>
                        <p class="text-sm">${error.message}</p>
                        <p class="text-sm mt-2">Click "Load Routes" to try again</p>
                    `;
                }
            }
        }

        // Create a route element from Firebase data
        function createRouteElement(routeRecord, jobs, routeNumber) {
            const routeDiv = document.createElement('div');
            routeDiv.className = 'flex flex-col gap-3 rounded-lg border border-[#283039] bg-[#1a1f24] p-3 dynamic-route w-full max-w-2xl';
            routeDiv.id = `firebase-route-${routeNumber}`;
            
            // Create job pairs (Collection A -> Delivery A, Collection B -> Delivery B, etc.)
            let jobPairsHTML = '';
            jobs.forEach((job, index) => {
                const jobLetter = String.fromCharCode(65 + index); // A, B, C, etc.
                
                
                // Extract postcodes from addresses
                let collectionPostcode = 'N/A';
                let deliveryPostcode = 'N/A';
                
                if (job.parsedData?.collection_address) {
                    collectionPostcode = job.parsedData.collection_address;
                }
                
                if (job.parsedData?.postcode_delivery) {
                    deliveryPostcode = job.parsedData.postcode_delivery;
                }
                
                jobPairsHTML += `
                    <div class="flex flex-col gap-1.5">
                        <label class="text-gray-400 font-medium text-xs">Collection ${jobLetter}</label>
                        <p class="text-green-400 font-semibold text-sm">${collectionPostcode}</p>
                    </div>
                    <div class="flex flex-col gap-1.5">
                        <label class="text-gray-400 font-medium text-xs">Delivery ${jobLetter}</label>
                        <p class="text-red-400 font-semibold text-sm">${deliveryPostcode}</p>
                    </div>
                `;
            });
            
            routeDiv.innerHTML = `
                <div class="relative">
                    <!-- Score display in top right corner -->
                    <div class="absolute top-0 right-0 bg-gray-800 rounded-bl-lg px-2 py-1" id="firebase-route-${routeNumber}-score">
                        <span class="text-xs font-bold" id="firebase-route-${routeNumber}-score-text">-</span>
                    </div>
                    
                <!-- Driver Info Line -->
                <div class="flex items-center gap-3 mb-3 text-sm">
                    <div class="flex items-center gap-2">
                        <span class="text-gray-400 font-medium text-xs">REG:</span>
                        <span class="text-white font-bold" id="firebase-route-${routeNumber}-reg">-</span>
                    </div>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <div class="flex items-center gap-2">
                        <span class="text-white font-semibold" id="firebase-route-${routeNumber}-driver">-</span>
                        <button id="firebase-route-${routeNumber}-why-driver" onclick="showWhyThisDriver(${routeNumber})" class="hidden text-blue-400 hover:text-blue-300 transition-colors" title="Why this driver?">
                            <span class="material-symbols-outlined text-sm">info</span>
                        </button>
                    </div>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <div class="flex flex-col">
                        <div class="flex items-center gap-2">
                            <span class="text-gray-400 text-xs">Driver Home:</span>
                            <span class="text-white text-xs font-semibold" id="firebase-route-${routeNumber}-driver-location">-</span>
                        </div>
                        <div id="firebase-route-${routeNumber}-carryover-display" class="hidden flex items-center gap-2 mt-0.5">
                            <span class="text-gray-400 text-xs">(Carryover):</span>
                            <span class="text-red-400 text-xs font-bold" id="firebase-route-${routeNumber}-carryover-postcode">-</span>
                        </div>
                    </div>
                </div>
                    
                <div class="grid grid-cols-${Math.min(jobs.length * 2, 6)} gap-2 text-xs">
                    ${jobPairsHTML}
                </div>
                <div class="mt-3 grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-gray-400 font-medium text-xs mb-1 block" id="firebase-route-${routeNumber}-to-work-label">To First Job</label>
                        <div id="firebase-route-${routeNumber}-to-work" class="bg-[#283039] rounded-lg px-3 py-2 text-gray-500 text-xs">
                            -
                        </div>
                    </div>
                    <div>
                        <label class="text-gray-400 font-medium text-xs mb-1 block">From Last Job</label>
                        <div id="firebase-route-${routeNumber}-from-work" class="bg-[#283039] rounded-lg px-3 py-2 text-gray-500 text-xs">
                            -
                        </div>
                    </div>
                </div>
            `;
            
            // Populate driver information if assigned
            if (routeRecord.assignedDriverName) {
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                
                if (driverElement) {
                    driverElement.textContent = routeRecord.assignedDriverName;
                }
                if (locationElement) {
                    locationElement.textContent = routeRecord.assignedDriverPostcode || '-';
                }
            }
            
            return routeDiv;
        }

        // Show demo routes for optimization
        function showDemoRoutes() {
            document.getElementById('demo-route-1').style.display = 'block';
            document.getElementById('demo-route-2').style.display = 'block';
            document.getElementById('demo-route-3').style.display = 'block';
            document.getElementById('no-routes-message').style.display = 'none';
        }

        // Hide demo routes
        function hideDemoRoutes() {
            document.getElementById('demo-route-1').style.display = 'none';
            document.getElementById('demo-route-2').style.display = 'none';
            document.getElementById('demo-route-3').style.display = 'none';
        }

        // Optimize routes function
        // Global variable to store carry-over postcodes
        let carryOverPostcodes = {};

        async function optimizeRoutes() {
            console.log('optimizeRoutes called, current drivers array length:', drivers.length);
            
            // Only load drivers from Firebase if we don't already have them
            if (drivers.length === 0) {
                console.log('Loading drivers for optimization...');
                await loadDriversFromFirebase();
                console.log('After loadDriversFromFirebase, drivers array length:', drivers.length);
            } else {
                console.log('Using existing drivers for optimization:', drivers.length);
            }
            
            if (drivers.length === 0) {
                alert('No drivers found in database. Please add drivers first.');
                return;
            }
            
            // Show alterations popup before optimization
            showAlterationsPopup();
        }

        // Show alterations popup
        function showAlterationsPopup() {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            overlay.id = 'alterations-overlay';
            
            // Create popup content
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 w-full max-w-md mx-4 border border-[#283039]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Alterations</h3>
                        <button onclick="closeAlterationsPopup()" class="text-gray-400 hover:text-white">
                            <span class="material-symbols-outlined text-xl">close</span>
                        </button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">Carry-Overs</label>
                            <p class="text-xs text-gray-400 mb-3">Set temporary starting locations for drivers (e.g., morning car drop-offs)</p>
                            
                            <div id="carry-overs-list" class="space-y-2">
                                <!-- Carry-over items will be added here -->
                            </div>
                            
                            <div class="mt-3">
                                <select id="carry-over-driver-select" class="w-full bg-[#283039] border border-gray-600 rounded-md px-3 py-2 text-white text-sm">
                                    <option value="">Select a driver...</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="flex gap-3 pt-4">
                            <button onclick="closeAlterationsPopup()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Cancel
                            </button>
                            <button onclick="startOptimization()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Start Optimization
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Populate driver dropdown
            populateDriverDropdown();
            
            // Add event listener for driver selection
            document.getElementById('carry-over-driver-select').addEventListener('change', function() {
                const selectedDriverId = this.value;
                if (selectedDriverId) {
                    addCarryOverDriver(selectedDriverId);
                    this.value = ''; // Reset selection
                }
            });
        }

        // Populate driver dropdown
        function populateDriverDropdown() {
            const select = document.getElementById('carry-over-driver-select');
            select.innerHTML = '<option value="">Select a driver...</option>';
            
            drivers.forEach((driver, index) => {
                // Don't show drivers who already have carry-over set
                if (!carryOverPostcodes[index]) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = driver.name;
                    select.appendChild(option);
                }
            });
        }

        // Add carry-over driver
        function addCarryOverDriver(driverIndex) {
            const driver = drivers[driverIndex];
            const postcode = prompt(`Enter carry-over postcode for ${driver.name}:`);
            
            if (postcode && postcode.trim()) {
                carryOverPostcodes[driverIndex] = postcode.trim().toUpperCase();
                updateCarryOversList();
                populateDriverDropdown(); // Refresh dropdown to remove selected driver
                console.log(`Carry-over set for ${driver.name}: ${postcode.trim().toUpperCase()}`);
            }
        }

        // Update carry-overs list display
        function updateCarryOversList() {
            const listContainer = document.getElementById('carry-overs-list');
            listContainer.innerHTML = '';
            
            Object.keys(carryOverPostcodes).forEach(driverIndex => {
                const driver = drivers[parseInt(driverIndex)];
                const postcode = carryOverPostcodes[driverIndex];
                
                const item = document.createElement('div');
                item.className = 'flex items-center justify-between bg-[#283039] rounded-md px-3 py-2';
                item.innerHTML = `
                    <div>
                        <span class="text-white text-sm font-medium">${driver.name}</span>
                        <span class="text-gray-400 text-xs ml-2">â ${postcode}</span>
                    </div>
                    <button onclick="removeCarryOver(${driverIndex})" class="text-red-400 hover:text-red-300">
                        <span class="material-symbols-outlined text-sm">close</span>
                    </button>
                `;
                listContainer.appendChild(item);
            });
        }

        // Remove carry-over
        function removeCarryOver(driverIndex) {
            delete carryOverPostcodes[driverIndex];
            updateCarryOversList();
            populateDriverDropdown(); // Refresh dropdown to show removed driver
            console.log(`Carry-over removed for ${drivers[driverIndex].name}`);
        }

        // Close alterations popup
        function closeAlterationsPopup() {
            const overlay = document.getElementById('alterations-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Week calculation functions for optimise settings
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
            return new Date(d.setDate(diff));
        }

        function getWeekNumber(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
            const week1 = new Date(d.getFullYear(), 0, 4);
            return 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        }

        // Show optimise settings popup
        function showOptimiseSettings() {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            overlay.id = 'optimise-settings-overlay';
            
            // Create popup content
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 w-full max-w-2xl mx-4 border border-[#283039] max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Optimise Settings</h3>
                        <button onclick="closeOptimiseSettings()" class="text-gray-400 hover:text-white">
                            <span class="material-symbols-outlined text-xl">close</span>
                        </button>
                    </div>
                    
                    <div class="space-y-6">
                        <!-- Day Selection Section -->
                        <div id="day-selection-section">
                            <h4 class="text-lg font-semibold text-white mb-3">1. Select Day</h4>
                            <div class="flex gap-3">
                                <select id="weekSelectOptimise" class="flex-1 bg-[#283039] border border-gray-600 rounded-md px-3 py-2 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="">Choose a week...</option>
                                    <option value="current">Current Week</option>
                                    <option value="next">Next Week</option>
                                </select>
                            </div>
                            <div id="weekDaysOptimise" class="grid grid-cols-2 gap-2 mt-3">
                                <!-- Days will be populated here -->
                            </div>
                        </div>

                        <!-- Driver Overview Section (hidden initially) -->
                        <div id="driver-overview-section" class="hidden">
                            <h4 class="text-lg font-semibold text-white mb-3">2. Driver Availability</h4>
                            
                            <!-- Drivers Off Today -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between mb-3">
                                    <span class="text-white font-medium">Drivers Off Today</span>
                                    <span id="driversOffCount" class="text-red-400 font-bold">0</span>
                                </div>
                                <div id="driversOffList" class="space-y-2">
                                    <!-- Drivers off will be listed here -->
                                </div>
                            </div>

                            <!-- Total Drivers -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-white font-medium">Available Drivers</span>
                                    <span id="totalDriversCount" class="text-blue-400 font-bold text-lg">0/0</span>
                                </div>
                            </div>

                            <!-- Total Routes -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-white font-medium">Routes to Assign</span>
                                    <span id="totalRoutesCount" class="text-green-400 font-bold text-lg">0</span>
                                </div>
                            </div>

                            <!-- Availability Button -->
                            <div class="flex justify-center">
                                <button id="markAsOffBtn" class="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors">
                                    Availability
                                </button>
                            </div>

                            <!-- Driver Selection Dropdown (hidden initially) -->
                            <div id="driverSelectionDropdown" class="hidden mt-4 bg-[#283039] rounded-lg p-4 border border-gray-600">
                                <h5 class="text-white font-medium mb-3">Select Driver Availability</h5>
                                <div id="allDriversList" class="space-y-2 max-h-60 overflow-y-auto">
                                    <!-- All drivers will be listed here -->
                                </div>
                            </div>
                        </div>

                        <!-- Carryover Settings Section -->
                        <div id="carryoverSection" class="hidden">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="material-symbols-outlined text-green-500">local_shipping</span>
                                <h4 class="text-md font-bold text-white">3. Carryover Settings</h4>
                            </div>
                            <p class="text-sm text-gray-400 mb-3">Select drivers who have carryover vehicles to deliver in the morning</p>
                            
                            <!-- Driver Search and Selection -->
                            <div class="mb-3">
                                <input type="text" id="carryoverDriverSearch" placeholder="Search drivers..." 
                                    class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-green-500 mb-2">
                                <div id="carryoverDriverList" class="max-h-48 overflow-y-auto bg-[#283039] rounded-md border border-gray-600">
                                    <!-- Drivers will be populated here -->
                                </div>
                            </div>
                            
                            <!-- Selected Carryovers Display -->
                            <div id="selectedCarryovers" class="hidden mb-3">
                                <h5 class="text-sm font-bold text-white mb-2">Drivers with Carryovers:</h5>
                                <div id="carryoversList" class="space-y-2">
                                    <!-- Carryover items will be added here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex gap-3 pt-4 border-t border-gray-700">
                            <button onclick="closeOptimiseSettings()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Cancel
                            </button>
                            <button id="nextToCarryoverBtn" onclick="showCarryoverSettings()" class="hidden flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                Next
                            </button>
                            <button id="startOptimisationBtn" onclick="startOptimisationWithSettings()" class="hidden flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Start Optimisation
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Ensure day selection section is visible when popup opens
            const daySelectionSection = document.getElementById('day-selection-section');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            if (daySelectionSection) {
                daySelectionSection.style.display = 'block';
            }
            if (weekDaysContainer) {
                weekDaysContainer.style.display = 'block';
            }
            
            // Initialize day selection
            initializeOptimiseDaySelection();
        }

        // Global variables for optimise settings
        let selectedOptimiseDay = null;
        let tempDriversOff = []; // Temporary list of drivers marked as off
        let allDrivers = []; // All drivers for the office

        // Initialize day selection for optimise settings
        function initializeOptimiseDaySelection() {
            const weekSelect = document.getElementById('weekSelectOptimise');
            const markAsOffBtn = document.getElementById('markAsOffBtn');
            
            weekSelect.addEventListener('change', populateOptimiseWeekDays);
            markAsOffBtn.addEventListener('click', toggleDriverSelectionDropdown);
            
            // Click outside to close dropdown
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('driverSelectionDropdown');
                const btn = document.getElementById('markAsOffBtn');
                const allDriversList = document.getElementById('allDriversList');
                
                // Only close if clicking outside the dropdown, button, and driver list
                if (dropdown && !dropdown.contains(e.target) && !btn.contains(e.target) && !allDriversList.contains(e.target)) {
                    dropdown.classList.add('hidden');
                    // Reset button state when closing
                    btn.classList.remove('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                    btn.classList.add('bg-red-600', 'hover:bg-red-700');
                }
            });
        }

        // Populate week days for optimise settings
        function populateOptimiseWeekDays() {
            const weekSelect = document.getElementById('weekSelectOptimise');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            
            if (!weekSelect.value || weekSelect.value === 'selected') {
                weekDaysContainer.innerHTML = '';
                weekDaysContainer.style.display = 'none';
                return;
            }
            
            const weekType = weekSelect.value;
            const days = generateOptimiseWeekDays(weekType);
            
            weekDaysContainer.innerHTML = days.map(day => `
                <button onclick="selectOptimiseDay('${day.date.toISOString()}', '${day.dayName}', '${day.week}')" 
                        class="p-3 bg-[#283039] border border-gray-600 rounded-lg text-white text-sm hover:bg-[#3a4049] transition-colors">
                    <div class="font-medium">${day.dayName}</div>
                    <div class="text-xs text-gray-400">${day.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}</div>
                </button>
            `).join('');
            
            // Show the week days container
            weekDaysContainer.style.display = 'block';
        }

        // Generate week days for optimise settings
        function generateOptimiseWeekDays(weekType) {
            const today = new Date();
            let startDate;
            
            if (weekType === 'current') {
                startDate = getWeekStart(today);
            } else { // next week
                startDate = getWeekStart(today);
                startDate.setDate(startDate.getDate() + 7);
            }
            
            const days = [];
            for (let i = 0; i < 5; i++) { // Monday to Friday only
                const dayDate = new Date(startDate);
                dayDate.setDate(startDate.getDate() + i);
                
                const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const week = getWeekNumber(dayDate);
                
                days.push({
                    date: dayDate,
                    dayName: dayNames[i],
                    week: `${dayDate.getFullYear()}-W${week.toString().padStart(2, '0')}`
                });
            }
            
            return days;
        }

        // Select day for optimise settings
        async function selectOptimiseDay(dateString, dayName, week) {
            selectedOptimiseDay = {
                date: new Date(dateString),
                dayName: dayName,
                week: week
            };
            
            // Minimize the day selection section but keep the week dropdown
            const daySelectionSection = document.getElementById('day-selection-section');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            if (weekDaysContainer) {
                weekDaysContainer.style.display = 'none';
            }
            
            // Show driver overview section
            const driverOverviewSection = document.getElementById('driver-overview-section');
            driverOverviewSection.classList.remove('hidden');
            
            // Update the section title to show selected day
            const sectionTitle = driverOverviewSection.querySelector('h4');
            if (sectionTitle) {
                sectionTitle.textContent = `2. Driver Availability - ${dayName} ${selectedOptimiseDay.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`;
            }
            
            // Update the week dropdown to show selected day but keep functionality
            const weekSelect = document.getElementById('weekSelectOptimise');
            if (weekSelect) {
                const selectedText = `${dayName} ${selectedOptimiseDay.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`;
                // Keep the original options but update the selected one
                const currentValue = weekSelect.value;
                weekSelect.innerHTML = `
                    <option value="">Choose a week...</option>
                    <option value="current" ${currentValue === 'current' ? 'selected' : ''}>Current Week</option>
                    <option value="next" ${currentValue === 'next' ? 'selected' : ''}>Next Week</option>
                `;
                // Add a custom option to show the selected day
                const selectedOption = document.createElement('option');
                selectedOption.value = 'selected';
                selectedOption.textContent = selectedText;
                selectedOption.selected = true;
                weekSelect.appendChild(selectedOption);
            }
            
            // Load drivers and their availability
            await loadDriversForOptimise();
            await loadDriversOffForOptimise();
            
            // Show "Next" button instead of "Start Optimisation"
            document.getElementById('nextToCarryoverBtn').classList.remove('hidden');
            document.getElementById('nextToCarryoverBtn').disabled = false;
        }
        
        // Global variable for carryovers
        let driversWithCarryover = new Map(); // Map<driverId, carryoverPostcode>
        
        // Show carryover settings
        function showCarryoverSettings() {
            // Hide day selection section
            const daySelectionSection = document.getElementById('day-selection-section');
            if (daySelectionSection) {
                daySelectionSection.style.display = 'none';
            }
            
            // Hide driver availability section
            const driverSection = document.querySelector('#optimise-settings-overlay .space-y-6 > div:nth-child(2)');
            if (driverSection) {
                driverSection.style.display = 'none';
            }
            
            // Show carryover section
            const carryoverSection = document.getElementById('carryoverSection');
            carryoverSection.classList.remove('hidden');
            
            // Hide "Next" button, show "Start Optimisation" button
            document.getElementById('nextToCarryoverBtn').classList.add('hidden');
            document.getElementById('startOptimisationBtn').classList.remove('hidden');
            
            // Populate driver list for carryover selection
            populateCarryoverDriverList();
        }
        
        // Populate driver list with search functionality
        function populateCarryoverDriverList() {
            const driverList = document.getElementById('carryoverDriverList');
            const searchInput = document.getElementById('carryoverDriverSearch');
            
            const renderDriverList = (searchTerm = '') => {
                const filteredDrivers = allDrivers.filter(driver => {
                    const driverName = driver.name || `${driver.firstName} ${driver.lastName}`;
                    const isOff = tempDriversOff.some(off => off.id === driver.id || off.id === driver.uid);
                    const matchesSearch = searchTerm === '' || driverName.toLowerCase().includes(searchTerm.toLowerCase());
                    return !isOff && matchesSearch; // Only show available drivers
                });
                
                driverList.innerHTML = filteredDrivers.map(driver => {
                    const driverName = driver.name || `${driver.firstName} ${driver.lastName}`;
                    const hasCarryover = driversWithCarryover.has(driver.id);
                    
                    return `
                        <div onclick="selectDriverForCarryover('${driver.id}', '${driverName.replace(/'/g, "\\'")}  ')" 
                            class="p-3 hover:bg-[#3a4049] transition-colors cursor-pointer border-b border-gray-700 last:border-0 ${hasCarryover ? 'bg-green-900 bg-opacity-20' : ''}">
                            <div class="flex items-center justify-between">
                                <span class="text-white text-sm">${driverName}</span>
                                ${hasCarryover ? '<span class="material-symbols-outlined text-green-500 text-sm">check_circle</span>' : ''}
                            </div>
                        </div>
                    `;
                }).join('') || '<div class="p-3 text-gray-400 text-sm text-center">No drivers found</div>';
            };
            
            // Initial render
            renderDriverList();
            
            // Search functionality
            searchInput.addEventListener('input', (e) => {
                renderDriverList(e.target.value);
            });
        }
        
        // Select driver for carryover
        function selectDriverForCarryover(driverId, driverName) {
            // Show input modal for carryover postcode
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[110]';
            overlay.id = 'carryover-postcode-overlay';
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 max-w-md w-full mx-4 border border-gray-600">
                    <h3 class="text-lg font-bold text-white mb-4">Carryover for ${driverName}</h3>
                    <div class="mb-4">
                        <label class="block text-sm text-gray-400 mb-2">Carryover Postcode</label>
                        <input type="text" id="carryover-postcode-input" 
                            class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
                            placeholder="e.g., SW1A 1AA">
                        <p id="carryover-validation-error" class="text-red-500 text-xs mt-1 hidden"></p>
                    </div>
                    <div class="flex gap-3">
                        <button onclick="closeCarryoverPostcodeModal()" 
                            class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm font-bold">
                            Cancel
                        </button>
                        <button onclick="saveCarryoverPostcode('${driverId}', '${driverName.replace(/'/g, "\\'")} ')" 
                            class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-bold">
                            Save
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Focus and pre-fill if exists
            setTimeout(() => {
                const input = document.getElementById('carryover-postcode-input');
                if (driversWithCarryover.has(driverId)) {
                    input.value = driversWithCarryover.get(driverId);
                }
                input.focus();
                input.select();
            }, 100);
        }
        
        // Save carryover postcode
        function saveCarryoverPostcode(driverId, driverName) {
            const input = document.getElementById('carryover-postcode-input');
            const errorElement = document.getElementById('carryover-validation-error');
            const value = input.value.trim().toUpperCase();
            
            if (!value) {
                errorElement.textContent = 'Postcode is required';
                errorElement.classList.remove('hidden');
                return;
            }
            
            // Validate UK postcode format
            const postcodePattern = /^[A-Z]{1,2}\d{1,2}[A-Z]?\s?\d[A-Z]{2}$/i;
            if (!postcodePattern.test(value)) {
                errorElement.textContent = 'Please enter a valid UK postcode';
                errorElement.classList.remove('hidden');
                return;
            }
            
            // Normalize postcode (add space before last 3 chars if needed)
            const cleaned = value.replace(/\s+/g, '');
            const normalized = `${cleaned.slice(0, -3)} ${cleaned.slice(-3)}`;
            
            // Save carryover
            driversWithCarryover.set(driverId, normalized);
            
            // Close modal
            closeCarryoverPostcodeModal();
            
            // Update UI
            updateCarryoverDisplay();
            populateCarryoverDriverList();
        }
        
        // Close carryover postcode modal
        function closeCarryoverPostcodeModal() {
            const overlay = document.getElementById('carryover-postcode-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Update carryover display
        function updateCarryoverDisplay() {
            const selectedCarryoversSection = document.getElementById('selectedCarryovers');
            const carryoversList = document.getElementById('carryoversList');
            
            if (driversWithCarryover.size > 0) {
                selectedCarryoversSection.classList.remove('hidden');
                
                const items = [];
                driversWithCarryover.forEach((postcode, driverId) => {
                    const driver = allDrivers.find(d => d.id === driverId);
                    const driverName = driver ? (driver.name || `${driver.firstName} ${driver.lastName}`) : 'Unknown';
                    
                    items.push(`
                        <div class="flex items-center justify-between p-2 bg-[#283039] rounded">
                            <div>
                                <span class="text-white text-sm font-medium">${driverName}</span>
                                <span class="text-red-400 text-sm font-bold ml-2">${postcode}</span>
                            </div>
                            <button onclick="removeCarryover('${driverId}')" class="text-gray-400 hover:text-white transition-colors">
                                <span class="material-symbols-outlined text-sm">close</span>
                            </button>
                        </div>
                    `);
                });
                
                carryoversList.innerHTML = items.join('');
            } else {
                selectedCarryoversSection.classList.add('hidden');
            }
        }
        
        // Remove carryover
        function removeCarryover(driverId) {
            driversWithCarryover.delete(driverId);
            updateCarryoverDisplay();
            populateCarryoverDriverList();
        }

        // Load office logo from Firebase
        async function loadOfficeLogo(officeId) {
            if (!officeId) {
                console.log('No officeId provided, skipping logo load');
                return;
            }
            
            console.log('Loading office logo for officeId:', officeId);
            
            try {
                // Wait for Firebase to be ready with retries
                let attempts = 0;
                while (attempts < 20 && (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc)) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc) {
                    console.error('Firebase not ready after waiting');
                    console.log('Available Firebase:', { firestore: !!window.firestore, firebaseGetDoc: !!window.firebaseGetDoc, firebaseDoc: !!window.firebaseDoc });
                    return;
                }
                
                console.log('Fetching office document...');
                const officeDoc = await window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'offices', officeId));
                
                if (!officeDoc.exists()) {
                    console.log('Office document does not exist');
                    return;
                }
                
                const officeData = officeDoc.data();
                console.log('Office data:', officeData);
                console.log('Office logoUrl:', officeData.logoUrl);
                
                const logoImg = document.getElementById('officeLogoImg');
                if (!logoImg) {
                    console.error('Logo image element not found');
                    return;
                }
                
                if (officeData.logoUrl) {
                    console.log('Setting logo image source to:', officeData.logoUrl);
                    logoImg.src = officeData.logoUrl;
                    // Force reload if image is cached
                    logoImg.onload = function() {
                        console.log('Logo image loaded successfully');
                    };
                    logoImg.onerror = function() {
                        console.error('Error loading logo image, falling back to default');
                        logoImg.src = '/assets/logos/favicon.svg';
                    };
                } else {
                    console.log('No logoUrl in office data, keeping default logo');
                }
            } catch (error) {
                console.error('Error loading office logo:', error);
                console.error('Error details:', error.message, error.stack);
                // Fallback to default logo (already set in HTML)
            }
        }

        // Load all drivers for the office
        async function loadDriversForOptimise() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context available when loading drivers.');
                    document.getElementById('totalDriversCount').textContent = '0';
                    return;
                }
                
                // Load office logo
                await loadOfficeLogo(officeId);
                
                console.log('Loading drivers for office:', officeId);
                
                const driversCollection = window.firebaseCollection(window.firestore, 'drivers');
                const driversQuery = window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', officeId));
                
                let [driversSnapshot, legacySnapshot] = await Promise.all([
                    window.firebaseGetDocs(driversQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy drivers query failed (likely no legacy docs):', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);
                
                allDrivers = [];
                
                const driverDocs = [...driversSnapshot.docs, ...(legacySnapshot?.docs || [])];
                
                for (const doc of driverDocs) {
                    const driverData = doc.data();
                    if (driverData.officeId && driverData.officeId !== officeId) {
                        continue;
                    }
                    
                    if (!driverData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(doc.ref, { officeId });
                            driverData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for driver ${doc.id}:`, error);
                            continue;
                        }
                    }
                    
                    allDrivers.push({
                        id: doc.id,
                        ...driverData
                    });
                }
                
                // Sort drivers alphabetically by name (handle missing names)
                allDrivers.sort((a, b) => {
                    const nameA = a.name || a.firstName + ' ' + a.lastName || 'Unknown';
                    const nameB = b.name || b.firstName + ' ' + b.lastName || 'Unknown';
                    return nameA.localeCompare(nameB);
                });
                
                // Update total drivers count (will be updated with fraction in updateDriversOffDisplay)
                // document.getElementById('totalDriversCount').textContent = allDrivers.length;
                
                console.log(`Loaded ${allDrivers.length} drivers for optimise settings:`, allDrivers);
                console.log('Driver IDs in collection:', allDrivers.map(d => d.id));
                console.log('Driver UIDs in collection:', allDrivers.map(d => d.uid));
            } catch (error) {
                console.error('Error loading drivers for optimise:', error);
                // Set count to 0 on error
                document.getElementById('totalDriversCount').textContent = '0';
            }
        }

        // Load drivers off for the selected day
        async function loadDriversOffForOptimise() {
            try {
                if (!selectedOptimiseDay) return;
                
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] Missing office context when loading drivers off.');
                    tempDriversOff = [];
                    updateDriversOffDisplay();
                    return;
                }
                
                const dateString = selectedOptimiseDay.date.toISOString().split('T')[0]; // YYYY-MM-DD
                console.log('Loading drivers off for date:', dateString);
                console.log('Available drivers:', allDrivers);
                
                const calendarDoc = await window.firebaseGetDoc(
                    window.firebaseDoc(window.firestore, 'calendar', dateString)
                );
                
                tempDriversOff = []; // Reset temporary list
                
                if (calendarDoc.exists()) {
                    const calendarData = calendarDoc.data();
                    
                    if (calendarData.officeId && calendarData.officeId !== officeId) {
                        console.warn('[OPTIMISATION] Calendar entry belongs to a different office. Ignoring legacy data.');
                        updateDriversOffDisplay();
                        return;
                    }
                    
                    if (!calendarData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(calendarDoc.ref, { officeId });
                        } catch (error) {
                            console.warn('Failed to backfill officeId on calendar entry:', error);
                        }
                    }
                    
                    const driversOff = calendarData.driversOff || [];
                    console.log('Calendar document found:', calendarData);
                    console.log('Drivers off in calendar:', driversOff);
                    
                    // Populate tempDriversOff with actual drivers off from Firebase
                    driversOff.forEach(driverOff => {
                        console.log('Looking for driver with ID:', driverOff.driverId);
                        console.log('Driver off object structure:', driverOff);
                        console.log('Available driver IDs:', allDrivers.map(d => d.id));
                        console.log('Available driver UIDs:', allDrivers.map(d => d.uid));
                        
                        // Try to match by Firebase Auth UID first, then by Firestore document ID
                        const driver = allDrivers.find(d => d.uid === driverOff.driverId || d.id === driverOff.driverId);
                        if (driver) {
                            console.log('Found matching driver:', driver);
                            tempDriversOff.push({
                                id: driver.id,
                                name: driver.name || (driver.firstName + ' ' + driver.lastName) || driverOff.driverName || 'Unknown Driver',
                                email: driver.email
                            });
                        } else {
                            console.log('No matching driver found for ID:', driverOff.driverId);
                            console.log('Available drivers:', allDrivers);
                        }
                    });
                } else {
                    console.log('No calendar document found for date:', dateString);
                }
                
                updateDriversOffDisplay();
                console.log(`Loaded ${tempDriversOff.length} drivers off for ${dateString}`);
            } catch (error) {
                console.error('Error loading drivers off for optimise:', error);
            }
        }

        // Update the drivers off display
        function updateDriversOffDisplay() {
            const driversOffList = document.getElementById('driversOffList');
            const driversOffCount = document.getElementById('driversOffCount');
            const totalDriversCount = document.getElementById('totalDriversCount');
            const totalRoutesCount = document.getElementById('totalRoutesCount');
            
            const totalDrivers = allDrivers.length;
            const driversOff = tempDriversOff.length;
            const availableDrivers = totalDrivers - driversOff;
            
            // Update drivers off count
            driversOffCount.textContent = driversOff;
            
            // Update total drivers count with fraction format
            totalDriversCount.textContent = `${availableDrivers}/${totalDrivers}`;
            
            // Update total routes count
            const routeCount = savedRoutes ? savedRoutes.length : 0;
            totalRoutesCount.textContent = routeCount;
            
            if (tempDriversOff.length === 0) {
                driversOffList.innerHTML = '<p class="text-gray-400 text-sm">No drivers off today</p>';
            } else {
                driversOffList.innerHTML = tempDriversOff.map(driver => `
                    <div class="flex items-center justify-between bg-[#1a1f24] rounded-lg p-2">
                        <span class="text-white text-sm">${driver.name}</span>
                        <button onclick="removeDriverFromOff('${driver.id}')" class="text-red-400 hover:text-red-300 text-sm">
                            Remove
                        </button>
                    </div>
                `).join('');
            }
        }

        // Toggle driver selection dropdown
        function toggleDriverSelectionDropdown() {
            const dropdown = document.getElementById('driverSelectionDropdown');
            const button = document.getElementById('markAsOffBtn');
            
            dropdown.classList.toggle('hidden');
            
            if (!dropdown.classList.contains('hidden')) {
                // Show dropdown - indicate button is active with red gradient
                button.classList.remove('bg-red-600', 'hover:bg-red-700');
                button.classList.add('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                populateAllDriversList();
            } else {
                // Hide dropdown - reset button to normal red state
                button.classList.remove('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                button.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }

        // Populate all drivers list for selection
        function populateAllDriversList() {
            const allDriversList = document.getElementById('allDriversList');
            
            // Sort drivers: off drivers first, then alphabetical
            const sortedDrivers = [...allDrivers].sort((a, b) => {
                const aIsOff = tempDriversOff.some(off => off.id === a.id);
                const bIsOff = tempDriversOff.some(off => off.id === b.id);
                
                if (aIsOff && !bIsOff) return -1;
                if (!aIsOff && bIsOff) return 1;
                
                const nameA = a.name || (a.firstName + ' ' + a.lastName) || 'Unknown';
                const nameB = b.name || (b.firstName + ' ' + b.lastName) || 'Unknown';
                return nameA.localeCompare(nameB);
            });
            
            allDriversList.innerHTML = sortedDrivers.map(driver => {
                const isOff = tempDriversOff.some(off => off.id === driver.id);
                const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
                return `
                    <button onclick="event.stopPropagation(); toggleDriverOffStatus('${driver.id}', '${driverName}', '${driver.email}')" 
                            class="w-full flex items-center justify-between p-2 rounded-lg text-left transition-colors ${
                                isOff ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-[#1a1f24] hover:bg-[#3a4049] text-white'
                            }">
                        <span class="text-sm">${driverName}</span>
                        <span class="text-xs ${isOff ? 'text-red-200' : 'text-gray-400'}">
                            ${isOff ? 'OFF' : 'Available'}
                        </span>
                    </button>
                `;
            }).join('');
        }

        // Toggle driver off status
        function toggleDriverOffStatus(driverId, driverName, driverEmail) {
            const existingIndex = tempDriversOff.findIndex(driver => driver.id === driverId);
            
            if (existingIndex > -1) {
                // Remove from off list
                tempDriversOff.splice(existingIndex, 1);
            } else {
                // Add to off list
                tempDriversOff.push({
                    id: driverId,
                    name: driverName,
                    email: driverEmail
                });
            }
            
            updateDriversOffDisplay();
            populateAllDriversList(); // Refresh the dropdown
        }

        // Remove driver from off list
        function removeDriverFromOff(driverId) {
            const index = tempDriversOff.findIndex(driver => driver.id === driverId);
            if (index > -1) {
                tempDriversOff.splice(index, 1);
                updateDriversOffDisplay();
                populateAllDriversList(); // Refresh the dropdown
            }
        }

        // Close optimise settings popup
        function closeOptimiseSettings() {
            const overlay = document.getElementById('optimise-settings-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Reset variables
            selectedOptimiseDay = null;
            tempDriversOff = [];
            allDrivers = [];
        }

        // Start optimisation with settings
        async function startOptimisationWithSettings() {
            if (!selectedOptimiseDay) {
                alert('Please select a day first');
                return;
            }
            
            // Simple approach: Get all office drivers, filter out the ones marked as off (BEFORE closing popup)
            console.log('Starting simple optimization...');
            console.log('All drivers:', allDrivers);
            console.log('Drivers marked as off:', tempDriversOff);
            
            const availableDrivers = allDrivers.filter(driver => {
                const isOff = tempDriversOff.some(off => off.id === driver.id || off.id === driver.uid);
                return !isOff;
            });
            
            console.log(`Available drivers for optimization: ${availableDrivers.length}`);
            
            if (availableDrivers.length === 0) {
                alert('No drivers available for optimization');
                closeOptimiseSettings();
                return;
            }
            
            // Close the settings popup
            closeOptimiseSettings();
            
            // Show progress modal
            showOptimizationProgress();
            
            // Use the optimal assignment algorithm instead of simple direct assignment
            await assignDriversToSavedRoutes(availableDrivers);
            
            // Track optimization usage for billing
            await trackOptimizationUsage();
            
            // Hide progress modal
            hideOptimizationProgress();
        }
        
        // Global progress tracking variables
        let optimizationStartTime = null;
        let totalCalculations = 0;
        let completedCalculations = 0;
        
        // Show optimization progress modal
        function showOptimizationProgress() {
            optimizationStartTime = Date.now();
            completedCalculations = 0;
            
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100]';
            overlay.id = 'optimization-progress-overlay';
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-8 w-full max-w-md mx-4 border border-[#283039]">
                    <!-- Header -->
                    <div class="text-center mb-6">
                        <div class="inline-flex items-center justify-center w-16 h-16 bg-green-600 bg-opacity-20 rounded-full mb-4">
                            <span class="material-symbols-outlined text-4xl text-green-500 animate-spin">settings</span>
                        </div>
                        <h3 class="text-2xl font-bold text-white mb-2">Optimizing Routes</h3>
                        <p class="text-gray-400 text-sm">Please wait while we find the best driver assignments...</p>
                    </div>
                    
                    <!-- Progress Bar -->
                    <div class="mb-6">
                        <div class="w-full bg-[#283039] rounded-full h-3 overflow-hidden">
                            <div id="optimization-progress-bar" class="h-full bg-gradient-to-r from-green-600 to-green-400 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                        <p id="optimization-progress-text" class="text-center text-sm text-gray-400 mt-2">Initializing...</p>
                        <p id="optimization-time-estimate" class="text-center text-xs text-gray-500 mt-1">Calculating time estimate...</p>
                    </div>
                    
                    <!-- Current Step -->
                    <div class="space-y-3">
                        <div id="optimization-step-1" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Loading routes</span>
                        </div>
                        <div id="optimization-step-2" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Fetching driver data</span>
                        </div>
                        <div id="optimization-step-3" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Calculating distances</span>
                        </div>
                        <div id="optimization-step-4" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Running optimization</span>
                        </div>
                        <div id="optimization-step-5" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Assigning drivers</span>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        // Update optimization progress with time estimate
        function updateOptimizationProgress(step, percentage, text, currentCalc = null, total = null) {
            const progressBar = document.getElementById('optimization-progress-bar');
            const progressText = document.getElementById('optimization-progress-text');
            const timeEstimate = document.getElementById('optimization-time-estimate');
            const stepElement = document.getElementById(`optimization-step-${step}`);
            
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
            
            if (progressText) {
                progressText.textContent = text || `${percentage}%`;
            }
            
            // Update time estimate if we have calculation progress
            if (timeEstimate && currentCalc && total && completedCalculations > 0) {
                const elapsed = (Date.now() - optimizationStartTime) / 1000; // seconds
                const avgTimePerCalc = elapsed / completedCalculations;
                const remaining = total - completedCalculations;
                const estimatedRemaining = Math.ceil(avgTimePerCalc * remaining);
                
                if (estimatedRemaining > 60) {
                    const mins = Math.floor(estimatedRemaining / 60);
                    const secs = estimatedRemaining % 60;
                    timeEstimate.textContent = `Estimated time remaining: ${mins}m ${secs}s`;
                } else {
                    timeEstimate.textContent = `Estimated time remaining: ${estimatedRemaining}s`;
                }
            } else if (timeEstimate) {
                timeEstimate.textContent = 'Calculating time estimate...';
            }
            
            if (stepElement) {
                // Mark current step as active
                stepElement.classList.remove('opacity-50');
                stepElement.classList.add('bg-green-600', 'bg-opacity-20');
                stepElement.querySelector('.material-symbols-outlined').textContent = 'check_circle';
                stepElement.querySelector('.material-symbols-outlined').classList.remove('text-gray-500');
                stepElement.querySelector('.material-symbols-outlined').classList.add('text-green-500');
                stepElement.querySelector('span:last-child').classList.remove('text-gray-400');
                stepElement.querySelector('span:last-child').classList.add('text-white');
            }
        }
        
        // Track optimization usage for billing
        async function trackOptimizationUsage() {
            try {
                const officeId = getCurrentOfficeId();
                
                if (!officeId) {
                    console.warn('No office ID found for tracking');
                    return;
                }
                
                // Get current date
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1; // 1-12
                const day = now.getDate();
                
                // Create document ID based on office, year, month, day
                const docId = `${officeId}_${year}_${String(month).padStart(2, '0')}_${String(day).padStart(2, '0')}`;
                
                // Check if document exists for today
                const usageDocRef = window.firebaseDoc(window.firestore, 'optimization_usage', docId);
                const usageDoc = await window.firebaseGetDoc(usageDocRef);
                
                if (usageDoc.exists()) {
                    // Increment count
                    const currentCount = usageDoc.data().count || 0;
                    await window.firebaseSetDoc(usageDocRef, {
                        officeId: officeId,
                        year: year,
                        month: month,
                        day: day,
                        count: currentCount + 1,
                        lastOptimization: now
                    });
                    console.log(`ð Usage tracked: ${officeId} - Day ${day}/${month}/${year} - Count: ${currentCount + 1}`);
                } else {
                    // Create new document with count = 1
                    await window.firebaseSetDoc(usageDocRef, {
                        officeId: officeId,
                        year: year,
                        month: month,
                        day: day,
                        count: 1,
                        firstOptimization: now,
                        lastOptimization: now
                    });
                    console.log(`ð Usage tracked: ${officeId} - Day ${day}/${month}/${year} - Count: 1 (first)`);
                }
            } catch (error) {
                console.error('Error tracking optimization usage:', error);
                // Don't throw error - tracking shouldn't block optimization
            }
        }
        
        // Hide optimization progress modal with completion animation
        function hideOptimizationProgress() {
            // Show 100% completion
            updateOptimizationProgress(5, 100, 'Complete!');
            
            // Change spinner to check icon
            setTimeout(() => {
                const spinner = document.querySelector('#optimization-progress-overlay .material-symbols-outlined.animate-spin');
                if (spinner) {
                    spinner.classList.remove('animate-spin');
                    spinner.textContent = 'check_circle';
                }
            }, 100);
            
            // Hide after a delay
            setTimeout(() => {
                const overlay = document.getElementById('optimization-progress-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }, 1500);
        }

        // Simple direct assignment function
        async function assignDriversToRoutesDirect(driversToUse) {
            console.log('Direct assignment with drivers:', driversToUse.length);
            console.log('Routes to assign:', savedRoutes.length);
            
            if (savedRoutes.length === 0 || driversToUse.length === 0) {
                console.log('No routes or drivers available for assignment');
                return;
            }
            
            // Simple assignment: assign drivers to routes in order
            for (let i = 0; i < savedRoutes.length && i < driversToUse.length; i++) {
                const route = savedRoutes[i];
                const driver = driversToUse[i];
                
                console.log(`Assigning driver ${driver.name || (driver.firstName + ' ' + driver.lastName)} to route ${i + 1}`);
                
                // Update the route with driver assignment (save in nested route object)
                route.route.assignedDriver = driver;
                route.route.assignedDriverName = driver.name || (driver.firstName + ' ' + driver.lastName);
                route.route.assignedDriverPostcode = driver.homePostcode || driver.postcode;
                
                // Update the UI elements immediately
                const routeNumber = i + 1;
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                
                if (driverElement) {
                    driverElement.textContent = route.route.assignedDriverName;
                }
                if (locationElement) {
                    locationElement.textContent = route.route.assignedDriverPostcode;
                }
                
                // Calculate and display distances
                await updateRouteDistances(routeNumber, route.route.assignedDriverPostcode, route.jobs);
            }
            
            // Save the assignments to Firebase (with driver assignment data)
            await saveRoutesToFirebase();
            
            // Don't reload from Firebase - keep current assignments in memory
            // await displayRoutesFromFirebase(); // Removed to preserve driver assignments
            
            alert(`Optimization complete! Assigned ${Math.min(savedRoutes.length, driversToUse.length)} drivers to routes.`);
        }

        // Convert minutes to hours and minutes
        function formatTime(minutes) {
            if (minutes < 60) {
                return `${minutes}m`;
            }
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }

        // Format travel option for display (collapsed by default)
        function formatTravelOptionForRoute(option, routeNumber, direction, useMixedMode = false) {
            if (!option || !option.success) {
                return '<span class="text-red-400 text-xs">Error</span>';
            }
            
            const detailsId = `${routeNumber}-${direction}-details`;
            const mixedDetailsId = `${routeNumber}-${direction}-mixed-details`;
            
            // Handle requires_authorization mode (show train station route with red car)
            if (option.mode === 'requires_authorization') {
                if (option.driveToStation && option.transitFromStation) {
                    const totalTime = option.totalDuration;
                    const driveTime = option.driveToStation.duration;
                    const transitTime = option.transitFromStation.duration;
                    
                    const stepsHTML = `
                        <div class="flex items-center gap-1">
                            <span class="material-symbols-outlined text-red-500 font-bold" style="font-size: 12px;">local_taxi</span>
                            <span class="text-white text-xs font-bold">${formatTime(driveTime)}</span>
                            <span class="text-gray-400 text-xs">to ${option.trainStation.name}</span>
                        </div>
                        ${option.transitFromStation.steps.map(step => {
                            if (step.type === 'transit') {
                                const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                                const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                                const stationName = step.mode !== 'BUS' && step.departure ? ` (${step.departure})` : '';
                                return `
                                    <div class="flex items-center gap-1">
                                        <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                        <span class="text-white text-xs">${formatTime(step.duration)}${stationName}</span>
                                    </div>
                                `;
                            } else if (step.type === 'walk') {
                                return `
                                    <div class="flex items-center gap-1">
                                        <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                        <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                    </div>
                                `;
                            }
                            return '';
                        }).join('')}
                    `;
                    
                    return `
                        <div>
                            <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#1a1f24] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${detailsId}')">
                                <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">warning</span>
                                <span class="text-white text-xs font-bold">${formatTime(totalTime)}</span>
                                <span class="text-xs text-yellow-400">(Auth Req'd)</span>
                                <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${detailsId}-icon">expand_more</span>
                            </div>
                            <div id="${detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                ${stepsHTML}
                            </div>
                        </div>
                    `;
                } else {
                    // No station found or no transit from station
                    return `
                        <div class="flex items-center gap-1.5">
                            <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">warning</span>
                            <span class="text-white text-xs font-bold">${formatTime(option.originalDrivingDuration)}</span>
                            <span class="text-xs text-yellow-400">(Auth Req'd)</span>
                        </div>
                    `;
                }
            }
            
            if (option.mode === 'taxi') {
                return `
                    <div class="flex items-center gap-1.5">
                        <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">local_taxi</span>
                        <span class="text-white text-xs font-bold">${formatTime(option.duration)}</span>
                    </div>
                `;
            } else {
                // Check if mixed mode route exists
                const hasMixedMode = option.mixedModeRoute && option.mixedModeRoute.duration < option.duration;
                
                if (hasMixedMode) {
                    // Display both routes side-by-side
                    const mixedMode = option.mixedModeRoute;
                    const timeSavings = option.duration - mixedMode.duration;
                    
                    // Render mixed mode steps
                    const mixedStepsHTML = mixedMode.allSteps.map(step => {
                        if (step.type === 'drive') {
                            // Check if this is an authorized route (red car) or regular mixed mode (green car)
                            const isAuthorized = option.mode === 'requires_authorization';
                            const carColor = isAuthorized ? 'text-red-500 font-bold' : 'text-green-500';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${carColor}" style="font-size: 12px; font-weight: ${isAuthorized ? 'bold' : 'normal'};">local_taxi</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        } else if (step.type === 'transit') {
                            const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                            const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                            const stationName = step.mode !== 'BUS' && step.departure ? ` (${step.departure})` : '';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}${stationName}</span>
                                </div>
                            `;
                        } else if (step.type === 'walk') {
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                    <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        }
                        return '';
                    }).filter(h => h).join('');
                    
                    // Render original transit steps
                    const originalStepsHTML = (option.allSteps || []).map(step => {
                        if (step.type === 'transit') {
                            const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                            const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                            const stationName = step.mode !== 'BUS' && step.departure ? ` (${step.departure})` : '';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}${stationName}</span>
                                </div>
                            `;
                        } else if (step.type === 'walk') {
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                    <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        }
                        return '';
                    }).filter(h => h).join('');
                    
                    // Determine display order based on useMixedMode flag
                    const leftRoute = useMixedMode ? {
                        label: 'Mixed Mode',
                        time: mixedMode.duration,
                        stepsHTML: mixedStepsHTML,
                        detailsId: mixedDetailsId,
                        icon: 'add_road',
                        iconColor: 'text-green-500',
                        timeSavings: timeSavings
                    } : {
                        label: 'Full Transit',
                        time: option.duration,
                        stepsHTML: originalStepsHTML,
                        detailsId: detailsId,
                        icon: 'directions_transit',
                        iconColor: 'text-blue-400',
                        timeSavings: null
                    };
                    
                    const rightRoute = useMixedMode ? {
                        label: 'Full Transit',
                        time: option.duration,
                        stepsHTML: originalStepsHTML,
                        detailsId: detailsId,
                        icon: 'directions_transit',
                        iconColor: 'text-blue-400',
                        timeSavings: null
                    } : {
                        label: 'Mixed Mode',
                        time: mixedMode.duration,
                        stepsHTML: mixedStepsHTML,
                        detailsId: mixedDetailsId,
                        icon: 'add_road',
                        iconColor: 'text-green-500',
                        timeSavings: timeSavings
                    };
                    
                    return `
                        <div class="grid grid-cols-2 gap-2">
                            <!-- Left Route (Always primary/used for optimization) -->
                            <div class="bg-[#1a1f24] rounded p-2 border-2 border-green-500">
                                <div class="text-xs text-gray-400 mb-1">${leftRoute.label}</div>
                                <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#283039] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${leftRoute.detailsId}')">
                                    <span class="material-symbols-outlined ${leftRoute.iconColor}" style="font-size: 14px;">${leftRoute.icon}</span>
                                    <span class="text-white text-xs font-bold">${formatTime(leftRoute.time)}</span>
                                    <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${leftRoute.detailsId}-icon">expand_more</span>
                                </div>
                                <div id="${leftRoute.detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                    ${leftRoute.timeSavings ? `<div class="text-green-500 text-xs font-bold mb-1">Saves ${formatTime(leftRoute.timeSavings)}</div>` : ''}
                                    ${leftRoute.stepsHTML}
                                </div>
                            </div>
                            
                            <!-- Right Route (Alternative option) -->
                            <div class="bg-[#1a1f24] rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">${rightRoute.label}</div>
                                <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#283039] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${rightRoute.detailsId}')">
                                    <span class="material-symbols-outlined ${rightRoute.iconColor}" style="font-size: 14px;">${rightRoute.icon}</span>
                                    <span class="text-white text-xs font-bold">${formatTime(rightRoute.time)}</span>
                                    <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${rightRoute.detailsId}-icon">expand_more</span>
                                </div>
                                <div id="${rightRoute.detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                    ${rightRoute.timeSavings ? `<div class="text-green-500 text-xs font-bold mb-1">Saves ${formatTime(rightRoute.timeSavings)}</div>` : ''}
                                    ${rightRoute.stepsHTML}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // No mixed mode - show single transit route
                const allSteps = option.allSteps || [];
                const stepsHTML = allSteps.map(step => {
                    if (step.type === 'transit') {
                        const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                        const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                        const stationName = step.mode !== 'BUS' && step.departure ? ` (${step.departure})` : '';
                        return `
                            <div class="flex items-center gap-1">
                                <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                <span class="text-white text-xs">${formatTime(step.duration)}${stationName}</span>
                            </div>
                        `;
                    } else if (step.type === 'walk') {
                        return `
                            <div class="flex items-center gap-1">
                                <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                            </div>
                        `;
                    }
                    return '';
                }).filter(h => h).join('');
                
                return `
                    <div>
                        <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#1a1f24] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${detailsId}')">
                            <span class="material-symbols-outlined text-blue-400" style="font-size: 14px;">directions_transit</span>
                            <span class="text-white text-xs font-bold">${formatTime(option.duration)}</span>
                            <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${detailsId}-icon">expand_more</span>
                        </div>
                        <div id="${detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                            ${stepsHTML}
                        </div>
                    </div>
                `;
                }
            }
        }
        
        // Toggle travel details expansion
        function toggleTravelDetails(detailsId) {
            const detailsElement = document.getElementById(detailsId);
            const iconElement = document.getElementById(`${detailsId}-icon`);
            if (detailsElement && iconElement) {
                detailsElement.classList.toggle('hidden');
                iconElement.textContent = detailsElement.classList.contains('hidden') ? 'expand_more' : 'expand_less';
            }
        }

        // Update route distances using Google Maps API
        async function updateRouteDistances(routeNumber, driverPostcode, jobs) {
            console.log(`ð updateRouteDistances called for route ${routeNumber}`);
            if (!jobs || jobs.length === 0) {
                console.log(`â ï¸ No jobs for route ${routeNumber}`);
                return;
            }
            
            
            try {
                const firstJob = jobs[0];
                const lastJob = jobs[jobs.length - 1];
                
                const collectionAddress = firstJob.parsedData?.collection_address || firstJob.collectionAddress;
                const deliveryAddress = lastJob.parsedData?.postcode_delivery || lastJob.deliveryAddress;
                
                console.log(`ð¦ Route ${routeNumber} - Driver: ${driverPostcode}, Collection: ${collectionAddress}, Delivery: ${deliveryAddress}`);
                
                // Calculate travel options from driver to first collection (arrive by 8 AM)
                console.log(`ð Calculating TO work for route ${routeNumber}...`);
                const toWorkOptions = await calculateTravelOptions(driverPostcode, collectionAddress, true);
                
                // Calculate travel options from last delivery back to driver (depart at 6 PM)
                console.log(`ð  Calculating FROM work for route ${routeNumber}...`);
                const fromWorkOptions = await calculateTravelOptions(deliveryAddress, driverPostcode, false);
                
                // Update the UI elements
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                
                if (toWorkElement) {
                    toWorkElement.innerHTML = formatTravelOptionForRoute(toWorkOptions, `route-${routeNumber}`, 'to-work');
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = formatTravelOptionForRoute(fromWorkOptions, `route-${routeNumber}`, 'from-work');
                }
                
            } catch (error) {
                console.error(`Error calculating travel options for route ${routeNumber}:`, error);
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                if (toWorkElement) {
                    toWorkElement.innerHTML = '<span class="text-red-400 text-xs">Error</span>';
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = '<span class="text-red-400 text-xs">Error</span>';
                }
            }
        }

        // Calculate distance between two addresses using Firebase Functions
        async function calculateDistance(origin, destination) {
            try {
                const calculateDistanceFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateDistance');
                const result = await calculateDistanceFunction({
                    origin: origin,
                    destination: destination
                });
                
                if (result.data.success) {
                    return result.data.distance;
                } else {
                    throw new Error(result.data.error || 'Distance calculation failed');
                }
            } catch (error) {
                console.error('Error calculating distance:', error);
                throw error;
            }
        }

        // Get next Monday for accurate weekday transit schedules
        function getNextMonday() {
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            let daysUntilMonday;
            if (dayOfWeek === 0) {
                // Today is Sunday, next Monday is tomorrow
                daysUntilMonday = 1;
            } else if (dayOfWeek === 1) {
                // Today is Monday, use next Monday
                daysUntilMonday = 7;
            } else {
                // Today is Tuesday-Saturday, calculate days until next Monday
                daysUntilMonday = (8 - dayOfWeek) % 7;
                if (daysUntilMonday === 0) daysUntilMonday = 7;
            }
            
            const nextMonday = new Date(today);
            nextMonday.setDate(today.getDate() + daysUntilMonday);
            
            console.log(`ð Today: ${today.toLocaleDateString()} (${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]})`);
            console.log(`ð Using next Monday: ${nextMonday.toLocaleDateString()} for transit calculations`);
            
            return nextMonday;
        }

        // Calculate travel options (taxi vs public transport) using Firebase Functions
        async function calculateTravelOptions(origin, destination, isToWork = true) {
            try {
                console.log(`ð Calculating travel options: ${origin} â ${destination} (${isToWork ? 'TO work' : 'FROM work'})`);
                
                // Use departure times for more realistic routes
                // TO work: Depart at 7 AM (arrive by 8 AM)
                // FROM work: Depart at 6 PM
                // Calculate for next Monday to get accurate weekday transit schedules
                const nextMonday = getNextMonday();
                
                const departAt7AM = new Date(nextMonday.getFullYear(), nextMonday.getMonth(), nextMonday.getDate(), 7, 0, 0);
                const departAt6PM = new Date(nextMonday.getFullYear(), nextMonday.getMonth(), nextMonday.getDate(), 18, 0, 0);
                
                const departureTime = Math.floor((isToWork ? departAt7AM : departAt6PM).getTime() / 1000);
                
                console.log(`â° Departure time: ${(isToWork ? departAt7AM : departAt6PM).toLocaleString()}`);
                
                const calculateTravelOptionsFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateTravelOptions');
                const result = await calculateTravelOptionsFunction({
                    origin: origin,
                    destination: destination,
                    departureTime: departureTime
                });
                
                console.log(`â Travel options result:`, result.data);
                return result.data;
            } catch (error) {
                console.error('â Error calculating travel options:', error);
                console.error('Error details:', error.message, error.stack);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Start optimization after alterations
        async function startOptimization() {
            closeAlterationsPopup();
            
            console.log('Starting optimization with carry-overs:', carryOverPostcodes);
            
            // If no saved routes, show demo routes for optimization
            if (savedRoutes.length === 0) {
                showDemoRoutes();
                optimizeDemoRoutes();
                return;
            }
            
            // Optimize saved routes
            const optimizeButton = document.querySelector('button[onclick="showOptimiseSettings()"]');
            optimizeButton.disabled = true;
            optimizeButton.innerHTML = '<span class="truncate">Optimising...</span>';
            optimizeButton.classList.add('opacity-50');

            // Assign drivers to saved routes using Google Maps API
            try {
                await assignDriversToSavedRoutes();
                
                // Reset button
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert(`Routes optimized successfully! Optimized ${savedRoutes.length} saved routes using Google Maps API and ${drivers.length} drivers.`);
            } catch (error) {
                console.error('Error during optimization:', error);
                
                // Reset button
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert('Error during optimization. Please check console for details.');
            }
        }

        // Optimize demo routes (when no saved routes exist)
        function optimizeDemoRoutes() {
            const optimizeButton = document.querySelector('button[onclick="showOptimiseSettings()"]');
            optimizeButton.disabled = true;
            optimizeButton.innerHTML = '<span class="truncate">Optimising...</span>';
            optimizeButton.classList.add('opacity-50');

            setTimeout(async () => {
                await assignDriversToRoutes();
                
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert('Demo routes optimized! Go to the Routes page to create and save your own routes.');
            }, 2000);
        }

        // Calculate total driving distance for a route (sum of all collectionâdelivery distances)
        async function calculateRouteTotalDistance(routeData) {
            const jobs = routeData.jobs || [];
            let totalDistance = 0;
            
            for (const job of jobs) {
                const collection = job.parsedData?.collection_address;
                const delivery = job.parsedData?.postcode_delivery;
                
                if (collection && delivery) {
                    try {
                        const distance = await calculateDistance(collection, delivery);
                        totalDistance += distance;
                    } catch (error) {
                        console.warn(`Error calculating distance for job ${job.jobNumber}:`, error);
                    }
                }
            }
            
            return totalDistance;
        }

        // Assign drivers to saved routes from Firebase using optimal assignment algorithm
        async function assignDriversToSavedRoutes(driversToUse = null) {
            // Step 1: Loading routes
            updateOptimizationProgress(1, 10, 'Loading routes...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            const driversForAssignment = driversToUse || drivers;
            console.log('Assigning drivers using PRIORITY-BASED assignment algorithm...');
            console.log('Saved routes count:', savedRoutes.length);
            console.log('Drivers count:', driversForAssignment.length);
            
            if (savedRoutes.length === 0 || driversForAssignment.length === 0) {
                console.log('No routes or drivers available for assignment');
                return;
            }
            
            // Step 2: Calculate total driving distance for each route
            updateOptimizationProgress(2, 20, 'Calculating route distances...');
            const routesWithDistances = [];
            
            for (let routeIndex = 0; routeIndex < savedRoutes.length; routeIndex++) {
                const routeData = savedRoutes[routeIndex];
                const totalDistance = await calculateRouteTotalDistance(routeData);
                routesWithDistances.push({
                    routeIndex,
                    routeData,
                    totalDistance
                });
                console.log(`Route ${routeIndex + 1}: Total driving distance = ${totalDistance} miles`);
            }
            
            // Sort routes by total distance (shortest first)
            routesWithDistances.sort((a, b) => a.totalDistance - b.totalDistance);
            console.log('Routes sorted by total distance:', routesWithDistances.map(r => `Route ${r.routeIndex + 1}: ${r.totalDistance}mi`).join(', '));
            
            // Step 3: Separate carryover and non-carryover drivers
            const carryoverDrivers = [];
            const regularDrivers = [];
            
            for (let i = 0; i < driversForAssignment.length; i++) {
                const driver = driversForAssignment[i];
                if (driversWithCarryover.has(driver.id)) {
                    carryoverDrivers.push({ driver, driverIndex: i });
                } else {
                    regularDrivers.push({ driver, driverIndex: i });
                }
            }
            
            console.log(`Carryover drivers: ${carryoverDrivers.length}, Regular drivers: ${regularDrivers.length}`);
            
            // Step 4: Assign shortest routes to carryover drivers
            const carryoverRoutes = [];
            const regularRoutes = [];
            
            const numCarryoverRoutes = Math.min(carryoverDrivers.length, routesWithDistances.length);
            
            // Take the N shortest routes for carryover drivers
            for (let i = 0; i < numCarryoverRoutes; i++) {
                carryoverRoutes.push(routesWithDistances[i]);
            }
            
            // Remaining routes go to regular drivers
            for (let i = numCarryoverRoutes; i < routesWithDistances.length; i++) {
                regularRoutes.push(routesWithDistances[i]);
            }
            
            console.log(`Carryover routes (${carryoverRoutes.length} shortest):`, carryoverRoutes.map(r => `Route ${r.routeIndex + 1} (${r.totalDistance}mi)`).join(', '));
            console.log(`Regular routes (${regularRoutes.length} remaining):`, regularRoutes.map(r => `Route ${r.routeIndex + 1} (${r.totalDistance}mi)`).join(', '));
            
            // Step 5: Fetching driver data
            updateOptimizationProgress(3, 30, 'Fetching driver data...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Calculate total number of API calls for time estimation
            const carryoverCalculations = carryoverRoutes.length * carryoverDrivers.length;
            const regularCalculations = regularRoutes.length * regularDrivers.length;
            totalCalculations = carryoverCalculations + regularCalculations;
            console.log(`ð Total calculations needed: ${totalCalculations} (Carryover: ${carryoverCalculations}, Regular: ${regularCalculations})`);
            
            // Step 6: Calculate all driver-route combinations
            const allAssignments = [];
            
            // First pass: Calculate all routes to determine which ones need mixed mode
            const routeNeedsMixedMode = new Array(savedRoutes.length).fill(false);
            const routeCalculations = []; // Store all calculations
            
            // Process carryover routes
            for (const routeInfo of carryoverRoutes) {
                const routeIndex = routeInfo.routeIndex;
                const routeData = routeInfo.routeData;
                const jobs = routeData.jobs;
                
                if (jobs.length > 0) {
                    const firstJob = jobs[0];
                    const lastJob = jobs[jobs.length - 1];
                    const collectionAddress = firstJob.parsedData?.collection_address || 'B797RU';
                    const deliveryAddress = lastJob.parsedData?.postcode_delivery || 'M1 4AN';
                    
                    const routeDriverTimes = [];
                    
                    for (const { driver, driverIndex } of carryoverDrivers) {
                        completedCalculations = allAssignments.length + 1;
                        const calculationProgress = 30 + Math.floor((completedCalculations / totalCalculations) * 50);
                        updateOptimizationProgress(4, calculationProgress, `Calculating distances (${completedCalculations}/${totalCalculations})...`, completedCalculations, totalCalculations);
                        
                        try {
                            const driverHomePostcode = driver.homePostcode || driver.postcode;
                            const carryoverPostcode = driversWithCarryover.get(driver.id);
                            
                            // Use carryover postcode for "to work"
                            const toWorkOrigin = carryoverPostcode;
                            
                            console.log(`Calculating travel options for carryover driver ${driverIndex + 1} and route ${routeIndex + 1}...`);
                            
                            const toWorkOptions = await calculateTravelOptions(toWorkOrigin, collectionAddress, true);
                            const fromWorkOptions = await calculateTravelOptions(deliveryAddress, driverHomePostcode, false);
                            
                            const originalTotalTime = toWorkOptions.duration + fromWorkOptions.duration;
                            routeDriverTimes.push(originalTotalTime);
                            
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions,
                                fromWorkOptions,
                                originalTotalTime,
                                hasCarryover: true,
                                carryoverPostcode: carryoverPostcode,
                                isCarryoverRoute: true
                            });
                            
                        } catch (error) {
                            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
                            console.error(`Error calculating travel options for driver ${driverName} and route ${routeIndex + 1}:`, error);
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions: { success: false },
                                fromWorkOptions: { success: false },
                                originalTotalTime: 999,
                                hasCarryover: true,
                                isCarryoverRoute: true
                            });
                            routeDriverTimes.push(999);
                        }
                    }
                    
                    const allDriversOverThreshold = routeDriverTimes.every(time => time > 120);
                    routeNeedsMixedMode[routeIndex] = allDriversOverThreshold;
                }
            }
            
            // Process regular routes
            for (const routeInfo of regularRoutes) {
                const routeIndex = routeInfo.routeIndex;
                const routeData = routeInfo.routeData;
                const jobs = routeData.jobs;
                
                if (jobs.length > 0) {
                    const firstJob = jobs[0];
                    const lastJob = jobs[jobs.length - 1];
                    const collectionAddress = firstJob.parsedData?.collection_address || 'B797RU';
                    const deliveryAddress = lastJob.parsedData?.postcode_delivery || 'M1 4AN';
                    
                    const routeDriverTimes = [];
                    
                    for (const { driver, driverIndex } of regularDrivers) {
                        completedCalculations = routeCalculations.length + 1;
                        const calculationProgress = 30 + Math.floor((completedCalculations / totalCalculations) * 50);
                        updateOptimizationProgress(4, calculationProgress, `Calculating distances (${completedCalculations}/${totalCalculations})...`, completedCalculations, totalCalculations);
                        
                        try {
                            const driverHomePostcode = driver.homePostcode || driver.postcode;
                            
                            console.log(`Calculating travel options for driver ${driverIndex + 1} and route ${routeIndex + 1}...`);
                            
                            const toWorkOptions = await calculateTravelOptions(driverHomePostcode, collectionAddress, true);
                            const fromWorkOptions = await calculateTravelOptions(deliveryAddress, driverHomePostcode, false);
                            
                            const originalTotalTime = toWorkOptions.duration + fromWorkOptions.duration;
                            routeDriverTimes.push(originalTotalTime);
                            
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions,
                                fromWorkOptions,
                                originalTotalTime,
                                hasCarryover: false,
                                isCarryoverRoute: false
                            });
                            
                        } catch (error) {
                            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
                            console.error(`Error calculating travel options for driver ${driverName} and route ${routeIndex + 1}:`, error);
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions: { success: false },
                                fromWorkOptions: { success: false },
                                originalTotalTime: 999,
                                hasCarryover: false,
                                isCarryoverRoute: false
                            });
                            routeDriverTimes.push(999);
                        }
                    }
                    
                    const allDriversOverThreshold = routeDriverTimes.every(time => time > 120);
                    routeNeedsMixedMode[routeIndex] = allDriversOverThreshold;
                }
            }
            
            // Second pass: Build assignments with correct mode based on route analysis
            console.log('Building assignments with mixed mode decisions...');
            console.log('Routes needing mixed mode:', routeNeedsMixedMode.map((needs, i) => needs ? `Route ${i+1}` : null).filter(r => r).join(', ') || 'None');
            
            for (const calc of routeCalculations) {
                const useMixedMode = routeNeedsMixedMode[calc.routeIndex];
                
                let effectiveToWorkDuration = calc.toWorkOptions.duration;
                let effectiveFromWorkDuration = calc.fromWorkOptions.duration;
                let useMixedModeToWork = false;
                let useMixedModeFromWork = false;
                
                // If this route needs mixed mode (all drivers >2hrs), use it for optimization
                if (useMixedMode) {
                    if (calc.toWorkOptions.mixedModeRoute) {
                        const originalTime = calc.toWorkOptions.duration;
                        const mixedTime = calc.toWorkOptions.mixedModeRoute.duration;
                        effectiveToWorkDuration = mixedTime;
                        useMixedModeToWork = true;
                        console.log(`  Route ${calc.routeIndex + 1} TO work: Using mixed mode ${mixedTime}min (was ${originalTime}min)`);
                    }
                    if (calc.fromWorkOptions.mixedModeRoute) {
                        const originalTime = calc.fromWorkOptions.duration;
                        const mixedTime = calc.fromWorkOptions.mixedModeRoute.duration;
                        effectiveFromWorkDuration = mixedTime;
                        useMixedModeFromWork = true;
                        console.log(`  Route ${calc.routeIndex + 1} FROM work: Using mixed mode ${mixedTime}min (was ${originalTime}min)`);
                    }
                }
                
                const totalTime = effectiveToWorkDuration + effectiveFromWorkDuration;
                const bothTaxi = calc.toWorkOptions.mode === 'taxi' && calc.fromWorkOptions.mode === 'taxi';
                const oneTaxi = (calc.toWorkOptions.mode === 'taxi') !== (calc.fromWorkOptions.mode === 'taxi');
                const requiresAuth = calc.toWorkOptions.mode === 'requires_authorization' || calc.fromWorkOptions.mode === 'requires_authorization';
                            
                let priorityScore;
                if (requiresAuth) {
                    // Very low priority - these need manual authorization
                    priorityScore = -10000 + totalTime; // Negative score to de-prioritize
                } else if (bothTaxi) {
                    priorityScore = 10000 - totalTime;
                } else if (oneTaxi) {
                    const transitTime = calc.toWorkOptions.mode === 'transit' ? effectiveToWorkDuration : effectiveFromWorkDuration;
                    priorityScore = 5000 - transitTime;
                } else {
                    priorityScore = 1000 - totalTime;
                }
                
                // Note: No longer boosting carryover drivers - they get shortest routes assigned separately
                            
                const assignment = {
                    routeIndex: calc.routeIndex,
                    driverIndex: calc.driverIndex,
                    driver: calc.driver,
                    routeData: calc.routeData,
                    toWorkOptions: calc.toWorkOptions,
                    fromWorkOptions: calc.fromWorkOptions,
                    totalTime: totalTime,
                    priorityScore: priorityScore,
                    bothTaxi: bothTaxi,
                    oneTaxi: oneTaxi,
                    useMixedModeToWork: useMixedModeToWork,
                    useMixedModeFromWork: useMixedModeFromWork,
                    hasCarryover: calc.hasCarryover,
                    carryoverPostcode: calc.carryoverPostcode,
                    isCarryoverRoute: calc.isCarryoverRoute
                };
                
                allAssignments.push(assignment);
            }
            
            // Store assignments globally for authorization function
            window.currentAssignments = allAssignments;
            
            // Step 7: Running optimization on Firebase (algorithm hidden from competitors)
            updateOptimizationProgress(5, 85, 'Running optimization algorithm...');
            
            // Prepare assignments data for Firebase (minimize data sent - only what's needed for optimization)
            const assignmentsForFirebase = allAssignments.map((calc, idx) => ({
                index: idx, // Keep original index for mapping back
                routeIndex: calc.routeIndex,
                driverIndex: calc.driverIndex,
                totalTime: calc.totalTime,
                priorityScore: calc.priorityScore,
                bothTaxi: calc.bothTaxi,
                oneTaxi: calc.oneTaxi,
                useMixedModeToWork: calc.useMixedModeToWork,
                useMixedModeFromWork: calc.useMixedModeFromWork,
                hasCarryover: calc.hasCarryover,
                isCarryoverRoute: calc.isCarryoverRoute
            }));
            
            // Separate assignments by type
            const carryoverAssignments = assignmentsForFirebase.filter(a => a.isCarryoverRoute);
            const regularAssignments = assignmentsForFirebase.filter(a => !a.isCarryoverRoute);
            
            // Call Firebase Function for optimization (algorithm hidden on server)
            let optimalAssignment = [];
            try {
                if (window.firebase && window.firebase.httpsCallable && window.firebase.functions) {
                    const optimizeFunction = window.firebase.httpsCallable(window.firebase.functions, 'optimizeRouteAssignments');
                    const result = await optimizeFunction({
                        carryoverAssignments: carryoverAssignments,
                        regularAssignments: regularAssignments,
                        numCarryoverRoutes: carryoverRoutes.length,
                        numRegularRoutes: regularRoutes.length,
                        numCarryoverDrivers: carryoverDrivers.length,
                        numRegularDrivers: regularDrivers.length
                    });
                    
                    if (result.data && result.data.success) {
                        // Firebase returns indices into the assignments arrays
                        const carryoverOptimalIndices = result.data.carryoverOptimal || [];
                        const regularOptimalIndices = result.data.regularOptimal || [];
                        
                        // Map indices back to full assignment objects
                        const carryoverFull = carryoverOptimalIndices.map(idx => {
                            const assignmentData = carryoverAssignments[idx];
                            return allAssignments[assignmentData.index];
                        }).filter(Boolean);
                        
                        const regularFull = regularOptimalIndices.map(idx => {
                            const assignmentData = regularAssignments[idx];
                            return allAssignments[assignmentData.index];
                        }).filter(Boolean);
                        
                        optimalAssignment = [...carryoverFull, ...regularFull];
                        console.log(`â Optimal assignment found with ${optimalAssignment.length} assignments (via Firebase)`);
                    } else {
                        throw new Error(result.data?.error || 'Optimization failed');
                    }
                } else {
                    // Fallback to client-side if Firebase not available (shouldn't happen in production)
                    console.warn('Firebase Functions not available, using client-side optimization');
                    let carryoverOptimal = [];
                    if (carryoverAssignments.length > 0 && carryoverDrivers.length > 0) {
                        carryoverOptimal = findOptimalAssignmentByPriority(
                            allAssignments.filter(a => a.isCarryoverRoute), 
                            carryoverRoutes.length, 
                            carryoverDrivers.length
                        );
                    }
                    let regularOptimal = [];
                    if (regularAssignments.length > 0 && regularDrivers.length > 0) {
                        regularOptimal = findOptimalAssignmentByPriority(
                            allAssignments.filter(a => !a.isCarryoverRoute), 
                            regularRoutes.length, 
                            regularDrivers.length
                        );
                    }
                    optimalAssignment = [...carryoverOptimal, ...regularOptimal];
                    console.log(`â Optimal assignment found with ${optimalAssignment.length} assignments (client-side fallback)`);
                }
            } catch (error) {
                console.error('Error optimizing routes:', error);
                alert('Failed to optimize routes: ' + error.message);
                return;
            }
            
            // Step 5: Assigning drivers
            updateOptimizationProgress(5, 95, 'Assigning drivers to routes...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Sort assignments by priority score (highest first)
            optimalAssignment.sort((a, b) => {
                return b.priorityScore - a.priorityScore; // Highest priority first
            });
            
            // Apply the optimal assignment to UI and calculate scores
            const assignmentsWithScores = [];
            
            for (const assignment of optimalAssignment) {
                const routeNumber = assignment.routeIndex + 1;
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                
                const driverName = assignment.driver.name || (assignment.driver.firstName + ' ' + assignment.driver.lastName) || 'Unknown Driver';
                const driverHome = assignment.driver.homePostcode || assignment.driver.postcode || 'Unknown';
                
                // CRITICAL: Update the route object in savedRoutes with driver assignment
                assignment.routeData.route.assignedDriver = assignment.driver;
                assignment.routeData.route.assignedDriverName = driverName;
                assignment.routeData.route.assignedDriverPostcode = driverHome;
                
                // Store carryover information if it exists
                if (assignment.hasCarryover) {
                    assignment.routeData.route.carryoverPostcode = assignment.carryoverPostcode;
                }
                
                // Get REG number from first job
                const firstJob = assignment.routeData.jobs[0];
                const regNumber = firstJob?.parsedData?.reg_number || '-';
                
                // Update REG display
                const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                if (regElement) {
                    regElement.textContent = regNumber;
                }
                
                // Update driver name
                if (driverElement) {
                    driverElement.textContent = driverName;
                }
                
                // Show "why this driver" button
                const whyDriverButton = document.getElementById(`firebase-route-${routeNumber}-why-driver`);
                if (whyDriverButton) {
                    whyDriverButton.classList.remove('hidden');
                }
                
                // Update driver home
                if (locationElement) {
                    locationElement.textContent = driverHome;
                }
                
                // Show carryover if driver has one
                if (assignment.hasCarryover && assignment.carryoverPostcode) {
                    const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                    const carryoverPostcodeElement = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                    
                    if (carryoverDisplay) {
                        carryoverDisplay.classList.remove('hidden');
                    }
                    if (carryoverPostcodeElement) {
                        carryoverPostcodeElement.textContent = assignment.carryoverPostcode;
                    }
                    
                    // Change "To First Job" label to "From Carryover"
                    const toWorkLabel = document.getElementById(`firebase-route-${routeNumber}-to-work-label`);
                    if (toWorkLabel) {
                        toWorkLabel.textContent = 'From Carryover';
                    }
                }
                
                // Display travel options - check EACH DIRECTION separately
                // TO work: Show mixed mode only if TO work time > 2 hours
                const toWorkOriginalTime = assignment.toWorkOptions.duration;
                const fromWorkOriginalTime = assignment.fromWorkOptions.duration;
                const shouldShowMixedModeToWork = toWorkOriginalTime > 120;
                const shouldShowMixedModeFromWork = fromWorkOriginalTime > 120;
                
                // Calculate effective times for SCORING based on what's actually displayed
                // Use mixed mode if available AND original time > 2 hours (matches display logic)
                const effectiveToWork = shouldShowMixedModeToWork && assignment.toWorkOptions.mixedModeRoute 
                    ? { ...assignment.toWorkOptions, duration: assignment.toWorkOptions.mixedModeRoute.duration, mode: 'mixed' }
                    : assignment.toWorkOptions;
                const effectiveFromWork = shouldShowMixedModeFromWork && assignment.fromWorkOptions.mixedModeRoute
                    ? { ...assignment.fromWorkOptions, duration: assignment.fromWorkOptions.mixedModeRoute.duration, mode: 'mixed' }
                    : assignment.fromWorkOptions;
                
                // Log the ACTUAL times being used for scoring (match what's displayed)
                const displayToWorkTime = shouldShowMixedModeToWork && assignment.toWorkOptions.mixedModeRoute 
                    ? assignment.toWorkOptions.mixedModeRoute.duration 
                    : toWorkOriginalTime;
                const displayFromWorkTime = shouldShowMixedModeFromWork && assignment.fromWorkOptions.mixedModeRoute 
                    ? assignment.fromWorkOptions.mixedModeRoute.duration 
                    : fromWorkOriginalTime;
                
                console.log(`Route ${routeNumber}: TO work ${displayToWorkTime}min (${shouldShowMixedModeToWork ? 'Mixed Mode' : 'Original'} on left), FROM work ${displayFromWorkTime}min (${shouldShowMixedModeFromWork ? 'Mixed Mode' : 'Original'} on left)`);
                
                if (toWorkElement) {
                    toWorkElement.innerHTML = formatTravelOptionForRoute(assignment.toWorkOptions, `route-${routeNumber}`, 'to-work', shouldShowMixedModeToWork);
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = formatTravelOptionForRoute(assignment.fromWorkOptions, `route-${routeNumber}`, 'from-work', shouldShowMixedModeFromWork);
                }
                
                const routeScore = calculateTravelScore(effectiveToWork, effectiveFromWork);
                const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                
                // Log score calculation details for carryover drivers
                if (assignment.hasCarryover) {
                    console.log(`ð¦ Route ${routeNumber} (Carryover driver): Score ${routeScore.score} - TO: ${effectiveToWork.duration}min, FROM: ${effectiveFromWork.duration}min`);
                }
                
                // Store assignment with score for sorting later
                assignmentsWithScores.push({
                    routeNumber: routeNumber,
                    score: routeScore.score,
                    routeElement: document.getElementById(`firebase-route-${routeNumber}`)
                });
                
                if (scoreElement) {
                    scoreElement.textContent = `${routeScore.score}`;
                }
                if (scoreContainer) {
                    // Apply color based on score
                    if (routeScore.color === 'green') {
                        scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                    } else if (routeScore.color === 'orange') {
                        scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                    } else {
                        scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                    }
                }
                
                // CRITICAL: Save the route score to the route data for persistence
                assignment.routeData.route.routeScore = routeScore;
                
                console.log(`â Assigned ${driverName} to route ${routeNumber} (Score: ${routeScore.score}/100)`);
            }
            
            // Sort routes by score (highest first) and reorder in DOM
            assignmentsWithScores.sort((a, b) => b.score - a.score);
            
            console.log('Routes sorted by score:', assignmentsWithScores.map(a => `Route ${a.routeNumber}: ${a.score}`).join(', '));
            
            // Wait for DOM updates to complete before reordering
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const routesContainer = document.getElementById('routes-container');
            if (routesContainer) {
                // Hide all driverless routes from main container (they're shown in driverless section)
                const assignedRouteIndices = new Set(optimalAssignment.map(a => a.routeIndex));
                savedRoutes.forEach((routeData, index) => {
                    if (!assignedRouteIndices.has(index)) {
                        const routeElement = document.getElementById(`firebase-route-${index + 1}`);
                        if (routeElement) {
                            routeElement.style.display = 'none'; // Hide driverless routes
                        }
                    }
                });
                
                if (assignmentsWithScores.length > 0) {
                    // Re-fetch elements to ensure they exist
                    const sortedElements = assignmentsWithScores
                        .map(item => {
                            const el = document.getElementById(`firebase-route-${item.routeNumber}`);
                            if (!el) {
                                console.warn(`Route element not found: firebase-route-${item.routeNumber}`);
                            }
                            return el;
                        })
                        .filter(el => el);
                    
                    console.log(`Found ${sortedElements.length} route elements to sort`);
                    
                    // Detach elements from DOM first (preserves them)
                    sortedElements.forEach(el => el.remove());
                    
                    // Re-append in sorted order (highest score first)
                    sortedElements.forEach(element => {
                        routesContainer.appendChild(element);
                    });
                    
                    console.log('â Routes reordered: Top-left (highest) to bottom-right (lowest)');
                }
            }
            
            // Store assignment details for each route (for "why this driver" info)
            window.routeAssignmentDetails = {};
            for (const assignment of optimalAssignment) {
                const routeNumber = assignment.routeIndex + 1;
                window.routeAssignmentDetails[routeNumber] = {
                    driver: assignment.driver,
                    priorityScore: assignment.priorityScore,
                    totalTime: assignment.totalTime,
                    bothTaxi: assignment.bothTaxi,
                    oneTaxi: assignment.oneTaxi,
                    toWorkOptions: assignment.toWorkOptions,
                    fromWorkOptions: assignment.fromWorkOptions,
                    hasCarryover: assignment.hasCarryover,
                    carryoverPostcode: assignment.carryoverPostcode,
                    isCarryoverRoute: assignment.isCarryoverRoute,
                    routeData: assignment.routeData, // Store route data for map
                    allConsideredDrivers: allAssignments
                        .filter(a => a.routeIndex === assignment.routeIndex)
                        .map(a => ({
                            driver: a.driver,
                            priorityScore: a.priorityScore,
                            totalTime: a.totalTime
                        }))
                        .sort((a, b) => b.priorityScore - a.priorityScore)
                };
            }
            
            // Display routes requiring authorization (detected during calculations)
            // Only show routes that require auth AND were NOT assigned in optimal assignment
            const assignedRouteIndices = new Set(optimalAssignment.map(a => a.routeIndex));
            const routesRequiringAuth = allAssignments.filter(assignment => 
                (assignment.toWorkOptions.mode === 'requires_authorization' || 
                 assignment.fromWorkOptions.mode === 'requires_authorization') &&
                !assignedRouteIndices.has(assignment.routeIndex)
            );
            
            const authSection = document.getElementById('authorization-routes-section');
            const authContainer = document.getElementById('authorization-routes-container');
            
            if (routesRequiringAuth.length > 0) {
                authContainer.innerHTML = '';
                // Group by route and find best driver for each route
                const routeAuthMap = new Map();
                routesRequiringAuth.forEach(assignment => {
                    if (!routeAuthMap.has(assignment.routeIndex)) {
                        routeAuthMap.set(assignment.routeIndex, assignment);
                    } else {
                        // Keep the one with higher priority score
                        const existing = routeAuthMap.get(assignment.routeIndex);
                        if (assignment.priorityScore > existing.priorityScore) {
                            routeAuthMap.set(assignment.routeIndex, assignment);
                        }
                    }
                });
                
                routeAuthMap.forEach(assignment => {
                    const card = createAuthorizationRouteCard(assignment);
                    authContainer.appendChild(card);
                });
                authSection.classList.remove('hidden');
            } else {
                authSection.classList.add('hidden');
            }
            
            // Display unassigned drivers (jobless drivers)
            const assignedDriverIndices = new Set(optimalAssignment.map(a => a.driverIndex));
            const joblessDrivers = driversForAssignment.filter((driver, index) => !assignedDriverIndices.has(index));
            
            const joblessDriversSection = document.getElementById('jobless-drivers-section');
            const joblessDriversContainer = document.getElementById('jobless-drivers-container');
            
            if (joblessDrivers.length > 0) {
                joblessDriversContainer.innerHTML = '';
                joblessDrivers.forEach(driver => {
                    const card = createJoblessDriverCard(driver);
                    joblessDriversContainer.appendChild(card);
                });
                joblessDriversSection.classList.remove('hidden');
            } else {
                joblessDriversSection.classList.add('hidden');
            }
            
            // Display unassigned routes (driverless routes)
            const driverlessRoutes = savedRoutes.filter((route, index) => !assignedRouteIndices.has(index));
            
            const driverlessRoutesSection = document.getElementById('driverless-routes-section');
            const driverlessRoutesContainer = document.getElementById('driverless-routes-container');
            
            if (driverlessRoutes.length > 0) {
                driverlessRoutesContainer.innerHTML = '';
                driverlessRoutes.forEach((route, index) => {
                    const card = createDriverlessRouteCard(route, index);
                    driverlessRoutesContainer.appendChild(card);
                });
                driverlessRoutesSection.classList.remove('hidden');
            } else {
                driverlessRoutesSection.classList.add('hidden');
            }
            
            const totalDistance = optimalAssignment.reduce((sum, assignment) => sum + assignment.totalDistance, 0);
            
            // Save all driver assignments to Firebase
            console.log('ð¾ Saving driver assignments to Firebase...');
            await saveRoutesToFirebase();
            console.log('â Driver assignments saved to Firebase');
        }
        
        // Calculate route score based on total distance (for backward compatibility)
        function calculateRouteScore(totalDistance) {
            if (totalDistance <= 20) return { score: 10, color: 'green' };
            if (totalDistance <= 40) return { score: 9, color: 'green' };
            if (totalDistance <= 60) return { score: 8, color: 'orange' };
            if (totalDistance <= 80) return { score: 7, color: 'orange' };
            if (totalDistance <= 100) return { score: 6, color: 'orange' };
            if (totalDistance <= 120) return { score: 5, color: 'red' };
            if (totalDistance <= 140) return { score: 4, color: 'red' };
            if (totalDistance <= 160) return { score: 3, color: 'red' };
            if (totalDistance <= 180) return { score: 2, color: 'red' };
            return { score: 1, color: 'red' };
        }

        // Calculate route score based on travel time and mode (out of 100)
        function calculateTravelScore(toWork, fromWork) {
            // Handle requires_authorization mode - use totalDuration if available
            const toWorkDuration = toWork.mode === 'requires_authorization' && toWork.totalDuration ? toWork.totalDuration : toWork.duration;
            const fromWorkDuration = fromWork.mode === 'requires_authorization' && fromWork.totalDuration ? fromWork.totalDuration : fromWork.duration;
            
            const totalMinutes = toWorkDuration + fromWorkDuration;
            const bothTaxi = toWork.mode === 'taxi' && fromWork.mode === 'taxi';
            const oneTaxi = (toWork.mode === 'taxi') !== (fromWork.mode === 'taxi');
            const requiresAuth = toWork.mode === 'requires_authorization' || fromWork.mode === 'requires_authorization';
            
            let score = 0;
            
            // Routes requiring authorization get penalty (20-40 points based on total time)
            if (requiresAuth) {
                // Lower score for auth-required routes to prioritize them less
                if (totalMinutes <= 60) {
                    score = 40; // Best case for auth routes
                } else if (totalMinutes <= 120) {
                    score = 35 - Math.floor((totalMinutes - 60) / 12); // 35 down to 30
                } else {
                    score = Math.max(20, 30 - Math.floor((totalMinutes - 120) / 20)); // 30 down to 20
                }
                return score;
            }
            
            // BOTH TAXI: 90-100 points (based on total taxi time)
            if (bothTaxi) {
                // Perfect: 0-4min total = 100
                // Excellent: 5-8min = 99
                // Very good: 9-20min = 95-98
                // Good: 21-30min = 90-94
                if (totalMinutes <= 4) {
                    score = 100;
                } else if (totalMinutes <= 8) {
                    score = 99;
                } else if (totalMinutes <= 30) {
                    score = 98 - Math.floor((totalMinutes - 8) / 3); // 98 down to 90
                } else {
                    score = Math.max(85, 90 - Math.floor((totalMinutes - 30) / 2)); // Slowly decrease
                }
            }
            // ONE TAXI: 70-90 points (based on transit time)
            else if (oneTaxi) {
                const transitTime = toWork.mode === 'transit' ? toWork.duration : fromWork.duration;
                
                if (transitTime <= 30) {
                    // â¤30min transit = 90 points
                    score = 90;
                } else if (transitTime <= 60) {
                    // 30-60min transit = 80-89
                    // 30min = 90, 60min = 80
                    score = 90 - Math.floor((transitTime - 30) / 3);
                } else if (transitTime <= 90) {
                    // 60-90min transit = 75-79
                    score = 80 - Math.floor((transitTime - 60) / 6);
                } else {
                    // >90min transit = 70-74
                    score = Math.max(70, 75 - Math.floor((transitTime - 90) / 10));
                }
            }
            // BOTH TRANSIT: 10-70 points (based on total transit time)
            else {
                const totalHours = totalMinutes / 60;
                
                if (totalHours <= 2) {
                    // â¤2hr = 70 points
                    score = 70;
                } else if (totalHours <= 2.5) {
                    // 2-2.5hr = 60-69
                    score = 70 - Math.floor((totalMinutes - 120) / 3);
                } else if (totalHours <= 3) {
                    // 2.5-3hr = 50-59
                    score = 60 - Math.floor((totalMinutes - 150) / 3);
                } else if (totalHours <= 3.5) {
                    // 3-3.5hr = 40-49
                    score = 50 - Math.floor((totalMinutes - 180) / 3);
                } else if (totalHours <= 4) {
                    // 3.5-4hr = 30-39
                    score = 40 - Math.floor((totalMinutes - 210) / 3);
                } else if (totalHours <= 4.5) {
                    // 4-4.5hr = 20-29
                    score = 30 - Math.floor((totalMinutes - 240) / 3);
                } else if (totalHours <= 5) {
                    // 4.5-5hr = 10-19
                    score = 20 - Math.floor((totalMinutes - 270) / 3);
                } else {
                    // >5hr = 1-9
                    score = Math.max(1, 10 - Math.floor((totalMinutes - 300) / 10));
                }
            }
            
            // Ensure score stays between 1-100
            score = Math.max(1, Math.min(100, score));
            
            // Determine color based on score
            let color = 'red';
            if (score >= 80) color = 'green';
            else if (score >= 50) color = 'orange';
            
            return { score, color };
        }

        // Create jobless driver card
        // Create authorization route card with "Authorise Drive" button
        function createAuthorizationRouteCard(assignment) {
            const route = assignment.routeData;
            const driver = assignment.driver;
            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
            const driverPostcode = driver.homePostcode || driver.postcode || 'Unknown';
            const totalTime = assignment.totalTime;
            
            // Check which direction requires authorization
            const toWorkAuth = assignment.toWorkOptions.mode === 'requires_authorization';
            const fromWorkAuth = assignment.fromWorkOptions.mode === 'requires_authorization';
            
            // Get train station info
            let stationInfo = '';
            if (toWorkAuth && assignment.toWorkOptions.trainStation) {
                stationInfo = assignment.toWorkOptions.trainStation.name;
            } else if (fromWorkAuth && assignment.fromWorkOptions.trainStation) {
                stationInfo = assignment.fromWorkOptions.trainStation.name;
            }
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-yellow-500/30 bg-yellow-900/10 p-4';
            card.id = `auth-route-${assignment.routeIndex}`;
            
            // Format total time
            const hours = Math.floor(totalTime / 60);
            const minutes = totalTime % 60;
            const timeText = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
            
            card.innerHTML = `
                <div class="flex items-center justify-between gap-3">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 bg-yellow-600 rounded-full flex items-center justify-center">
                            <span class="material-symbols-outlined text-white text-lg">warning</span>
                        </div>
                        <div class="flex-1">
                            <h3 class="font-semibold text-white">Route ${route.route.routeNumber || assignment.routeIndex + 1}</h3>
                            <p class="text-sm text-gray-400">${stationInfo ? `Via ${stationInfo}` : 'No direct transit'}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-yellow-400 font-medium">Needs Authorization</span>
                    </div>
                </div>
                
                <div class="border-t border-gray-700 pt-3">
                    <div class="grid grid-cols-2 gap-3 text-sm mb-3">
                        <div>
                            <span class="text-gray-400">Best Driver:</span>
                            <p class="text-white font-semibold">${driverName}</p>
                            <p class="text-gray-500 text-xs">${driverPostcode}</p>
                        </div>
                        <div>
                            <span class="text-gray-400">Total Time:</span>
                            <p class="text-white font-semibold">${timeText}</p>
                            <p class="text-gray-500 text-xs">Including drive</p>
                        </div>
                    </div>
                    
                    ${toWorkAuth ? '<p class="text-xs text-yellow-300 mb-2">â ï¸ TO work requires driving to station</p>' : ''}
                    ${fromWorkAuth ? '<p class="text-xs text-yellow-300 mb-2">â ï¸ FROM work requires driving from station</p>' : ''}
                    
                    <button onclick="authorizeRoute(${assignment.routeIndex}, ${assignment.driverIndex})" 
                            class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-semibold">
                        Authorise Drive
                    </button>
                </div>
            `;
            
            return card;
        }

        function createJoblessDriverCard(driver) {
            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
            const driverPostcode = driver.homePostcode || driver.postcode || 'Unknown';
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-red-500/30 bg-red-900/10 p-4';
            
            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-red-600 rounded-full flex items-center justify-center">
                        <span class="material-symbols-outlined text-white text-lg">person_off</span>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-white">${driverName}</h3>
                        <p class="text-sm text-gray-400">${driverPostcode}</p>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-red-400 font-medium">No Route</span>
                    </div>
                </div>
                <div class="text-sm text-gray-400">
                    This driver was not assigned to any routes during optimization.
                </div>
            `;
            
            return card;
        }

        // Create driverless route card
        function createDriverlessRouteCard(routeData, routeIndex) {
            const routeNumber = routeIndex + 1;
            const jobs = routeData.jobs || [];
            
            // Create job pairs display
            let jobPairsHTML = '';
            jobs.forEach((job, index) => {
                const jobLetter = String.fromCharCode(65 + index);
                const collectionPostcode = job.parsedData?.collection_address || 'N/A';
                const deliveryPostcode = job.parsedData?.postcode_delivery || 'N/A';
                
                jobPairsHTML += `
                    <div class="flex items-center gap-2 text-xs">
                        <span class="text-green-400">${collectionPostcode}</span>
                        <span class="material-symbols-outlined text-gray-400 text-sm">arrow_forward</span>
                        <span class="text-red-400">${deliveryPostcode}</span>
                    </div>
                `;
            });
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-orange-500/30 bg-orange-900/10 p-4';
            
            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-orange-600 rounded-full flex items-center justify-center">
                        <span class="material-symbols-outlined text-white text-lg">route</span>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-white">Route ${routeNumber}</h3>
                        <p class="text-sm text-gray-400">${jobs.length} job${jobs.length !== 1 ? 's' : ''}</p>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-orange-400 font-medium">No Driver</span>
                    </div>
                </div>
                <div class="space-y-1">
                    ${jobPairsHTML}
                </div>
                <div class="text-sm text-gray-400">
                    This route was not assigned to any drivers during optimization.
                </div>
            `;
            
            return card;
        }
        
        // Find optimal assignment using a greedy approach (simplified Hungarian algorithm)
        function findOptimalAssignment(assignments, numRoutes, numDrivers) {
            // Sort assignments by total distance (ascending)
            assignments.sort((a, b) => a.totalDistance - b.totalDistance);
            
            const assignedRoutes = new Set();
            const assignedDrivers = new Set();
            const optimalAssignment = [];
            
            // Greedy assignment: pick the best available option at each step
            for (const assignment of assignments) {
                // Skip if this route or driver is already assigned
                if (assignedRoutes.has(assignment.routeIndex) || assignedDrivers.has(assignment.driverIndex)) {
                    continue;
                }
                
                // Assign this driver to this route
                assignedRoutes.add(assignment.routeIndex);
                assignedDrivers.add(assignment.driverIndex);
                optimalAssignment.push(assignment);
                
                // Stop if we've assigned all routes
                if (optimalAssignment.length === numRoutes) {
                    break;
                }
            }
            
            // If we have more drivers than routes, we're done
            // If we have more routes than drivers, assign remaining routes to the best available driver
            if (optimalAssignment.length < numRoutes) {
                console.warn(`â ï¸ More routes (${numRoutes}) than drivers (${numDrivers}). Some routes will be unassigned.`);
            }
            
            return optimalAssignment;
        }

        // Find optimal assignment using priority score (taxi priority over transit)
        function findOptimalAssignmentByPriority(assignments, numRoutes, numDrivers) {
            // Sort assignments by priority score (descending - highest priority first)
            assignments.sort((a, b) => b.priorityScore - a.priorityScore);
            
            const assignedRoutes = new Set();
            const assignedDrivers = new Set();
            const optimalAssignment = [];
            
            // Greedy assignment: pick the best available option at each step
            for (const assignment of assignments) {
                // Skip if this route or driver is already assigned
                if (assignedRoutes.has(assignment.routeIndex) || assignedDrivers.has(assignment.driverIndex)) {
                    continue;
                }
                
                // Assign this driver to this route
                assignedRoutes.add(assignment.routeIndex);
                assignedDrivers.add(assignment.driverIndex);
                optimalAssignment.push(assignment);
                
                // Stop if we've assigned all routes or all drivers
                if (optimalAssignment.length === Math.min(numRoutes, numDrivers)) {
                    break;
                }
            }
            
            console.log(`ð Assignment summary: ${optimalAssignment.length} routes assigned`);
            
            return optimalAssignment;
        }

        // Assign drivers to demo routes using optimal assignment algorithm
        async function assignDriversToRoutes() {
            const routes = [
                { id: 1, delivery: "M1 4AN", collection: "B797RU" },
                { id: 2, delivery: "B775JA", collection: "CV1 1GF" },
                { id: 3, delivery: "LS1 4DY", collection: "S1 2HE" }
            ];

            if (drivers.length === 0) {
                console.log('No drivers available for demo assignment');
                return;
            }

            // Calculate all possible driver-route combinations for demo routes
            const assignments = [];
            
            for (let routeIndex = 0; routeIndex < routes.length; routeIndex++) {
                const route = routes[routeIndex];
                
                console.log(`Calculating distances for Demo Route ${route.id} (Collection: ${route.collection}, Delivery: ${route.delivery})`);
                
                // Calculate distances for each driver with this route
                for (let driverIndex = 0; driverIndex < drivers.length; driverIndex++) {
                    const driver = drivers[driverIndex];
                    
                    try {
                        // Use carry-over postcode for distance TO collection, home postcode for distance FROM delivery
                        const startingPostcode = carryOverPostcodes[driverIndex] || driver.postcode;
                        const endingPostcode = driver.postcode; // Always use home postcode for return journey
                        
                        const distanceToCollection = await calculateDistance(startingPostcode, route.collection);
                        const distanceFromDelivery = await calculateDistance(route.delivery, endingPostcode);
                        const totalDistance = distanceToCollection + distanceFromDelivery;
                        
                        assignments.push({
                            routeIndex: routeIndex,
                            routeId: route.id,
                            driverIndex: driverIndex,
                            driver: driver,
                            distanceToCollection: distanceToCollection,
                            distanceFromDelivery: distanceFromDelivery,
                            totalDistance: totalDistance
                        });
                        
                        const carryOverInfo = carryOverPostcodes[driverIndex] ? ` (carry-over: ${carryOverPostcodes[driverIndex]})` : '';
                        console.log(`Driver ${driver.name}${carryOverInfo} â Demo Route ${route.id}: ${distanceToCollection} mi to collection + ${distanceFromDelivery} mi from delivery = ${totalDistance} mi total`);
                        
                    } catch (error) {
                        console.error(`Error calculating distance for driver ${driver.name} and demo route ${route.id}:`, error);
                        // Add with default distances
                        assignments.push({
                            routeIndex: routeIndex,
                            routeId: route.id,
                            driverIndex: driverIndex,
                            driver: driver,
                            distanceToCollection: 100,
                            distanceFromDelivery: 100,
                            totalDistance: 200
                        });
                    }
                }
            }
            
            // Find optimal assignment
            const optimalAssignment = findOptimalAssignment(assignments, routes.length, drivers.length);
            
            console.log('Optimal demo assignment found:', optimalAssignment);
            
            // Apply the optimal assignment to demo UI
            for (const assignment of optimalAssignment) {
                const routeId = assignment.routeId;
                
                // Update UI
                document.getElementById(`route-${routeId}-driver`).textContent = assignment.driver.name;
                document.getElementById(`route-${routeId}-driver-location`).textContent = assignment.driver.postcode;
                
                // Display both distances
                document.getElementById(`route-${routeId}-distance-to-collection`).textContent = `${assignment.distanceToCollection} miles`;
                document.getElementById(`route-${routeId}-distance`).textContent = `${assignment.distanceFromDelivery} miles`;
                
                // Update progress bars
                const progressToCollectionBar = document.getElementById(`route-${routeId}-progress-to-collection`);
                const progressHomeBar = document.getElementById(`route-${routeId}-progress`);
                
                // Update collection distance progress bar
                if (progressToCollectionBar) {
                    const percentage = Math.min((assignment.distanceToCollection / 100) * 100, 100);
                    progressToCollectionBar.style.width = `${percentage}%`;
                    
                    // Apply gradient based on distance
                    if (assignment.distanceToCollection <= 20) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #10b981, #34d399)'; // Green gradient
                    } else if (assignment.distanceToCollection <= 40) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)'; // Orange gradient
                    } else if (assignment.distanceToCollection <= 60) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #f97316, #fb923c)'; // Red-orange gradient
                } else {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red gradient
                    }
                }
                
                // Update home distance progress bar
                if (progressHomeBar) {
                    const percentage = Math.min((assignment.distanceFromDelivery / 100) * 100, 100);
                    progressHomeBar.style.width = `${percentage}%`;
                    
                    // Apply gradient based on distance
                    if (assignment.distanceFromDelivery <= 20) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #10b981, #34d399)'; // Green gradient
                    } else if (assignment.distanceFromDelivery <= 40) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)'; // Orange gradient
                    } else if (assignment.distanceFromDelivery <= 60) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #f97316, #fb923c)'; // Red-orange gradient
                    } else {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red gradient
                    }
                }
                
            }
            
            const totalDistance = optimalAssignment.reduce((sum, assignment) => sum + assignment.totalDistance, 0);
        }

        // Find best driver for a route based on minimizing sum of distance to first collection + distance from last delivery
        async function findBestDriver(deliveryAddress, collectionAddress) {
            if (!drivers || drivers.length === 0) {
                console.log('No drivers available');
                return { name: 'No Driver', postcode: 'Unknown' };
            }
            
            // Extract postcodes from addresses if they're full addresses
            let deliveryPostcode = deliveryAddress;
            let collectionPostcode = collectionAddress;
            
            if (deliveryAddress.includes(',')) {
                const parts = deliveryAddress.split(',');
                deliveryPostcode = parts[0].trim();
            }
            
            if (collectionAddress.includes(',')) {
                const parts = collectionAddress.split(',');
                collectionPostcode = parts[0].trim();
            }
            
            console.log('Finding best driver for collection:', collectionPostcode, 'and delivery:', deliveryPostcode);
            
            let bestDriver = drivers[0];
            let shortestTotalDistance = Infinity;
            let bestDistances = { toCollection: 0, fromDelivery: 0 };
            
            // Calculate total distance (to first collection + from last delivery) for each driver
            for (const driver of drivers) {
                try {
                    const distanceToCollection = await calculateDistance(driver.postcode, collectionPostcode);
                    const distanceFromDelivery = await calculateDistance(deliveryPostcode, driver.postcode);
                    const totalDistance = distanceToCollection + distanceFromDelivery;
                    
                    console.log(`Driver ${driver.name} (${driver.postcode}): ${distanceToCollection} mi to collection + ${distanceFromDelivery} mi from delivery = ${totalDistance} mi total`);
                    
                    if (totalDistance < shortestTotalDistance) {
                        shortestTotalDistance = totalDistance;
                        bestDriver = driver;
                        bestDistances = { toCollection: distanceToCollection, fromDelivery: distanceFromDelivery };
                    }
                } catch (error) {
                    console.error(`Error calculating distance for driver ${driver.name}:`, error);
                    // Use default distances for this driver
                    const defaultTotalDistance = 200;
                    if (defaultTotalDistance < shortestTotalDistance) {
                        shortestTotalDistance = defaultTotalDistance;
                        bestDriver = driver;
                        bestDistances = { toCollection: 100, fromDelivery: 100 };
                    }
                }
            }
            
            console.log(`Best driver: ${bestDriver.name} (${bestDriver.postcode}) - ${bestDistances.toCollection} mi to collection + ${bestDistances.fromDelivery} mi from delivery = ${shortestTotalDistance} mi total`);
            return { 
                ...bestDriver, 
                distance: bestDistances.fromDelivery, // Keep for backward compatibility
                distanceToCollection: bestDistances.toCollection,
                totalDistance: shortestTotalDistance
            };
        }

        // Google Maps Distance Matrix API integration
        let distanceMatrixService;
        let isGoogleMapsLoaded = false;
        let googleMapsError = null;

        // Google Maps callback function
        window.initGoogleMaps = function() {
            try {
                if (window.google && window.google.maps) {
                    distanceMatrixService = new google.maps.DistanceMatrixService();
                    isGoogleMapsLoaded = true;
                }
            } catch (error) {
                googleMapsError = error;
                console.error('â Google Maps API initialization error:', error);
                console.error('Make sure Distance Matrix API, Geocoding API, and Maps JavaScript API are enabled');
            }
        };

        // Wait for Google Maps to load
        function waitForGoogleMaps() {
            return new Promise((resolve, reject) => {
                if (googleMapsError) {
                    reject(googleMapsError);
                    return;
                }
                
                if (window.google && window.google.maps && distanceMatrixService) {
                    resolve(true);
                } else {
                    setTimeout(() => waitForGoogleMaps().then(resolve).catch(reject), 100);
                }
            });
        }

        // Calculate distance between two postcodes using Google Maps Distance Matrix API
        async function calculateDistance(postcode1, postcode2) {
            try {
                // Add UK to postcodes for better geocoding
                const origin = `${postcode1}, UK`;
                const destination = `${postcode2}, UK`;

                const calculateDistanceFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateDistance');
                const result = await calculateDistanceFunction({
                    origin: origin,
                    destination: destination
                });
                
                if (result.data.success) {
                    return Math.round(result.data.distance);
                } else {
                    console.warn(`â ï¸ Firebase Functions error for ${postcode1} to ${postcode2}:`, result.data.error);
                    return calculateFallbackDistance(postcode1, postcode2);
                }
            } catch (error) {
                console.warn('Firebase Functions not available, using fallback calculation:', error.message);
                return calculateFallbackDistance(postcode1, postcode2);
            }
        }

        // Enhanced fallback distance calculation when Google Maps API is not available
        function calculateFallbackDistance(postcode1, postcode2) {
            // More comprehensive UK postcode area distance mapping
            const area1 = postcode1.substring(0, 1);
            const area2 = postcode2.substring(0, 1);
            
            // If same area, estimate shorter distance
            if (area1 === area2) {
                const distance = Math.floor(Math.random() * 30) + 10; // 10-40 miles within same area
                console.log(`ð Same area (${area1}) distance from ${postcode1} to ${postcode2}: ${distance} miles`);
                return distance;
            }
            
            // Cross-area distances (more realistic UK distances)
            const areaDistances = {
                'B': { 'M': 85, 'L': 125, 'S': 120, 'E': 140, 'N': 130, 'default': 65 },
                'M': { 'B': 85, 'L': 45, 'S': 185, 'E': 200, 'N': 220, 'default': 55 },
                'L': { 'B': 125, 'M': 45, 'S': 205, 'E': 180, 'N': 100, 'default': 85 },
                'S': { 'B': 120, 'M': 185, 'L': 205, 'E': 50, 'N': 150, 'default': 110 },
                'E': { 'B': 140, 'M': 200, 'L': 180, 'S': 50, 'N': 120, 'default': 95 },
                'N': { 'B': 130, 'M': 220, 'L': 100, 'S': 150, 'E': 120, 'default': 90 }
            };
            
            const baseDistance = areaDistances[area1]?.[area2] || areaDistances[area1]?.['default'] || 60;
            // Add some variation to make it more realistic
            const variation = Math.floor(Math.random() * 20) - 10; // Â±10 miles variation
            const distance = Math.max(10, baseDistance + variation); // Minimum 10 miles
            
            console.log(`ð Fallback distance from ${postcode1} (${area1}) to ${postcode2} (${area2}): ${distance} miles`);
            return distance;
        }

        // Fallback straight-line distance calculation using Google Maps Geometry library
        function calculateStraightLineDistance(postcode1, postcode2) {
            const geocoder = new google.maps.Geocoder();
            
            return new Promise((resolve) => {
                const geocodePromises = [
                    new Promise((res) => geocoder.geocode({ address: `${postcode1}, UK` }, res)),
                    new Promise((res) => geocoder.geocode({ address: `${postcode2}, UK` }, res))
                ];

                Promise.all(geocodePromises).then(([result1, result2]) => {
                    if (result1[0] && result1[0].status === 'OK' && result2[0] && result2[0].status === 'OK') {
                        const location1 = result1[0].results[0].geometry.location;
                        const location2 = result2[0].results[0].geometry.location;
                        
                        const distance = google.maps.geometry.spherical.computeDistanceBetween(location1, location2);
                        const distanceInMiles = distance * 0.000621371;
                        console.log(`Straight-line distance from ${postcode1} to ${postcode2}: ${distanceInMiles.toFixed(1)} miles`);
                        resolve(Math.round(distanceInMiles));
                    } else {
                        console.warn('Geocoding failed, using fallback estimation');
                        resolve(calculateFallbackDistance(postcode1, postcode2));
                    }
                }).catch(() => {
                    resolve(calculateFallbackDistance(postcode1, postcode2));
                });
            });
        }

        // Clear all routes (both Firebase and localStorage)

        // Load and display routes function (can be called manually)
        async function loadAndDisplayRoutes() {
            const loadButton = document.querySelector('button[onclick="loadAndDisplayRoutes()"]');
            const originalText = loadButton ? loadButton.innerHTML : '';
            
            if (loadButton) {
                loadButton.innerHTML = '<span class="animate-spin">â³</span> Loading...';
                loadButton.disabled = true;
            }
            
            try {
                await displayRoutesFromFirebase();
                console.log('Routes loaded successfully');
            } catch (error) {
                console.error('Error loading routes:', error);
                alert('Error loading routes: ' + error.message);
            } finally {
                if (loadButton) {
                    loadButton.innerHTML = originalText;
                    loadButton.disabled = false;
                }
            }
        }

        // Delete all routes
        async function deleteAllRoutes() {
            // Confirm deletion
            if (!confirm('Are you sure you want to delete ALL routes? This action cannot be undone.')) {
                return;
            }
            
            // Double confirmation
            if (!confirm('This will permanently delete all routes from Firebase. Are you absolutely sure?')) {
                return;
            }

            const deleteButton = document.querySelector('button[onclick="deleteAllRoutes()"]');
            const originalText = deleteButton ? deleteButton.innerHTML : '';
            
            if (deleteButton) {
                deleteButton.innerHTML = '<span class="animate-spin">â³</span> Deleting...';
                deleteButton.disabled = true;
            }

            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    alert('Cannot delete routes without office context.');
                    return;
                }

                // Check if Firebase is available
                if (!window.firestore || !window.firebaseCollection) {
                    // If Firebase not available, just clear local state
                    savedRoutes = [];
                    localStorage.removeItem('savedRoutes');
                    alert('Firebase not available. Cleared local routes only.');
                    // Refresh UI
                    await displayRoutesFromFirebase();
                    return;
                }

                console.log('Deleting all routes and jobs from Firebase...');
                
                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                const jobsCollection = window.firebaseCollection(window.firestore, 'jobs');
                
                // Get all routes for this office
                const officeRoutesQuery = window.firebaseQuery(
                    routesCollection, 
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const routesSnapshot = await window.firebaseGetDocs(officeRoutesQuery);
                
                // Get all jobs for this office
                const officeJobsQuery = window.firebaseQuery(
                    jobsCollection,
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const jobsSnapshot = await window.firebaseGetDocs(officeJobsQuery);
                
                if (routesSnapshot.empty && jobsSnapshot.empty) {
                    alert('No routes or jobs found to delete.');
                    return;
                }

                // Delete all jobs first (they reference routes)
                const jobDeletePromises = [];
                jobsSnapshot.forEach((doc) => {
                    jobDeletePromises.push(window.firebaseDeleteDoc(doc.ref));
                });
                
                await Promise.all(jobDeletePromises);
                console.log(`Deleted ${jobsSnapshot.size} jobs from Firebase`);

                // Delete each route document
                const routeDeletePromises = [];
                routesSnapshot.forEach((doc) => {
                    routeDeletePromises.push(window.firebaseDeleteDoc(doc.ref));
                });

                await Promise.all(routeDeletePromises);
                
                console.log(`Deleted ${routesSnapshot.size} routes from Firebase`);
                
                // Clear local state
                savedRoutes = [];
                localStorage.removeItem('savedRoutes');
                
                // Clear the routes container immediately
                const routesContainer = document.getElementById('routes-container');
                const noRoutesMessage = document.getElementById('no-routes-message');
                if (routesContainer) {
                    // Remove all dynamic route elements
                    const dynamicRoutes = routesContainer.querySelectorAll('.dynamic-route');
                    dynamicRoutes.forEach(route => route.remove());
                }
                
                // Show no routes message immediately
                if (noRoutesMessage) {
                    noRoutesMessage.style.display = 'block';
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2">No saved routes available</p>
                        <p class="text-sm">Go to the Routes page to create and save routes first</p>
                    `;
                }
                
                // Also hide authorization, driverless, and jobless sections
                const authSection = document.getElementById('authorization-routes-section');
                const driverlessSection = document.getElementById('driverless-routes-section');
                const joblessSection = document.getElementById('jobless-drivers-section');
                if (authSection) authSection.classList.add('hidden');
                if (driverlessSection) driverlessSection.classList.add('hidden');
                if (joblessSection) joblessSection.classList.add('hidden');
                
                // Refresh UI from Firebase (should confirm no routes)
                await displayRoutesFromFirebase();
                
                const totalDeleted = routesSnapshot.size + jobsSnapshot.size;
                alert(`Successfully deleted ${routesSnapshot.size} route${routesSnapshot.size === 1 ? '' : 's'} and ${jobsSnapshot.size} job${jobsSnapshot.size === 1 ? '' : 's'} (${totalDeleted} total).`);
                
            } catch (error) {
                console.error('Error deleting routes:', error);
                alert('Error deleting routes: ' + error.message);
            } finally {
                if (deleteButton) {
                    deleteButton.innerHTML = originalText;
                    deleteButton.disabled = false;
                }
            }
        }

        // Load routes with their last assigned drivers (quick load)
        async function loadLastAssignedDrivers() {
            const loadButton = document.querySelector('button[onclick="loadLastAssignedDrivers()"]');
            const originalText = loadButton ? loadButton.innerHTML : '';
            
            if (loadButton) {
                loadButton.innerHTML = '<span class="animate-spin">â³</span> Loading...';
                loadButton.disabled = true;
            }
            
            try {
                console.log('Loading routes with last assigned drivers...');
                savedRoutes = await loadRoutesFromFirebase();
                
                if (savedRoutes.length === 0) {
                    showNoRoutesMessage();
                    return;
                }

                // Load drivers to check for unmatched routes/drivers
                await loadDriversFromFirebase();
                
                // Display routes with their assigned drivers
                await displayRoutesWithAssignments();
                
                // Handle unmatched routes and drivers
                await handleUnmatchedRoutesAndDrivers();
                
                console.log('Successfully loaded routes with last assigned drivers');
            } catch (error) {
                console.error('Error loading last assigned drivers:', error);
                showNoRoutesMessage(error);
            } finally {
                if (loadButton) {
                    loadButton.innerHTML = originalText;
                    loadButton.disabled = false;
                }
            }
        }

        // Display routes with their previously assigned drivers
        async function displayRoutesWithAssignments() {
            const routesContainer = document.getElementById('routes-container');
            if (!routesContainer) return;

            routesContainer.innerHTML = '';

            for (let i = 0; i < savedRoutes.length; i++) {
                const routeData = savedRoutes[i];
                const routeNumber = i + 1;
                
                // Only display routes that have assigned drivers (skip driverless routes)
                if (!routeData.route.assignedDriverName) {
                    continue; // Skip driverless routes - they're shown in driverless section
                }
                
                // Create route card with assigned driver if available
                const routeDiv = createRouteElement(routeData.route, routeData.jobs, routeNumber);
                routesContainer.appendChild(routeDiv);
                
                // Populate driver assignment data if it exists
                if (routeData.route.assignedDriverName) {
                    const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                    const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                    const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                    
                    if (driverElement) {
                        driverElement.textContent = routeData.route.assignedDriverName;
                    }
                    
                    if (locationElement) {
                        locationElement.textContent = routeData.route.assignedDriverPostcode || '-';
                    }
                    
                    // Get REG number from first job
                    if (regElement && routeData.jobs.length > 0) {
                        const firstJob = routeData.jobs[0];
                        const regNumber = firstJob?.parsedData?.reg_number || '-';
                        regElement.textContent = regNumber;
                    }
                    
                    // Restore carryover information if it exists
                    if (routeData.route.carryoverPostcode) {
                        const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                        const carryoverPostcode = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                        if (carryoverDisplay) carryoverDisplay.classList.remove('hidden');
                        if (carryoverPostcode) carryoverPostcode.textContent = routeData.route.carryoverPostcode;
                    }
                    
                    // Restore route score if it exists
                    if (routeData.route.routeScore) {
                        const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                        const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                        
                        if (scoreElement) {
                            scoreElement.textContent = routeData.route.routeScore.score;
                        }
                        
                        if (scoreContainer) {
                            // Apply color based on score
                            if (routeData.route.routeScore.color === 'green') {
                                scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                            } else if (routeData.route.routeScore.color === 'orange') {
                                scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                            } else {
                                scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                            }
                        }
                    }
                    
                    console.log(`â Restored assignment: ${routeData.route.assignedDriverName} to route ${routeNumber}`);
                }
            }
        }

        // Show no routes message
        function showNoRoutesMessage(error = null) {
            const routesContainer = document.getElementById('routes-container');
            if (routesContainer) {
                const message = error ? 
                    `<p class="text-red-400 text-center">Error loading routes: ${error.message || error}</p>` :
                    `<p class="text-gray-400 text-center">No routes found. Create routes in the Routes page first.</p>`;
                routesContainer.innerHTML = message;
            }
            
            // Hide all sections
            const authSection = document.getElementById('authorization-routes-section');
            const joblessSection = document.getElementById('jobless-drivers-section');
            const driverlessSection = document.getElementById('driverless-routes-section');
            
            if (authSection) authSection.classList.add('hidden');
            if (joblessSection) joblessSection.classList.add('hidden');
            if (driverlessSection) driverlessSection.classList.add('hidden');
        }
        
        // Display jobless drivers section
        function displayJoblessDrivers(joblessDrivers) {
            const joblessDriversSection = document.getElementById('jobless-drivers-section');
            const joblessDriversContainer = document.getElementById('jobless-drivers-container');
            
            if (!joblessDriversSection || !joblessDriversContainer) return;
            
            if (joblessDrivers.length > 0) {
                joblessDriversContainer.innerHTML = '';
                joblessDrivers.forEach(driver => {
                    const card = createJoblessDriverCard(driver);
                    joblessDriversContainer.appendChild(card);
                });
                joblessDriversSection.classList.remove('hidden');
            } else {
                joblessDriversSection.classList.add('hidden');
            }
        }
        
        // Display driverless routes section
        function displayDriverlessRoutes(driverlessRoutes) {
            const driverlessRoutesSection = document.getElementById('driverless-routes-section');
            const driverlessRoutesContainer = document.getElementById('driverless-routes-container');
            
            if (!driverlessRoutesSection || !driverlessRoutesContainer) return;
            
            if (driverlessRoutes.length > 0) {
                driverlessRoutesContainer.innerHTML = '';
                driverlessRoutes.forEach((route, index) => {
                    const card = createDriverlessRouteCard(route, index);
                    driverlessRoutesContainer.appendChild(card);
                });
                driverlessRoutesSection.classList.remove('hidden');
            } else {
                driverlessRoutesSection.classList.add('hidden');
            }
        }

        // Handle unmatched routes and drivers
        async function handleUnmatchedRoutesAndDrivers() {
            const assignedDriverIds = new Set();
            const assignedRouteIds = new Set();
            
            // Track which drivers and routes are assigned
            savedRoutes.forEach(route => {
                if (route.route.assignedDriver) {
                    assignedDriverIds.add(route.route.assignedDriver.uid || route.route.assignedDriver.id);
                    assignedRouteIds.add(route.route.id);
                }
            });
            
            // Find jobless drivers (drivers not assigned to any route)
            const joblessDrivers = drivers.filter(driver => {
                const driverId = driver.uid || driver.id;
                return !assignedDriverIds.has(driverId);
            });
            
            // Find driverless routes (routes without assigned drivers)
            const driverlessRoutes = savedRoutes.filter(route => !route.route.assignedDriver);
            
            // Display jobless drivers section
            if (joblessDrivers.length > 0) {
                displayJoblessDrivers(joblessDrivers);
            }
            
            // Display driverless routes section
            if (driverlessRoutes.length > 0) {
                displayDriverlessRoutes(driverlessRoutes);
            }
        }

        // Make functions globally available
        window.loadAndDisplayRoutes = loadAndDisplayRoutes;
        window.loadLastAssignedDrivers = loadLastAssignedDrivers;
        window.optimizeRoutes = optimizeRoutes;
        window.showNotifications = showNotifications;
        window.showAlterationsPopup = showAlterationsPopup;
        window.closeAlterationsPopup = closeAlterationsPopup;
        window.startOptimization = startOptimization;
        window.addCarryOverDriver = addCarryOverDriver;
        window.removeCarryOver = removeCarryOver;
        window.showOptimiseSettings = showOptimiseSettings;
        // Authorize a route - assign driver and mark for red car display
        async function authorizeRoute(routeIndex, driverIndex) {
            try {
                // Find the assignment in our stored assignments
                const assignment = window.currentAssignments.find(a => 
                    a.routeIndex === routeIndex && a.driverIndex === driverIndex
                );
                
                if (!assignment) {
                    console.error('Assignment not found');
                    return;
                }
                
                const route = assignment.routeData;
                const driver = assignment.driver;
                const routeNumber = route.route.routeNumber;
                
                // Mark this route as authorized (will show red car icon)
                route.requiresAuthorization = true;
                route.authorizationApproved = true;
                
                // Assign the driver to the route
                await updateRouteDistances(
                    routeNumber,
                    driver.homePostcode || driver.postcode,
                    route.jobs
                );
                
                // Remove from authorization section
                const authCard = document.getElementById(`auth-route-${routeIndex}`);
                if (authCard) {
                    authCard.remove();
                }
                
                // Check if authorization section is now empty
                const authContainer = document.getElementById('authorization-routes-container');
                const authSection = document.getElementById('authorization-routes-section');
                if (authContainer && authContainer.children.length === 0) {
                    authSection.classList.add('hidden');
                }
                
                // Find the route element in the assigned routes section
                const routeElement = document.getElementById(`firebase-route-${routeNumber}`);
                if (routeElement) {
                    // Scroll to the route
                    routeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Add a visual highlight temporarily
                    routeElement.classList.add('ring-2', 'ring-green-500');
                    setTimeout(() => {
                        routeElement.classList.remove('ring-2', 'ring-green-500');
                    }, 2000);
                }
                
                console.log(`â Route ${routeNumber} authorized for driver ${driver.firstName} ${driver.lastName}`);
            } catch (error) {
                console.error('Error authorizing route:', error);
            }
        }
        
        window.closeOptimiseSettings = closeOptimiseSettings;
        window.startOptimisationWithSettings = startOptimisationWithSettings;
        window.selectOptimiseDay = selectOptimiseDay;
        window.toggleDriverOffStatus = toggleDriverOffStatus;
        window.removeDriverFromOff = removeDriverFromOff;
        window.toggleTravelDetails = toggleTravelDetails;
        window.authorizeRoute = authorizeRoute;

        // Wait for Firebase to be ready
        function waitForFirebase() {
            return new Promise((resolve) => {
                const checkFirebase = () => {
                    if (window.firestore && window.firebaseCollection) {
                        console.log('Firebase is ready!');
                        resolve(true);
                    } else {
                        console.log('Waiting for Firebase...');
                        setTimeout(checkFirebase, 100);
                    }
                };
                checkFirebase();
            });
        }

        // Show optimization info modal
        function showOptimizationInfo() {
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
            overlay.id = 'optimization-info-overlay';
            overlay.onclick = function(e) {
                if (e.target === overlay) {
                    closeOptimizationInfo();
                }
            };
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto border border-gray-700" onclick="event.stopPropagation()">
                    <div class="p-6">
                        <div class="flex items-center justify-between mb-6">
                            <h3 class="text-2xl font-bold text-white">How Optimization Works</h3>
                            <button onclick="closeOptimizationInfo()" class="text-gray-400 hover:text-white">
                                <span class="material-symbols-outlined">close</span>
                            </button>
                        </div>
                        
                        <div class="space-y-6">
                            <!-- Overview Tab -->
                            <div id="info-overview" class="space-y-4">
                                <div>
                                    <h4 class="text-lg font-bold text-white mb-3">Step-by-Step Process</h4>
                                    <div class="space-y-3 text-gray-300">
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">1.</span>
                                            <div>
                                                <p class="font-semibold">Calculate Route Distances</p>
                                                <p class="text-sm text-gray-400">For each route, sum all collectionâdelivery driving distances (Col AâDel A + Col BâDel B + ...)</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">2.</span>
                                            <div>
                                                <p class="font-semibold">Sort Routes by Distance</p>
                                                <p class="text-sm text-gray-400">Routes are sorted from shortest to longest total driving distance</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">3.</span>
                                            <div>
                                                <p class="font-semibold">Assign Shortest Routes to Carryover Drivers</p>
                                                <p class="text-sm text-gray-400">If you have N carryover drivers, the N shortest routes are assigned to them (they start late, so need quick routes)</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">4.</span>
                                            <div>
                                                <p class="font-semibold">Calculate Travel Times</p>
                                                <p class="text-sm text-gray-400">For each driver-route combination, calculate time TO work (home/carryover â first collection) and FROM work (last delivery â home)</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">5.</span>
                                            <div>
                                                <p class="font-semibold">Determine Travel Mode</p>
                                                <p class="text-sm text-gray-400">â¤18min drive = Taxi | >18min = Public Transport | No transit = Find train station | >2hrs = Mixed mode (drive + train)</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">6.</span>
                                            <div>
                                                <p class="font-semibold">Calculate Priority Scores</p>
                                                <p class="text-sm text-gray-400">Both Taxi: 10,000 - time | One Taxi: 5,000 - transit time | Both Transit: 1,000 - time</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-3">
                                            <span class="text-blue-400 font-bold">7.</span>
                                            <div>
                                                <p class="font-semibold">Greedy Assignment</p>
                                                <p class="text-sm text-gray-400">Sort all combinations by priority score, then assign highest-scoring available driver-route pairs</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="border-t border-gray-700 pt-4">
                                    <h4 class="text-lg font-bold text-white mb-3">Carryover Logic</h4>
                                    <div class="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-4 text-gray-300">
                                        <p class="mb-2"><strong>Why shortest routes for carryover drivers?</strong></p>
                                        <p class="text-sm">Carryover drivers must deliver their previous day's vehicle first (usually to a business opening at 9am). This means they arrive at their first collection late. By giving them the shortest routes, we ensure they can complete all their jobs on time.</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="mt-6 flex justify-end">
                            <button onclick="closeOptimizationInfo()" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        function closeOptimizationInfo() {
            const overlay = document.getElementById('optimization-info-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Geocode a postcode to get coordinates
        async function geocodePostcode(postcode) {
            return new Promise((resolve, reject) => {
                if (!window.google || !window.google.maps) {
                    reject(new Error('Google Maps not loaded'));
                    return;
                }
                
                const geocoder = new google.maps.Geocoder();
                geocoder.geocode({ address: `${postcode}, UK` }, (results, status) => {
                    if (status === 'OK' && results[0]) {
                        resolve(results[0].geometry.location);
                    } else {
                        reject(new Error(`Geocoding failed: ${status}`));
                    }
                });
            });
        }

        // Get directions between two points (accepts postcodes, LatLng objects, or coordinate strings)
        async function getDirections(origin, destination) {
            return new Promise((resolve, reject) => {
                if (!window.google || !window.google.maps) {
                    reject(new Error('Google Maps not loaded'));
                    return;
                }
                
                // Format address - handle LatLng objects, coordinate strings, or postcodes
                const formatAddress = (addr) => {
                    // If it's a LatLng object
                    if (addr && typeof addr.lat === 'function') {
                        return addr;
                    }
                    // If it's a string
                    if (typeof addr === 'string') {
                        // Check if it's already coordinates (lat,lng format)
                        if (addr.includes(',') && !isNaN(parseFloat(addr.split(',')[0]))) {
                            return addr;
                        }
                        // Add UK to postcode
                        return `${addr}, UK`;
                    }
                    return addr;
                };
                
                const directionsService = new google.maps.DirectionsService();
                directionsService.route({
                    origin: formatAddress(origin),
                    destination: formatAddress(destination),
                    travelMode: google.maps.TravelMode.DRIVING
                }, (result, status) => {
                    if (status === 'OK') {
                        resolve(result.routes[0].overview_path);
                    } else {
                        reject(new Error(`Directions failed: ${status}`));
                    }
                });
            });
        }

        // Show "why this driver" info for a specific route
        async function showWhyThisDriver(routeNumber) {
            const details = window.routeAssignmentDetails?.[routeNumber];
            if (!details) {
                alert('Assignment details not available for this route.');
                return;
            }
            
            // Get route data from assignment details or savedRoutes
            const routeData = details.routeData || savedRoutes.find((r, idx) => {
                return (idx + 1) === routeNumber;
            });
            
            if (!routeData) {
                alert('Route data not available.');
                return;
            }
            
            const jobs = routeData.jobs || [];
            const driverName = details.driver.name || (details.driver.firstName + ' ' + details.driver.lastName) || 'Unknown Driver';
            const modeText = details.bothTaxi ? 'Both Taxi' : details.oneTaxi ? 'One Taxi' : 'Both Transit';
            const carryoverText = details.hasCarryover ? ` (Carryover from ${details.carryoverPostcode})` : '';
            
            // Get starting postcode (carryover or home)
            const startPostcode = details.hasCarryover ? details.carryoverPostcode : (details.driver.homePostcode || details.driver.postcode);
            const endPostcode = details.driver.homePostcode || details.driver.postcode;
            
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center p-4';
            overlay.id = 'why-driver-overlay';
            overlay.onclick = function(e) {
                if (e.target === overlay) {
                    closeWhyThisDriver();
                }
            };
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg max-w-4xl w-full max-h-[90vh] overflow-y-auto border border-gray-700" onclick="event.stopPropagation()">
                    <div class="p-6">
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-bold text-white">Why ${driverName} for Route ${routeNumber}?</h3>
                            <button onclick="closeWhyThisDriver()" class="text-gray-400 hover:text-white">
                                <span class="material-symbols-outlined">close</span>
                            </button>
                        </div>
                        
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                            <!-- Left Column: Info -->
                            <div class="space-y-4">
                                <div class="bg-green-900 bg-opacity-20 border border-green-700 rounded-lg p-4">
                                    <p class="text-green-400 font-semibold mb-2">Selected Driver</p>
                                    <p class="text-white">${driverName}${carryoverText}</p>
                                    <p class="text-sm text-gray-400 mt-2">Priority Score: ${details.priorityScore.toFixed(0)}</p>
                                    <p class="text-sm text-gray-400">Total Time: ${details.totalTime} minutes</p>
                                    <p class="text-sm text-gray-400">Mode: ${modeText}</p>
                                </div>
                                
                                <div>
                                    <p class="text-white font-semibold mb-2">All Drivers Considered:</p>
                                    <div class="space-y-2 max-h-64 overflow-y-auto">
                                        ${details.allConsideredDrivers.map((d, idx) => {
                                            const dName = d.driver.name || (d.driver.firstName + ' ' + d.driver.lastName) || 'Unknown';
                                            const isSelected = d.driver.id === details.driver.id;
                                            return `
                                                <div class="bg-gray-800 rounded p-3 ${isSelected ? 'border-2 border-green-500' : 'border border-gray-700'}">
                                                    <div class="flex justify-between items-center">
                                                        <span class="text-white ${isSelected ? 'font-bold' : ''}">${idx + 1}. ${dName}${isSelected ? ' â SELECTED' : ''}</span>
                                                        <span class="text-gray-400 text-sm">Score: ${d.priorityScore.toFixed(0)}</span>
                                                    </div>
                                                    <p class="text-xs text-gray-500 mt-1">Time: ${d.totalTime} min</p>
                                                </div>
                                            `;
                                        }).join('')}
                                    </div>
                                </div>
                                
                                ${details.isCarryoverRoute ? `
                                    <div class="bg-blue-900 bg-opacity-20 border border-blue-700 rounded-lg p-3">
                                        <p class="text-blue-400 text-sm">â¹ï¸ This route was assigned to a carryover driver because it's one of the ${details.allConsideredDrivers.length} shortest routes.</p>
                                    </div>
                                ` : ''}
                            </div>
                            
                            <!-- Right Column: Map -->
                            <div>
                                <p class="text-white font-semibold mb-2">Route Map</p>
                                <div id="why-driver-map" class="w-full h-96 rounded-lg border border-gray-700 bg-gray-900"></div>
                                <p class="text-xs text-gray-400 mt-2">
                                    <span class="inline-block w-3 h-0.5 bg-blue-500 mr-1"></span> Delivery routes
                                    <span class="inline-block w-3 h-0.5 border-dashed border-gray-400 mr-1 ml-3"></span> Travel between jobs
                                </p>
                            </div>
                        </div>
                        
                        <div class="mt-6 flex justify-end">
                            <button onclick="closeWhyThisDriver()" class="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-lg transition-colors">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Initialize map after a short delay to ensure DOM is ready
            setTimeout(async () => {
                try {
                    await initializeRouteMap(routeNumber, jobs, startPostcode, endPostcode, details.hasCarryover);
                } catch (error) {
                    console.error('Error initializing map:', error);
                    const mapDiv = document.getElementById('why-driver-map');
                    if (mapDiv) {
                        mapDiv.innerHTML = '<p class="text-red-400 p-4">Error loading map. Please try again.</p>';
                    }
                }
            }, 100);
        }
        
        // Initialize the route map
        async function initializeRouteMap(routeNumber, jobs, startPostcode, endPostcode, hasCarryover) {
            if (!window.google || !window.google.maps) {
                throw new Error('Google Maps not loaded');
            }
            
            const mapDiv = document.getElementById('why-driver-map');
            if (!mapDiv) return;
            
            // Initialize map centered on UK (light theme for better contrast)
            const map = new google.maps.Map(mapDiv, {
                zoom: 8,
                center: { lat: 52.5, lng: -1.5 }, // Center of UK
                mapTypeId: google.maps.MapTypeId.ROADMAP,
                // No custom styles - use default light theme for better contrast
                styles: []
            });
            
            const bounds = new google.maps.LatLngBounds();
            const markers = [];
            const polylines = [];
            
            try {
                // Geocode starting point (carryover or home)
                const startLocation = await geocodePostcode(startPostcode);
                bounds.extend(startLocation);
                
                // Add marker for starting point
                const startMarker = new google.maps.Marker({
                    position: startLocation,
                    map: map,
                    title: hasCarryover ? `Carryover: ${startPostcode}` : `Driver Home: ${startPostcode}`,
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        scale: 8,
                        fillColor: hasCarryover ? '#FF6B6B' : '#4ECDC4',
                        fillOpacity: 1,
                        strokeColor: '#FFF',
                        strokeWeight: 2
                    },
                    label: {
                        text: hasCarryover ? 'C' : 'H',
                        color: '#FFF',
                        fontSize: '10px',
                        fontWeight: 'bold'
                    }
                });
                markers.push(startMarker);
                
                let previousLocation = startLocation;
                
                // Process each job
                for (let i = 0; i < jobs.length; i++) {
                    const job = jobs[i];
                    const collectionPostcode = job.parsedData?.collection_address;
                    const deliveryPostcode = job.parsedData?.postcode_delivery;
                    
                    if (!collectionPostcode || !deliveryPostcode) continue;
                    
                    try {
                        // Geocode collection point
                        const collectionLocation = await geocodePostcode(collectionPostcode);
                        bounds.extend(collectionLocation);
                        
                        // Draw straight dotted line from previous location to collection (travel - as the crow flies)
                        // Always use straight line for travel segments
                        const travelLine = new google.maps.Polyline({
                            path: [previousLocation, collectionLocation],
                            geodesic: true,
                            strokeColor: '#9CA3AF',
                            strokeOpacity: 0.6,
                            strokeWeight: 2,
                            icons: [{
                                icon: {
                                    path: 'M 0,-1 0,1',
                                    strokeOpacity: 1,
                                    scale: 3
                                },
                                offset: '0',
                                repeat: '10px'
                            }]
                        });
                        travelLine.setMap(map);
                        polylines.push(travelLine);
                        
                        // Add marker for collection
                        const collectionMarker = new google.maps.Marker({
                            position: collectionLocation,
                            map: map,
                            title: `Collection ${String.fromCharCode(65 + i)}: ${collectionPostcode}`,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 7,
                                fillColor: '#10B981',
                                fillOpacity: 1,
                                strokeColor: '#FFF',
                                strokeWeight: 2
                            },
                            label: {
                                text: String.fromCharCode(65 + i),
                                color: '#FFF',
                                fontSize: '10px',
                                fontWeight: 'bold'
                            }
                        });
                        markers.push(collectionMarker);
                        
                        // Geocode delivery point
                        const deliveryLocation = await geocodePostcode(deliveryPostcode);
                        bounds.extend(deliveryLocation);
                        
                        // Draw blue solid line from collection to delivery (delivery route)
                        try {
                            const deliveryPath = await getDirections(collectionPostcode, deliveryPostcode);
                            const deliveryLine = new google.maps.Polyline({
                                path: deliveryPath,
                                geodesic: true,
                                strokeColor: '#3B82F6',
                                strokeOpacity: 0.8,
                                strokeWeight: 4
                            });
                            deliveryLine.setMap(map);
                            polylines.push(deliveryLine);
                        } catch (error) {
                            console.warn('Could not get directions for delivery:', error);
                            // Draw straight line as fallback
                            const deliveryLine = new google.maps.Polyline({
                                path: [collectionLocation, deliveryLocation],
                                geodesic: true,
                                strokeColor: '#3B82F6',
                                strokeOpacity: 0.8,
                                strokeWeight: 4
                            });
                            deliveryLine.setMap(map);
                            polylines.push(deliveryLine);
                        }
                        
                        // Add marker for delivery
                        const deliveryMarker = new google.maps.Marker({
                            position: deliveryLocation,
                            map: map,
                            title: `Delivery ${String.fromCharCode(65 + i)}: ${deliveryPostcode}`,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 7,
                                fillColor: '#EF4444',
                                fillOpacity: 1,
                                strokeColor: '#FFF',
                                strokeWeight: 2
                            },
                            label: {
                                text: String.fromCharCode(65 + i),
                                color: '#FFF',
                                fontSize: '10px',
                                fontWeight: 'bold'
                            }
                        });
                        markers.push(deliveryMarker);
                        
                        previousLocation = deliveryLocation;
                        
                    } catch (error) {
                        console.error(`Error processing job ${i + 1}:`, error);
                    }
                }
                
                // Draw straight dotted line from last delivery back to driver home (as the crow flies)
                if (jobs.length > 0 && endPostcode !== startPostcode) {
                    try {
                        const endLocation = await geocodePostcode(endPostcode);
                        bounds.extend(endLocation);
                        
                        // Always use straight line for return journey
                        const returnLine = new google.maps.Polyline({
                            path: [previousLocation, endLocation],
                            geodesic: true,
                            strokeColor: '#9CA3AF',
                            strokeOpacity: 0.6,
                            strokeWeight: 2,
                            icons: [{
                                icon: {
                                    path: 'M 0,-1 0,1',
                                    strokeOpacity: 1,
                                    scale: 3
                                },
                                offset: '0',
                                repeat: '10px'
                            }]
                        });
                        returnLine.setMap(map);
                        polylines.push(returnLine);
                        
                        // Add marker for driver home (if different from start)
                        const homeMarker = new google.maps.Marker({
                            position: endLocation,
                            map: map,
                            title: `Driver Home: ${endPostcode}`,
                            icon: {
                                path: google.maps.SymbolPath.CIRCLE,
                                scale: 8,
                                fillColor: '#4ECDC4',
                                fillOpacity: 1,
                                strokeColor: '#FFF',
                                strokeWeight: 2
                            },
                            label: {
                                text: 'H',
                                color: '#FFF',
                                fontSize: '10px',
                                fontWeight: 'bold'
                            }
                        });
                        markers.push(homeMarker);
                    } catch (error) {
                        console.error('Error adding return route:', error);
                    }
                }
                
                // Fit map to show all markers
                if (bounds.getNorthEast().equals(bounds.getSouthWest())) {
                    // If all points are the same, zoom to that point
                    map.setCenter(bounds.getCenter());
                    map.setZoom(12);
                } else {
                    map.fitBounds(bounds);
                    // Add padding
                    const padding = 50;
                    map.fitBounds(bounds, padding);
                }
                
            } catch (error) {
                console.error('Error initializing map:', error);
                mapDiv.innerHTML = '<p class="text-red-400 p-4">Error loading map. Please try again.</p>';
            }
        }
        
        function closeWhyThisDriver() {
            const overlay = document.getElementById('why-driver-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Initialize the page when it loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Optimisation page loaded');
            
            // Check authentication first
            if (!(await checkAuthentication())) {
                return;
            }
            
            // Handle Asana OAuth callback
            handleAsanaCallback();
            
            // Hide demo routes by default
            hideDemoRoutes();
            
            // Wait for Firebase to be ready, then load routes
            try {
                await waitForFirebase();
                
                // Load office logo after Firebase is ready
                try {
                    if (currentUser?.officeId) {
                        await loadOfficeLogo(currentUser.officeId);
                    }
                } catch (error) {
                    console.error('Error loading office logo on init:', error);
                }
                
                await displayRoutesFromFirebase();
                console.log('Initial routes loaded');
                
                // Initialize notification system
                await initializeNotifications();
                
            } catch (error) {
                console.error('Error initializing routes:', error);
                // Show a message to user
                const noRoutesMessage = document.getElementById('no-routes-message');
                if (noRoutesMessage) {
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2">Loading routes...</p>
                        <p class="text-sm">Click "Load Routes" if routes don't appear automatically</p>
                    `;
                }
            }
        });

        // Profile dropdown functions
        function toggleProfileDropdown() {
            const dropdown = document.getElementById('profileDropdown');
            dropdown.classList.toggle('hidden');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('profileDropdown');
            const profileButton = event.target.closest('button[onclick="toggleProfileDropdown()"]');
            
            if (!profileButton && !dropdown.contains(event.target)) {
                dropdown.classList.add('hidden');
            }
        });

        function showChangePassword() {
            document.getElementById('changePasswordModal').classList.remove('hidden');
            document.getElementById('profileDropdown').classList.add('hidden');
        }

        // Settings functions
        function showSettings() {
            const modal = document.getElementById('settingsModal');
            const dropdown = document.getElementById('profileDropdown');
            dropdown.classList.add('hidden');
            modal.classList.remove('hidden');
            
            // Load current setting value
            const useAsanaApi = window.sotoSettings?.getUseAsanaApiForRoutes() || false;
            const toggle = document.getElementById('useAsanaApiToggle');
            if (toggle) {
                toggle.checked = useAsanaApi;
            }
        }

        function hideSettings() {
            document.getElementById('settingsModal').classList.add('hidden');
        }

        function handleAsanaApiToggle(checked) {
            if (window.sotoSettings) {
                window.sotoSettings.setUseAsanaApiForRoutes(checked);
                console.log('Asana API for routes setting updated:', checked);
            }
        }

        function hideChangePassword() {
            document.getElementById('changePasswordModal').classList.add('hidden');
            document.getElementById('changePasswordForm').reset();
        }

        // View usage calendar
        function viewUsage() {
            const officeId = getCurrentOfficeId();
            if (!officeId) {
                console.warn('[OPTIMISATION] Unable to determine office for usage view.');
                return;
            }
            window.location.href = `/pages/office-calendar.html?officeId=${officeId}`;
        }

        // Handle password change
        async function handleChangePassword(event) {
            event.preventDefault();
            
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            
            if (newPassword !== confirmPassword) {
                alert('New passwords do not match');
                return;
            }
            
            try {
                const user = window.auth.currentUser;
                if (!user) {
                    alert('No user logged in');
                    return;
                }
                
                // Re-authenticate user with current password
                const credential = window.EmailAuthProvider.credential(user.email, currentPassword);
                await window.reauthenticateWithCredential(user, credential);
                
                // Update password
                await window.updatePassword(user, newPassword);
                
                alert('Password changed successfully!');
                hideChangePassword();
                
            } catch (error) {
                console.error('Error changing password:', error);
                
                if (error.code === 'auth/wrong-password') {
                    alert('Current password is incorrect');
                } else if (error.code === 'auth/weak-password') {
                    alert('New password is too weak. Please choose a stronger password.');
                } else if (error.code === 'auth/requires-recent-login') {
                    alert('Please log out and log back in, then try changing your password again.');
                } else {
                    alert('Error changing password: ' + error.message);
                }
            }
        }

        // Make functions globally available
        window.toggleProfileDropdown = toggleProfileDropdown;
        window.showChangePassword = showChangePassword;
        window.hideChangePassword = hideChangePassword;
        window.viewUsage = viewUsage;
        window.handleChangePassword = handleChangePassword;

        // Add event listener for password form
        document.addEventListener('DOMContentLoaded', function() {
            const changePasswordForm = document.getElementById('changePasswordForm');
            if (changePasswordForm) {
                changePasswordForm.addEventListener('submit', handleChangePassword);
            }
        });
    </script>

    <!-- Change Password Modal -->
    <div id="changePasswordModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Change Password</h3>
                <button onclick="hideChangePassword()" class="text-gray-400 hover:text-white">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            
            <form id="changePasswordForm" class="space-y-4">
                <div>
                    <label for="currentPassword" class="block text-sm font-medium text-gray-300 mb-2">Current Password</label>
                    <input 
                        type="password" 
                        id="currentPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Enter current password"
                    >
                </div>
                
                <div>
                    <label for="newPassword" class="block text-sm font-medium text-gray-300 mb-2">New Password</label>
                    <input 
                        type="password" 
                        id="newPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Enter new password"
                    >
                </div>
                
                <div>
                    <label for="confirmPassword" class="block text-sm font-medium text-gray-300 mb-2">Confirm New Password</label>
                    <input 
                        type="password" 
                        id="confirmPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Confirm new password"
                    >
                </div>

                <button 
                    type="submit"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors font-medium"
                >
                    Change Password
                </button>
            </form>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Settings</h3>
                <button onclick="hideSettings()" class="text-gray-400 hover:text-white">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            
            <div class="space-y-4">
                <div class="flex items-center justify-between py-3 border-b border-[#283039]">
                    <div class="flex-1">
                        <label for="useAsanaApiToggle" class="block text-sm font-medium text-white mb-1">
                            Use Asana API for route input
                        </label>
                        <p class="text-xs text-gray-400">When enabled, routes button will redirect to automatic routes page</p>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input 
                            type="checkbox" 
                            id="useAsanaApiToggle" 
                            class="sr-only peer"
                            onchange="handleAsanaApiToggle(this.checked)"
                        >
                        <div class="w-11 h-6 bg-[#283039] peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-blue-500 rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
            </div>
            
            <div class="mt-6 flex justify-end">
                <button 
                    onclick="hideSettings()"
                    class="px-4 py-2 bg-[#283039] hover:bg-[#3a444e] text-white rounded-lg transition-colors font-medium"
                >
                    Close
                </button>
            </div>
        </div>
    </div>
</body>
</html>
