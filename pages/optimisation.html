<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <link crossorigin="" href="https://fonts.gstatic.com/" rel="preconnect"/>
    <link as="style" href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900" onload="this.rel='stylesheet'" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/logos/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/logos/favicon-16.png">
    <link rel="icon" type="image/svg+xml" href="/assets/logos/favicon.svg">
    <link rel="icon" type="image/x-icon" href="/assets/logos/favicon.ico">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/logos/apple-touch-icon.png">
    <link rel="stylesheet" href="/assets/css/responsive-nav.css">
<title>SOTO Routes - Logistics Planning</title>
    <link href="data:image/x-icon;base64," rel="icon" type="image/x-icon"/>
    <script src="/assets/js/tailwind-runtime.js"></script>
    <script src="/js/mobile-nav.js"></script>
    <script src="/js/session-manager.js"></script>
    <script>
        tailwind.config = {
            plugins: {
                forms: {},
                containerQueries: {}
            }
        }
    </script>
    <!-- Google Maps API -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDTbiSXo9tg1Tx8SlZCZKsR_R0zIQ4N1VA&libraries=geometry&callback=initGoogleMaps"></script>
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, getDoc, doc, query, orderBy, limit, where, setDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, signInWithEmailAndPassword, createUserWithEmailAndPassword, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCkXzYFC1jQcA6yw6qY1Ao3luEYU4Rd0yA",
            authDomain: "soto-routes.firebaseapp.com",
            projectId: "soto-routes",
            storageBucket: "soto-routes.firebasestorage.app",
            messagingSenderId: "440989695549",
            appId: "1:440989695549:web:0bce8b92a46f7f79953454",
            measurementId: "G-4E3G40QQ9L"
        };
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
        
        // Make Firebase available globally
        window.firebaseApp = app;
        window.firebase = { functions: functions, httpsCallable: httpsCallable };
        window.firestore = db;
        window.auth = auth;
        window.firebaseCollection = collection;
        window.firebaseAddDoc = addDoc;
        window.firebaseGetDocs = getDocs;
        window.firebaseGetDoc = getDoc;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseUpdateDoc = updateDoc;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseWhere = where;
        window.signInWithEmailAndPassword = signInWithEmailAndPassword;
        window.createUserWithEmailAndPassword = createUserWithEmailAndPassword;
        window.signOut = signOut;
        window.onAuthStateChanged = onAuthStateChanged;
        
        console.log('Firebase initialized successfully!');
        
        // Hide loading overlay after Firebase is ready and page content loads
        window.addEventListener('load', () => {
            setTimeout(() => {
                const loadingOverlay = document.getElementById('loading-overlay');
                if (loadingOverlay) {
                    loadingOverlay.style.opacity = '0';
                    loadingOverlay.style.transition = 'opacity 0.3s ease-out';
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 300);
                }
            }, 500);
        });
    </script>
    <style type="text/tailwindcss">
        :root {
            --primary-color: #0d7ff2;
            --success-color: #22c55e;
        }
    </style>
</head>
<body class="bg-[#111418] text-white" style='font-family: Inter, "Noto Sans", sans-serif;'>
    <div class="relative flex h-auto min-h-screen w-full flex-col dark group/design-root overflow-x-hidden">
        <div class="flex h-full grow flex-col">
        <header class="relative flex items-center justify-between whitespace-nowrap border-b border-solid border-b-[#283039] px-6 py-3" data-soto-nav>
            <div class="flex items-center gap-4">
                <div class="size-8 text-[var(--primary-color)]">
                    <svg fill="none" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
                        <path d="M13.8261 17.4264C16.7203 18.1174 20.2244 18.5217 24 18.5217C27.7756 18.5217 31.2797 18.1174 34.1739 17.4264C36.9144 16.7722 39.9967 15.2331 41.3563 14.1648L24.8486 40.6391C24.4571 41.267 23.5429 41.267 23.1514 40.6391L6.64374 14.1648C8.00331 15.2331 11.0856 16.7722 13.8261 17.4264Z" fill="currentColor"></path>
                        <path clip-rule="evenodd" d="M39.998 12.236C39.9944 12.2537 39.9875 12.2845 39.9748 12.3294C39.9436 12.4399 39.8949 12.5741 39.8346 12.7175C39.8168 12.7597 39.7989 12.8007 39.7813 12.8398C38.5103 13.7113 35.9788 14.9393 33.7095 15.4811C30.9875 16.131 27.6413 16.5217 24 16.5217C20.3587 16.5217 17.0125 16.131 14.2905 15.4811C12.0012 14.9346 9.44505 13.6897 8.18538 12.8168C8.17384 12.7925 8.16216 12.767 8.15052 12.7408C8.09919 12.6249 8.05721 12.5114 8.02977 12.411C8.00356 12.3152 8.00039 12.2667 8.00004 12.2612C8.00004 12.261 8 12.2607 8.00004 12.2612C8.00004 12.2359 8.0104 11.9233 8.68485 11.3686C9.34546 10.8254 10.4222 10.2469 11.9291 9.72276C14.9242 8.68098 19.1919 8 24 8C28.8081 8 33.0758 8.68098 36.0709 9.72276C37.5778 10.2469 38.6545 10.8254 39.3151 11.3686C39.9006 11.8501 39.9857 12.1489 39.998 12.236ZM4.95178 15.2312L21.4543 41.6973C22.6288 43.5809 25.3712 43.5809 26.5457 41.6973L43.0534 15.223C43.0709 15.1948 43.0878 15.1662 43.104 15.1371L41.3563 14.1648C43.104 15.1371 43.1038 15.1374 43.104 15.1371L43.1051 15.135L43.1065 15.1325L43.1101 15.1261L43.1199 15.1082C43.1276 15.094 43.1377 15.0754 43.1497 15.0527C43.1738 15.0075 43.2062 14.9455 43.244 14.8701C43.319 14.7208 43.4196 14.511 43.5217 14.2683C43.6901 13.8679 44 13.0689 44 12.2609C44 10.5573 43.003 9.22254 41.8558 8.2791C40.6947 7.32427 39.1354 6.55361 37.385 5.94477C33.8654 4.72057 29.133 4 24 4C18.867 4 14.1346 4.72057 10.615 5.94478C8.86463 6.55361 7.30529 7.32428 6.14419 8.27911C4.99695 9.22255 3.99999 10.5573 3.99999 12.2609C3.99999 13.1275 4.29264 13.9078 4.49321 14.3607C4.60375 14.6102 4.71348 14.8196 4.79687 14.9689C4.83898 15.0444 4.87547 15.1065 4.9035 15.1529C4.91754 15.1762 4.92954 15.1957 4.93916 15.2111L4.94662 15.223L4.95178 15.2312ZM35.9868 18.996L24 38.22L12.0131 18.996C12.4661 19.1391 12.9179 19.2658 13.3617 19.3718C16.4281 20.1039 20.0901 20.5217 24 20.5217C27.9099 20.5217 31.5719 20.1039 34.6383 19.3718C35.082 19.2658 35.5339 19.1391 35.9868 18.996Z" fill="currentColor" fill-rule="evenodd"></path>
                    </svg>
                </div>
                <h2 class="text-xl font-bold">SOTO Routes</h2>
            </div>
            <nav class="flex flex-1 justify-center gap-2" data-soto-nav-links>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/soto-lp.html">Routes</a>
                <a class="bg-[#283039] text-white text-sm font-medium rounded-md px-4 py-2" href="#">Optimisation</a>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/drivers.html">Drivers</a>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/availability.html">Availability</a>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/expenses.html">Expenses</a>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/wait-times.html">Wait Times</a>
                <a class="text-sm font-medium rounded-md px-4 py-2 hover:bg-[#283039] transition-colors" href="/pages/messages.html">Messages</a>
            </nav>
            <div class="flex items-center gap-4">
                <button type="button" class="mobile-nav-toggle" data-soto-nav-toggle aria-label="Toggle navigation" aria-expanded="false">
                    <span class="material-symbols-outlined text-xl">menu</span>
                </button>
                <div class="relative">
                    <button class="flex items-center justify-center rounded-full h-10 w-10 bg-[#283039] hover:bg-[#3a444e] transition-colors relative" onclick="showNotifications()">
                        <span class="material-symbols-outlined text-xl">notifications</span>
                        <!-- Notification Badge -->
                        <span class="notification-badge absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full h-5 w-5 flex items-center justify-center font-bold hidden">0</span>
                    </button>
                    <!-- Notifications Dropdown -->
                    <div id="notificationDropdown" class="hidden absolute right-0 mt-2 w-80 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50 max-h-96 overflow-y-auto">
                        <div class="px-4 py-3 border-b border-[#283039]">
                            <h3 class="text-white font-semibold text-sm">Notifications</h3>
                        </div>
                        <div id="notificationsList" class="max-h-64 overflow-y-auto">
                            <!-- Notifications will be loaded here -->
                        </div>
                    </div>
                </div>
                <div class="relative">
                    <button onclick="toggleProfileDropdown()" class="flex items-center justify-center rounded-full size-10 bg-black overflow-hidden hover:ring-2 hover:ring-blue-500 transition-all cursor-pointer">
                        <img id="officeLogoImg" src="/assets/logos/favicon.svg" alt="Office Logo" class="w-full h-full object-cover" onerror="this.src='/assets/logos/favicon.svg'">
                    </button>
                    <!-- Profile Dropdown -->
                    <div id="profileDropdown" class="hidden absolute right-0 mt-2 w-48 bg-[#1a1f24] border border-[#283039] rounded-lg shadow-lg z-50">
                        <button onclick="showChangePassword()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors rounded-t-lg">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">lock</span>
                            Change Password
                        </button>
                        <button onclick="viewUsage()" class="block w-full text-left px-4 py-2 text-sm text-white hover:bg-[#283039] transition-colors">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">calendar_month</span>
                            View Usage
                        </button>
                        <button onclick="logout()" class="block w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-[#283039] transition-colors rounded-b-lg">
                            <span class="material-symbols-outlined inline-block align-middle text-base mr-2">logout</span>
                            Logout
                        </button>
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Loading Overlay -->
        <div id="loading-overlay" class="fixed inset-0 bg-[#0f1419] bg-opacity-95 flex items-center justify-center z-50">
            <div class="text-center">
                <div class="relative w-16 h-16 mx-auto mb-4">
                    <div class="absolute inset-0 border-4 border-gray-700 rounded-full"></div>
                    <div class="absolute inset-0 border-4 border-blue-500 rounded-full border-t-transparent animate-spin"></div>
                </div>
                <p class="text-white text-lg font-semibold">Loading Optimisation...</p>
                <p class="text-gray-400 text-sm mt-1">Please wait</p>
            </div>
        </div>
        
        <main class="flex-1 px-6 py-4">
            <div class="max-w-6xl mx-auto">
                <div class="flex justify-between items-center mb-4">
                    <h1 class="text-2xl font-bold tracking-tight">Optimisation</h1>
                    <div class="flex items-center gap-3">
                        <button onclick="loadLastAssignedDrivers()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-bold">
                            Load Last Assigned Drivers
                        </button>
                        <button onclick="showOptimiseSettings()" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-bold">
                            <span class="truncate">Optimise</span>
                        </button>
                    </div>
                </div>
                
                <!-- Routes Requiring Authorization Section -->
                <div id="authorization-routes-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-yellow-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">warning</span>
                        Routes Requiring Authorization
                    </h2>
                    <p class="text-sm text-gray-400 mb-4">These routes require driving to a train station as no direct transit is available.</p>
                    <div id="authorization-routes-container" class="grid grid-cols-1 gap-4">
                        <!-- Routes requiring authorization will be displayed here -->
                    </div>
                </div>

                <!-- Jobless Drivers Section -->
                <div id="jobless-drivers-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-red-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">person_off</span>
                        Jobless Drivers
                    </h2>
                    <div id="jobless-drivers-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <!-- Unassigned drivers will be displayed here -->
                    </div>
                </div>

                <!-- Driverless Routes Section -->
                <div id="driverless-routes-section" class="mb-6 hidden">
                    <h2 class="text-lg font-semibold text-orange-400 mb-3 flex items-center gap-2">
                        <span class="material-symbols-outlined">route</span>
                        Driverless Routes
                    </h2>
                    <div id="driverless-routes-container" class="grid grid-cols-1 lg:grid-cols-2 gap-4">
                        <!-- Unassigned routes will be displayed here -->
                    </div>
                </div>

                <!-- Assigned Routes Section -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4" id="routes-container">
                        <!-- Routes will be dynamically loaded here -->
                        <div id="no-routes-message" class="col-span-full text-center py-12 text-gray-400">
                            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
                            <p class="text-lg mb-2">Loading routes...</p>
                            <p class="text-sm">Please wait while we load your saved routes</p>
                        </div>
                        
                        <!-- Demo Route 1 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-1" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-1-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-1-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">M1 4AN</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-1-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-1-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-1-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-1-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>

                        <!-- Demo Route 2 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-2" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-2-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-2-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">B775JA</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-2-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-2-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-2-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-2-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>

                        <!-- Demo Route 3 (hidden by default) -->
                        <div class="flex flex-col gap-4 rounded-lg border border-[#283039] bg-[#1a1f24] p-6" id="demo-route-3" style="display: none;">
                            <div class="grid grid-cols-5 gap-6 text-sm">
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver</label>
                                    <p class="text-white font-semibold" id="route-3-driver">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Driver's Location</label>
                                    <p class="text-white font-semibold" id="route-3-driver-location">-</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Collection A</label>
                                    <p class="text-green-400 font-semibold">B797RU</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium"># of Jobs</label>
                                    <p class="text-white font-semibold">2</p>
                                </div>
                                <div class="flex flex-col gap-1.5">
                                    <label class="text-gray-400 font-medium">Delivery X</label>
                                    <p class="text-red-400 font-semibold">LS1 4DY</p>
                                </div>
                            </div>
                            <div class="mt-4">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance to Collection A</label>
                                    <p class="text-white font-semibold text-sm" id="route-3-distance-to-collection">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-3-progress-to-collection" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                            <div class="mt-2">
                                <div class="flex justify-between items-end mb-1">
                                    <label class="text-gray-400 font-medium text-sm">Distance Home</label>
                                    <p class="text-white font-semibold text-sm" id="route-3-distance">-</p>
                                </div>
                                <div class="w-full bg-[#283039] rounded-full h-2.5 relative overflow-hidden">
                                    <div class="bg-gray-600 h-full rounded-full" id="route-3-progress" style="width: 0%;"></div>
                                </div>
                                <div class="flex justify-between text-xs text-gray-400 mt-1">
                                    <span>0 mi</span>
                                    <span>100 mi</span>
                                </div>
                            </div>
                        </div>
            </div>
        </main>
        </div>
    </div>

    <script>
        // Check authentication first
        async function checkAuthentication() {
            try {
                const session = await window.sotoSession.bootstrap(['office', 'admin']);
                if (!session) {
                window.location.href = '/pages/soto-routes-login.html';
                return false;
            }

                currentSession = session;
                currentUserId = session.uid;

                try {
                    const userRef = window.firebaseDoc(window.firestore, 'users', session.uid);
                    const userDoc = await window.firebaseGetDoc(userRef);
                    if (userDoc.exists()) {
                        currentUser = { uid: session.uid, ...session, ...userDoc.data() };
                    } else {
                        currentUser = { uid: session.uid, ...session };
                    }
                } catch (userError) {
                    console.warn('Unable to load user profile, using session only:', userError);
                    currentUser = { uid: session.uid, ...session };
                }

            return true;
            } catch (error) {
                console.error('Authentication failed:', error);
                window.location.href = '/pages/soto-routes-login.html';
                return false;
            }
        }

        // CloudKit functionality removed
        let savedRoutes = [];
        let currentSession = null;
        let currentUser = null;
        let currentUserId = 'default_user'; // Placeholder for user authentication
        const getCurrentOfficeId = () => currentUser?.officeId || currentSession?.officeId || null;

        // Driver data loaded from Firebase
        let drivers = [];

        // Navigation functions
        // Calculate working hours between two dates (8am-5pm Mon-Fri only)
        function calculateWorkingHours(startDate, endDate) {
            let currentDate = new Date(startDate);
            let workingHours = 0;
            
            while (currentDate < endDate) {
                const dayOfWeek = currentDate.getDay();
                const hour = currentDate.getHours();
                
                if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                    if (hour >= 8 && hour < 17) {
                        workingHours += 1;
                    }
                }
                
                currentDate.setHours(currentDate.getHours() + 1);
            }
            
            return workingHours;
        }

        // Check for expenses over 24 working hours old
        async function checkOldExpenses(officeId) {
            try {
                const batchesQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'expenseBatches'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const batchesSnapshot = await window.firebaseGetDocs(batchesQuery);
                const now = new Date();
                let oldExpenseCount = 0;
                
                batchesSnapshot.docs.forEach(doc => {
                    const batch = doc.data();
                    if (batch.status === 'pending' || batch.status === 'validated') {
                        const submittedAt = batch.submittedAt?.toDate ? batch.submittedAt.toDate() : new Date(batch.submittedAt);
                        if (submittedAt) {
                            const workingHours = calculateWorkingHours(submittedAt, now);
                            if (workingHours > 24) {
                                oldExpenseCount++;
                            }
                        }
                    }
                });
                
                return oldExpenseCount;
            } catch (error) {
                console.error('Error checking old expenses:', error);
                return 0;
            }
        }
        
        // Update notification count across all office pages
        async function updateNotificationCount() {
            try {
                console.log('[OPTIMISATION] updateNotificationCount called');
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.log('[OPTIMISATION] No office context available');
                    return;
                }
                console.log('[OPTIMISATION] Office ID:', officeId);
                
                // Get all availability change notifications for this office that haven't been seen
                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);
                console.log('[OPTIMISATION] Total notifications found:', notificationsSnapshot.docs.length);
                
                // Count unique drivers with unread changes
                const driverChanges = {};
                // Filter to only unseen notifications and convert dates
                const allNotifications = notificationsSnapshot.docs
                    .map(doc => {
                        const data = doc.data();
                        return {
                            id: doc.id,
                            ...data,
                            createdAt: data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt)
                        };
                    })
                    .filter(notification => notification.seen !== true) // Only include unseen notifications
                    .sort((a, b) => b.createdAt - a.createdAt); // Sort by date (most recent first)
                
                // Group by driver and only count the most recent batch (within 1 hour of latest)
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    
                    if (!driverChanges[driverId]) {
                        // This is the first (most recent) unseen notification for this driver
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName,
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [notification],
                            latestDate: notification.createdAt,
                            earliestDate: notification.createdAt
                        };
                        
                        // Count this first notification
                        if (notification.changeType === 'unavailable') {
                            driverChanges[driverId].daysOff = 1;
                        } else {
                            driverChanges[driverId].daysAvailable = 1;
                        }
                    } else {
                        // Check if this notification is within 1 hour of the latest (most recent) one
                        // This ensures we only count the most recent batch, not old unseen notifications
                        const timeDiffFromLatest = Math.abs(driverChanges[driverId].latestDate - notification.createdAt);
                        const oneHour = 60 * 60 * 1000; // 1 hour in milliseconds
                        
                        if (timeDiffFromLatest <= oneHour) {
                            // Same batch - add to counts
                            if (notification.changeType === 'unavailable') {
                                driverChanges[driverId].daysOff++;
                            } else {
                                driverChanges[driverId].daysAvailable++;
                            }
                            driverChanges[driverId].notifications.push(notification);
                            // Update earliest date if this is older
                            if (notification.createdAt < driverChanges[driverId].earliestDate) {
                                driverChanges[driverId].earliestDate = notification.createdAt;
                            }
                            // latestDate stays as the most recent (first one we found)
                        }
                        // If outside the batch window (more than 1 hour from latest), ignore it
                    }
                });
                
                // Count total number of drivers with changes
                const availabilityCount = Object.keys(driverChanges).length;
                console.log('[OPTIMISATION] Drivers with changes:', availabilityCount);
                
                // Check for old expenses (>24 working hours)
                const oldExpenseCount = await checkOldExpenses(officeId);
                console.log('[OPTIMISATION] Old expenses count:', oldExpenseCount);
                
                // Total notification count (availability changes + old expenses)
                const unreadCount = availabilityCount + (oldExpenseCount > 0 ? 1 : 0);
                console.log('[OPTIMISATION] Total unread count:', unreadCount);
                
                // Update notification badge on all pages
                updateNotificationBadge(unreadCount);
                console.log('[OPTIMISATION] Badge updated');
                
            } catch (error) {
                console.error('[OPTIMISATION] Error updating notification count:', error);
            }
        }

        // Update notification badge display
        function updateNotificationBadge(count) {
            console.log('[OPTIMISATION] updateNotificationBadge called with count:', count);
            const badgeElements = document.querySelectorAll('.notification-badge');
            console.log('[OPTIMISATION] Found badge elements:', badgeElements.length);
            badgeElements.forEach((badge, index) => {
                console.log(`[OPTIMISATION] Badge ${index}:`, badge);
                if (count > 0) {
                    badge.textContent = count > 99 ? '99+' : count.toString();
                    badge.classList.remove('hidden');
                    console.log(`[OPTIMISATION] Badge ${index} shown with count:`, badge.textContent);
                } else {
                    badge.classList.add('hidden');
                    console.log(`[OPTIMISATION] Badge ${index} hidden`);
                }
            });
        }

        // Show notifications dropdown
        async function showNotifications() {
            const dropdown = document.getElementById('notificationDropdown');
            if (!dropdown) return;
            
            // Toggle dropdown visibility
            dropdown.classList.toggle('hidden');
            
            if (!dropdown.classList.contains('hidden')) {
                // Load and display notifications
                await loadNotifications();
            }
        }

        // Load notifications for dropdown (aggregated by driver)
        async function loadNotifications() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) return;
                
                // Get all unseen availability change notifications for this office
                const notificationsQuery = window.firebaseQuery(
                    window.firebaseCollection(window.firestore, 'availabilityNotifications'),
                    window.firebaseWhere('officeId', '==', officeId)
                );
                
                const notificationsSnapshot = await window.firebaseGetDocs(notificationsQuery);
                const notificationsList = document.getElementById('notificationsList');
                
                const oldExpenseCount = await checkOldExpenses(officeId);
                
                // Aggregate notifications by driver
                const driverChanges = {};
                const allNotifications = notificationsSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                
                allNotifications.forEach(notification => {
                    const driverId = notification.driverId;
                    if (!driverChanges[driverId]) {
                        driverChanges[driverId] = {
                            driverId: driverId,
                            driverName: notification.driverName,
                            daysOff: 0,
                            daysAvailable: 0,
                            notifications: [],
                            latestDate: null
                        };
                    }
                    
                    if (notification.changeType === 'unavailable') {
                        driverChanges[driverId].daysOff++;
                    } else {
                        driverChanges[driverId].daysAvailable++;
                    }
                    
                    driverChanges[driverId].notifications.push(notification);
                    
                    // Track latest notification date
                    const notifDate = notification.createdAt?.toDate ? notification.createdAt.toDate() : new Date(notification.createdAt);
                    if (!driverChanges[driverId].latestDate || notifDate > driverChanges[driverId].latestDate) {
                        driverChanges[driverId].latestDate = notifDate;
                    }
                });
                
                // Sort by latest date (most recent first)
                const sortedDrivers = Object.values(driverChanges).sort((a, b) => b.latestDate - a.latestDate);
                
                // Clear existing notifications
                notificationsList.innerHTML = '';
                
                if (oldExpenseCount > 0) {
                    const expenseNotification = createOldExpenseNotificationElement(oldExpenseCount);
                    notificationsList.appendChild(expenseNotification);
                }
                
                sortedDrivers.forEach(driverData => {
                    const notificationElement = createAggregatedNotificationElement(driverData);
                    notificationsList.appendChild(notificationElement);
                });
                
                if (oldExpenseCount === 0 && sortedDrivers.length === 0) {
                    notificationsList.innerHTML = `
                        <div class="px-4 py-3 text-gray-400 text-sm text-center">
                            No notifications yet
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('Error loading notifications:', error);
            }
        }

        // Create aggregated notification element for dropdown
        function createOldExpenseNotificationElement(count) {
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => {
                document.getElementById('notificationDropdown').classList.add('hidden');
                window.location.href = '/pages/expenses.html';
            };
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">There are ${count} ${count === 1 ? 'expense' : 'expenses'} that are 24 working hours old</div>
                        <div class="text-[#9cabba] text-xs mt-1">Click to view expenses</div>
                    </div>
                    <div class="w-2 h-2 bg-red-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }
        
        function createAggregatedNotificationElement(driverData) {
            const element = document.createElement('div');
            element.className = 'px-4 py-3 border-b border-[#283039] cursor-pointer hover:bg-[#283039] transition-colors bg-[#283039]';
            element.onclick = () => handleAggregatedNotificationClick(driverData);
            
            // Build message based on changes
            let message = '';
            if (driverData.daysOff > 0 && driverData.daysAvailable > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off and changed ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'} back to available`;
            } else if (driverData.daysOff > 0) {
                message = `${driverData.driverName} has booked ${driverData.daysOff} ${driverData.daysOff === 1 ? 'day' : 'days'} off`;
            } else if (driverData.daysAvailable > 0) {
                message = `${driverData.driverName} has changed ${driverData.daysAvailable} ${driverData.daysAvailable === 1 ? 'day' : 'days'} back to available`;
            }
            
            const timeAgo = getTimeAgo(driverData.latestDate);
            
            element.innerHTML = `
                <div class="flex items-start justify-between">
                    <div class="flex-1">
                        <div class="text-white text-sm font-medium">${message}</div>
                        <div class="text-[#9cabba] text-xs mt-1">${timeAgo}</div>
                    </div>
                    <div class="w-2 h-2 bg-blue-500 rounded-full ml-2 mt-1"></div>
                </div>
            `;
            
            return element;
        }

        // Handle aggregated notification click (navigate to availability page)
        async function handleAggregatedNotificationClick(driverData) {
            try {
                document.getElementById('notificationDropdown').classList.add('hidden');
                const dates = driverData.notifications.map(n => n.date).sort();
                const earliestDate = dates[0] ? new Date(dates[0]) : new Date();
                const year = earliestDate.getFullYear();
                const month = earliestDate.getMonth() + 1;
                window.location.href = `/pages/availability.html?year=${year}&month=${month}&showChanges=${driverData.driverId}`;
            } catch (error) {
                console.error('Error handling aggregated notification click:', error);
            }
        }

        // Handle notification click
        async function handleNotificationClick(notificationId, notification) {
            try {
                // Mark notification as read
                const notificationRef = window.firebaseDoc(window.firestore, 'availabilityNotifications', notificationId);
                await window.firebaseUpdateDoc(notificationRef, { seen: true });
                
                // Hide dropdown
                document.getElementById('notificationDropdown').classList.add('hidden');
                
                // Navigate to availability page with specific date
                const date = new Date(notification.date);
                const year = date.getFullYear();
                const month = date.getMonth() + 1; // JavaScript months are 0-indexed
                
                // Navigate to availability page with date parameters
                window.location.href = `/pages/availability.html?year=${year}&month=${month}&openDate=${notification.date}`;
                
            } catch (error) {
                console.error('Error handling notification click:', error);
            }
        }

        // Get time ago string
        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            return date.toLocaleDateString();
        }

        // Initialize notification system
        async function initializeNotifications() {
            // Update notification count on page load
            await updateNotificationCount();
            
            // Set up click outside to close dropdown
            document.addEventListener('click', function(event) {
                const dropdown = document.getElementById('notificationDropdown');
                const button = event.target.closest('button[onclick="showNotifications()"]');
                
                if (!button && !dropdown.contains(event.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        async function logout() {
            if (confirm('Are you sure you want to logout?')) {
                try {
                    // Sign out from Firebase
                    await window.signOut(window.auth);
                    
                    console.log('User logged out successfully');
                    
                    window.sotoSession?.clearSession();
                    
                    // Redirect to login page
                    window.location.href = '/pages/soto-routes-login.html';
                } catch (error) {
                    console.error('Logout error:', error);
                    window.sotoSession?.clearSession();
                    window.location.href = '/pages/soto-routes-login.html';
                }
            }
        }

        // Load routes from Firebase (with localStorage fallback)
        async function loadRoutesFromFirebase() {
            try {
                // Check if Firebase is available
                if (!window.firestore || !window.firebaseCollection) {
                    console.log('Firebase not available, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }

                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context when loading routes. Falling back to localStorage.');
                    return loadRoutesFromLocalStorage();
                }

                console.log('Loading routes and jobs from Firebase...');
                
                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                const jobsCollection = window.firebaseCollection(window.firestore, 'jobs');

                const officeRoutesQuery = window.firebaseQuery(routesCollection, window.firebaseWhere('officeId', '==', officeId));
                const officeJobsQuery = window.firebaseQuery(jobsCollection, window.firebaseWhere('officeId', '==', officeId));

                const [routesSnapshot, jobsSnapshot, legacyRoutesSnapshot, legacyJobsSnapshot] = await Promise.all([
                    window.firebaseGetDocs(officeRoutesQuery),
                    window.firebaseGetDocs(officeJobsQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(routesCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy routes query failed (likely none remaining):', legacyError);
                            return { docs: [] };
                        }
                    })(),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(jobsCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy jobs query failed (likely none remaining):', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);
                
                savedRoutes = [];
                
                const routeDocs = [...routesSnapshot.docs, ...(legacyRoutesSnapshot?.docs || [])];

                if (routeDocs.length === 0) {
                    console.log('No routes found in Firebase, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }
                
                const jobsByRoute = {};
                const jobDocs = [...jobsSnapshot.docs, ...(legacyJobsSnapshot?.docs || [])];

                await Promise.all(jobDocs.map(async jobDoc => {
                    const jobData = jobDoc.data();

                    if (jobData.officeId && jobData.officeId !== officeId) {
                        return;
                    }

                    if (!jobData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(jobDoc.ref, { officeId });
                            jobData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for job ${jobDoc.id}:`, error);
                            return;
                        }
                    }

                    const routeId = jobData.assignedRouteId;
                    if (!routeId) {
                        return;
                    }

                        if (!jobsByRoute[routeId]) {
                            jobsByRoute[routeId] = [];
                        }
                        jobsByRoute[routeId].push({
                            id: jobDoc.id,
                            ...jobData
                        });
                }));
                    
                // Sort jobs within each route by jobNumber
                Object.keys(jobsByRoute).forEach(routeId => {
                    jobsByRoute[routeId].sort((a, b) => (a.jobNumber || 0) - (b.jobNumber || 0));
                });
                
                // Process routes and attach their jobs
                for (const routeDoc of routeDocs) {
                    const routeData = routeDoc.data();
                    const routeId = routeData.routeId || routeDoc.id;
                    
                    if (routeData.officeId && routeData.officeId !== officeId) {
                        continue;
                    }

                    if (!routeData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(routeDoc.ref, { officeId });
                            routeData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for route ${routeDoc.id}:`, error);
                            continue;
                        }
                    }

                    const jobs = jobsByRoute[routeId] || [];
                    
                    const routeWithJobs = {
                        route: {
                            id: routeDoc.id,
                            ...(routeData.route || routeData)  // Spread nested route if exists, otherwise spread routeData
                        },
                        jobs: jobs
                    };
                    
                    routeWithJobs.route.officeId = routeWithJobs.route.officeId || officeId;
                    savedRoutes.push(routeWithJobs);
                }

                if (savedRoutes.length === 0) {
                    console.log('No routes matched office filter, checking localStorage...');
                    return loadRoutesFromLocalStorage();
                }

                console.log(`Loaded ${savedRoutes.length} routes with jobs from Firebase (optimized)`);
                return savedRoutes;
            } catch (error) {
                console.error('Error loading routes from Firebase:', error);
                console.log('Falling back to localStorage...');
                return loadRoutesFromLocalStorage();
            }
        }

        // Save routes to Firebase
        async function saveRoutesToFirebase() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] Cannot save routes without office context.');
                    return;
                }

                const user = window.auth.currentUser;
                const userId = currentSession?.uid || user?.uid;
                if (!userId) {
                    console.error('No authenticated user found for saving routes');
                    return;
                }

                const routesCollection = window.firebaseCollection(window.firestore, 'routes');
                
                // Save each route with its assignments using the original route ID
                for (let i = 0; i < savedRoutes.length; i++) {
                    const routeData = savedRoutes[i];
                    const originalRouteId = routeData.route.id; // Use the original Firebase document ID
                    const routeDocRef = window.firebaseDoc(routesCollection, originalRouteId);
                    
                    // Save driver assignments if they exist
                    const routeWithAssignments = { ...routeData.route };
                    routeWithAssignments.officeId = routeWithAssignments.officeId || officeId;
                    
                    const jobsWithOffice = (routeData.jobs || []).map(job => ({
                        ...job,
                        officeId: job.officeId || officeId
                    }));
                    
                    await window.firebaseSetDoc(routeDocRef, {
                        routeId: routeData.route.routeId || originalRouteId,
                        route: routeWithAssignments, // Include driver assignments
                        jobs: jobsWithOffice,
                        officeId: officeId,
                        lastUpdated: new Date(),
                        userId: userId
                    });
                }
                
                console.log(`Updated ${savedRoutes.length} routes in Firebase (with driver assignments)`);
            } catch (error) {
                console.error('Error saving routes to Firebase:', error);
            }
        }

        // Load drivers from Firebase
        async function loadDriversFromFirebase() {
            try {
                // Check if Firebase is available
                if (!window.firestore || !window.firebaseCollection) {
                    console.log('Firebase not available for drivers');
                    return [];
                }

                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context when loading drivers.');
                    drivers = [];
                    return drivers;
                }

                // Get all drivers from Firebase
                const driversCollection = window.firebaseCollection(window.firestore, 'drivers');
                const driversQuery = window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', officeId));

                let [driversSnapshot, legacySnapshot] = await Promise.all([
                    window.firebaseGetDocs(driversQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy drivers query (global) failed:', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);

                const driverDocs = [...driversSnapshot.docs, ...(legacySnapshot?.docs || [])];
                
                drivers = [];
                
                for (const driverDoc of driverDocs) {
                    const driverData = driverDoc.data();
                    
                    if (driverData.officeId && driverData.officeId !== officeId) {
                        continue;
                    }
                    
                    if (!driverData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(driverDoc.ref, { officeId });
                            driverData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for driver ${driverDoc.id}:`, error);
                            continue;
                        }
                    }
                    
                    console.log('Driver data from Firebase:', driverData);
                    
                    // Use the correct field names from the drivers page: firstName, lastName, homePostcode
                    const firstName = driverData.firstName || '';
                    const lastName = driverData.lastName || '';
                    const name = `${firstName} ${lastName}`.trim() || 'Unknown Driver';
                    const postcode = driverData.homePostcode || 'Unknown Postcode';
                    
                    drivers.push({
                        id: driverDoc.id,
                        name: name,
                        postcode: postcode,
                        ...driverData
                    });
                    
                    console.log('Processed driver:', { name, postcode });
                }

                console.log('Loaded drivers from Firebase:', drivers);
                return drivers;
            } catch (error) {
                console.error('Error loading drivers from Firebase:', error);
                // Fallback to demo drivers if Firebase fails
                drivers = [
                    { name: "John Smith", postcode: "B775JA" },
                    { name: "Sarah Johnson", postcode: "M1 4AN" },
                    { name: "Mike Wilson", postcode: "LS1 4DY" },
                    { name: "Emma Brown", postcode: "B797RU" },
                    { name: "David Taylor", postcode: "SW1A 0AA" }
                ];
                return drivers;
            }
        }

        // Load routes from localStorage (fallback)
        function loadRoutesFromLocalStorage() {
            try {
                const savedRoutesData = JSON.parse(localStorage.getItem('savedRoutes') || '[]');
                savedRoutes = [];
                
                for (const routeData of savedRoutesData) {
                    // Convert localStorage data to CloudKit-like format
                    const routeRecord = {
                        fields: {
                            routeIdString: { value: routeData.routeId },
                            userIdString: { value: routeData.userId },
                            routeNameString: { value: routeData.routeName },
                            driverNameString: { value: routeData.driverName },
                            driverLocationString: { value: routeData.driverLocation },
                            totalJobsInt64: { value: routeData.totalJobs },
                            totalDistanceDouble: { value: routeData.totalDistance },
                            estimatedDurationInt64: { value: routeData.estimatedDuration },
                            statusString: { value: routeData.status }
                        }
                    };
                    
                    const jobs = routeData.jobs.map(job => ({
                        fields: {
                            jobIdString: { value: job.jobId || `job_${routeData.routeId}_${job.jobNumber}` },
                            routeIdString: { value: routeData.routeId },
                            jobNumberInt64: { value: job.jobNumber },
                            collectionAddressString: { value: job.collectionAddress },
                            deliveryAddressString: { value: job.deliveryAddress },
                            collectionPostcodeString: { value: job.collectionPostcode },
                            deliveryPostcodeString: { value: job.deliveryPostcode },
                            jobPriceDouble: { value: job.price },
                            jobDistanceDouble: { value: job.distance },
                            jobDurationInt64: { value: job.duration },
                            jobNotesString: { value: job.notes },
                            isCompletedBoolean: { value: job.isCompleted ? 1 : 0 }
                        }
                    }));
                    
                    savedRoutes.push({
                        route: routeRecord,
                        jobs: jobs
                    });
                }
                
                console.log('Loaded routes from localStorage:', savedRoutes);
                return savedRoutes;
            } catch (error) {
                console.error('Error loading routes from localStorage:', error);
                return [];
            }
        }

        // Display routes from Firebase
        async function displayRoutesFromFirebase() {
            try {
                console.log('Loading routes from Firebase...');
                await loadRoutesFromFirebase();
                
                const routesContainer = document.getElementById('routes-container');
                const noRoutesMessage = document.getElementById('no-routes-message');
                
                if (savedRoutes.length === 0) {
                    noRoutesMessage.style.display = 'block';
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2">No saved routes available</p>
                        <p class="text-sm">Go to the Routes page to create and save routes first</p>
                    `;
                    hideDemoRoutes();
                    return;
                }
                
                console.log(`Found ${savedRoutes.length} routes, displaying...`);
                noRoutesMessage.style.display = 'none';
                hideDemoRoutes();
                
                // Clear existing dynamic routes
                const existingDynamicRoutes = routesContainer.querySelectorAll('.dynamic-route');
                existingDynamicRoutes.forEach(route => route.remove());
                
                // Display each saved route
                savedRoutes.forEach((routeData, index) => {
                    const route = routeData.route;
                    const jobs = routeData.jobs;
                    
                    if (jobs.length > 0) {
                        const firstJob = jobs[0];
                        const routeElement = createRouteElement(route, jobs, index + 1);
                        routesContainer.appendChild(routeElement);
                    }
                });
                
                // Populate driver assignments if they exist (same logic as displayRoutesWithAssignments)
                savedRoutes.forEach((routeData, index) => {
                    const routeNumber = index + 1;
                    
                    if (routeData.route.assignedDriverName) {
                        const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                        const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                        const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                        
                        if (driverElement) {
                            driverElement.textContent = routeData.route.assignedDriverName;
                        }
                        
                        if (locationElement) {
                            locationElement.textContent = routeData.route.assignedDriverPostcode || '-';
                        }
                        
                        if (regElement && routeData.jobs.length > 0) {
                            const firstJob = routeData.jobs[0];
                            const regNumber = firstJob?.parsedData?.reg_number || '-';
                            regElement.textContent = regNumber;
                        }
                        
                        // Restore carryover information if it exists
                        if (routeData.route.carryoverPostcode) {
                            const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                            const carryoverPostcode = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                            if (carryoverDisplay) carryoverDisplay.classList.remove('hidden');
                            if (carryoverPostcode) carryoverPostcode.textContent = routeData.route.carryoverPostcode;
                        }
                        
                        // Restore route score if it exists
                        if (routeData.route.routeScore) {
                            const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                            const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                            
                            if (scoreElement) {
                                scoreElement.textContent = routeData.route.routeScore.score;
                            }
                            
                            if (scoreContainer) {
                                if (routeData.route.routeScore.color === 'green') {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                                } else if (routeData.route.routeScore.color === 'orange') {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                                } else {
                                    scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                                }
                            }
                        }
                        
                        console.log(` Loaded assignment: ${routeData.route.assignedDriverName} to route ${routeNumber}`);
                    }
                });
                
                console.log(`Displayed ${savedRoutes.length} routes successfully`);
                
            } catch (error) {
                console.error('Error displaying routes:', error);
                const noRoutesMessage = document.getElementById('no-routes-message');
                if (noRoutesMessage) {
                    noRoutesMessage.style.display = 'block';
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2 text-red-400">Error loading routes</p>
                        <p class="text-sm">${error.message}</p>
                        <p class="text-sm mt-2">Click "Load Routes" to try again</p>
                    `;
                }
            }
        }

        // Create a route element from Firebase data
        function createRouteElement(routeRecord, jobs, routeNumber) {
            const routeDiv = document.createElement('div');
            routeDiv.className = 'flex flex-col gap-3 rounded-lg border border-[#283039] bg-[#1a1f24] p-3 dynamic-route w-full max-w-2xl';
            routeDiv.id = `firebase-route-${routeNumber}`;
            
            // Create job pairs (Collection A -> Delivery A, Collection B -> Delivery B, etc.)
            let jobPairsHTML = '';
            jobs.forEach((job, index) => {
                const jobLetter = String.fromCharCode(65 + index); // A, B, C, etc.
                
                
                // Extract postcodes from addresses
                let collectionPostcode = 'N/A';
                let deliveryPostcode = 'N/A';
                
                if (job.parsedData?.collection_address) {
                    collectionPostcode = job.parsedData.collection_address;
                }
                
                if (job.parsedData?.postcode_delivery) {
                    deliveryPostcode = job.parsedData.postcode_delivery;
                }
                
                jobPairsHTML += `
                    <div class="flex flex-col gap-1.5">
                        <label class="text-gray-400 font-medium text-xs">Collection ${jobLetter}</label>
                        <p class="text-green-400 font-semibold text-sm">${collectionPostcode}</p>
                    </div>
                    <div class="flex flex-col gap-1.5">
                        <label class="text-gray-400 font-medium text-xs">Delivery ${jobLetter}</label>
                        <p class="text-red-400 font-semibold text-sm">${deliveryPostcode}</p>
                    </div>
                `;
            });
            
            routeDiv.innerHTML = `
                <div class="relative">
                    <!-- Score display in top right corner -->
                    <div class="absolute top-0 right-0 bg-gray-800 rounded-bl-lg px-2 py-1" id="firebase-route-${routeNumber}-score">
                        <span class="text-xs font-bold" id="firebase-route-${routeNumber}-score-text">-</span>
                    </div>
                    
                <!-- Driver Info Line -->
                <div class="flex items-center gap-3 mb-3 text-sm">
                    <div class="flex items-center gap-2">
                        <span class="text-gray-400 font-medium text-xs">REG:</span>
                        <span class="text-white font-bold" id="firebase-route-${routeNumber}-reg">-</span>
                    </div>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <span class="text-white font-semibold" id="firebase-route-${routeNumber}-driver">-</span>
                    <div class="h-4 w-px bg-gray-600"></div>
                    <div class="flex flex-col">
                        <div class="flex items-center gap-2">
                            <span class="text-gray-400 text-xs">Driver Home:</span>
                            <span class="text-white text-xs font-semibold" id="firebase-route-${routeNumber}-driver-location">-</span>
                        </div>
                        <div id="firebase-route-${routeNumber}-carryover-display" class="hidden flex items-center gap-2 mt-0.5">
                            <span class="text-gray-400 text-xs">(Carryover):</span>
                            <span class="text-red-400 text-xs font-bold" id="firebase-route-${routeNumber}-carryover-postcode">-</span>
                        </div>
                    </div>
                </div>
                    
                <div class="grid grid-cols-${Math.min(jobs.length * 2, 6)} gap-2 text-xs">
                    ${jobPairsHTML}
                </div>
                <div class="mt-3 grid grid-cols-2 gap-2">
                    <div>
                        <label class="text-gray-400 font-medium text-xs mb-1 block" id="firebase-route-${routeNumber}-to-work-label">To First Job</label>
                        <div id="firebase-route-${routeNumber}-to-work" class="bg-[#283039] rounded-lg px-3 py-2 text-gray-500 text-xs">
                            -
                        </div>
                    </div>
                    <div>
                        <label class="text-gray-400 font-medium text-xs mb-1 block">From Last Job</label>
                        <div id="firebase-route-${routeNumber}-from-work" class="bg-[#283039] rounded-lg px-3 py-2 text-gray-500 text-xs">
                            -
                        </div>
                    </div>
                </div>
            `;
            
            // Populate driver information if assigned
            if (routeRecord.assignedDriverName) {
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                
                if (driverElement) {
                    driverElement.textContent = routeRecord.assignedDriverName;
                }
                if (locationElement) {
                    locationElement.textContent = routeRecord.assignedDriverPostcode || '-';
                }
            }
            
            return routeDiv;
        }

        // Show demo routes for optimization
        function showDemoRoutes() {
            document.getElementById('demo-route-1').style.display = 'block';
            document.getElementById('demo-route-2').style.display = 'block';
            document.getElementById('demo-route-3').style.display = 'block';
            document.getElementById('no-routes-message').style.display = 'none';
        }

        // Hide demo routes
        function hideDemoRoutes() {
            document.getElementById('demo-route-1').style.display = 'none';
            document.getElementById('demo-route-2').style.display = 'none';
            document.getElementById('demo-route-3').style.display = 'none';
        }

        // Optimize routes function
        // Global variable to store carry-over postcodes
        let carryOverPostcodes = {};

        async function optimizeRoutes() {
            console.log('optimizeRoutes called, current drivers array length:', drivers.length);
            
            // Only load drivers from Firebase if we don't already have them
            if (drivers.length === 0) {
                console.log('Loading drivers for optimization...');
                await loadDriversFromFirebase();
                console.log('After loadDriversFromFirebase, drivers array length:', drivers.length);
            } else {
                console.log('Using existing drivers for optimization:', drivers.length);
            }
            
            if (drivers.length === 0) {
                alert('No drivers found in database. Please add drivers first.');
                return;
            }
            
            // Show alterations popup before optimization
            showAlterationsPopup();
        }

        // Show alterations popup
        function showAlterationsPopup() {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            overlay.id = 'alterations-overlay';
            
            // Create popup content
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 w-full max-w-md mx-4 border border-[#283039]">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Alterations</h3>
                        <button onclick="closeAlterationsPopup()" class="text-gray-400 hover:text-white">
                            <span class="material-symbols-outlined text-xl">close</span>
                        </button>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-300 mb-2">Carry-Overs</label>
                            <p class="text-xs text-gray-400 mb-3">Set temporary starting locations for drivers (e.g., morning car drop-offs)</p>
                            
                            <div id="carry-overs-list" class="space-y-2">
                                <!-- Carry-over items will be added here -->
                            </div>
                            
                            <div class="mt-3">
                                <select id="carry-over-driver-select" class="w-full bg-[#283039] border border-gray-600 rounded-md px-3 py-2 text-white text-sm">
                                    <option value="">Select a driver...</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="flex gap-3 pt-4">
                            <button onclick="closeAlterationsPopup()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Cancel
                            </button>
                            <button onclick="startOptimization()" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Start Optimization
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Populate driver dropdown
            populateDriverDropdown();
            
            // Add event listener for driver selection
            document.getElementById('carry-over-driver-select').addEventListener('change', function() {
                const selectedDriverId = this.value;
                if (selectedDriverId) {
                    addCarryOverDriver(selectedDriverId);
                    this.value = ''; // Reset selection
                }
            });
        }

        // Populate driver dropdown
        function populateDriverDropdown() {
            const select = document.getElementById('carry-over-driver-select');
            select.innerHTML = '<option value="">Select a driver...</option>';
            
            drivers.forEach((driver, index) => {
                // Don't show drivers who already have carry-over set
                if (!carryOverPostcodes[index]) {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = driver.name;
                    select.appendChild(option);
                }
            });
        }

        // Add carry-over driver
        function addCarryOverDriver(driverIndex) {
            const driver = drivers[driverIndex];
            const postcode = prompt(`Enter carry-over postcode for ${driver.name}:`);
            
            if (postcode && postcode.trim()) {
                carryOverPostcodes[driverIndex] = postcode.trim().toUpperCase();
                updateCarryOversList();
                populateDriverDropdown(); // Refresh dropdown to remove selected driver
                console.log(`Carry-over set for ${driver.name}: ${postcode.trim().toUpperCase()}`);
            }
        }

        // Update carry-overs list display
        function updateCarryOversList() {
            const listContainer = document.getElementById('carry-overs-list');
            listContainer.innerHTML = '';
            
            Object.keys(carryOverPostcodes).forEach(driverIndex => {
                const driver = drivers[parseInt(driverIndex)];
                const postcode = carryOverPostcodes[driverIndex];
                
                const item = document.createElement('div');
                item.className = 'flex items-center justify-between bg-[#283039] rounded-md px-3 py-2';
                item.innerHTML = `
                    <div>
                        <span class="text-white text-sm font-medium">${driver.name}</span>
                        <span class="text-gray-400 text-xs ml-2"> ${postcode}</span>
                    </div>
                    <button onclick="removeCarryOver(${driverIndex})" class="text-red-400 hover:text-red-300">
                        <span class="material-symbols-outlined text-sm">close</span>
                    </button>
                `;
                listContainer.appendChild(item);
            });
        }

        // Remove carry-over
        function removeCarryOver(driverIndex) {
            delete carryOverPostcodes[driverIndex];
            updateCarryOversList();
            populateDriverDropdown(); // Refresh dropdown to show removed driver
            console.log(`Carry-over removed for ${drivers[driverIndex].name}`);
        }

        // Close alterations popup
        function closeAlterationsPopup() {
            const overlay = document.getElementById('alterations-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Week calculation functions for optimise settings
        function getWeekStart(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust when day is Sunday
            return new Date(d.setDate(diff));
        }

        function getWeekNumber(date) {
            const d = new Date(date);
            d.setHours(0, 0, 0, 0);
            d.setDate(d.getDate() + 3 - (d.getDay() + 6) % 7);
            const week1 = new Date(d.getFullYear(), 0, 4);
            return 1 + Math.round(((d.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        }

        // Show optimise settings popup
        function showOptimiseSettings() {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
            overlay.id = 'optimise-settings-overlay';
            
            // Create popup content
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 w-full max-w-2xl mx-4 border border-[#283039] max-h-[90vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-white">Optimise Settings</h3>
                        <button onclick="closeOptimiseSettings()" class="text-gray-400 hover:text-white">
                            <span class="material-symbols-outlined text-xl">close</span>
                        </button>
                    </div>
                    
                    <div class="space-y-6">
                        <!-- Day Selection Section -->
                        <div id="day-selection-section">
                            <h4 class="text-lg font-semibold text-white mb-3">1. Select Day</h4>
                            <div class="flex gap-3">
                                <select id="weekSelectOptimise" class="flex-1 bg-[#283039] border border-gray-600 rounded-md px-3 py-2 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="">Choose a week...</option>
                                    <option value="current">Current Week</option>
                                    <option value="next">Next Week</option>
                                </select>
                            </div>
                            <div id="weekDaysOptimise" class="grid grid-cols-2 gap-2 mt-3">
                                <!-- Days will be populated here -->
                            </div>
                        </div>

                        <!-- Driver Overview Section (hidden initially) -->
                        <div id="driver-overview-section" class="hidden">
                            <h4 class="text-lg font-semibold text-white mb-3">2. Driver Availability</h4>
                            
                            <!-- Drivers Off Today -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between mb-3">
                                    <span class="text-white font-medium">Drivers Off Today</span>
                                    <span id="driversOffCount" class="text-red-400 font-bold">0</span>
                                </div>
                                <div id="driversOffList" class="space-y-2">
                                    <!-- Drivers off will be listed here -->
                                </div>
                            </div>

                            <!-- Total Drivers -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-white font-medium">Available Drivers</span>
                                    <span id="totalDriversCount" class="text-blue-400 font-bold text-lg">0/0</span>
                                </div>
                            </div>

                            <!-- Total Routes -->
                            <div class="bg-[#283039] rounded-lg p-4 mb-4">
                                <div class="flex items-center justify-between">
                                    <span class="text-white font-medium">Routes to Assign</span>
                                    <span id="totalRoutesCount" class="text-green-400 font-bold text-lg">0</span>
                                </div>
                            </div>

                            <!-- Availability Button -->
                            <div class="flex justify-center">
                                <button id="markAsOffBtn" class="bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-md text-sm font-medium transition-colors">
                                    Availability
                                </button>
                            </div>

                            <!-- Driver Selection Dropdown (hidden initially) -->
                            <div id="driverSelectionDropdown" class="hidden mt-4 bg-[#283039] rounded-lg p-4 border border-gray-600">
                                <h5 class="text-white font-medium mb-3">Select Driver Availability</h5>
                                <div id="allDriversList" class="space-y-2 max-h-60 overflow-y-auto">
                                    <!-- All drivers will be listed here -->
                                </div>
                            </div>
                        </div>

                        <!-- Carryover Settings Section -->
                        <div id="carryoverSection" class="hidden">
                            <div class="flex items-center gap-2 mb-3">
                                <span class="material-symbols-outlined text-green-500">local_shipping</span>
                                <h4 class="text-md font-bold text-white">3. Carryover Settings</h4>
                            </div>
                            <p class="text-sm text-gray-400 mb-3">Select drivers who have carryover vehicles to deliver in the morning</p>
                            
                            <!-- Driver Search and Selection -->
                            <div class="mb-3">
                                <input type="text" id="carryoverDriverSearch" placeholder="Search drivers..." 
                                    class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-green-500 mb-2">
                                <div id="carryoverDriverList" class="max-h-48 overflow-y-auto bg-[#283039] rounded-md border border-gray-600">
                                    <!-- Drivers will be populated here -->
                                </div>
                            </div>
                            
                            <!-- Selected Carryovers Display -->
                            <div id="selectedCarryovers" class="hidden mb-3">
                                <h5 class="text-sm font-bold text-white mb-2">Drivers with Carryovers:</h5>
                                <div id="carryoversList" class="space-y-2">
                                    <!-- Carryover items will be added here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- Action Buttons -->
                        <div class="flex gap-3 pt-4 border-t border-gray-700">
                            <button onclick="closeOptimiseSettings()" class="flex-1 bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Cancel
                            </button>
                            <button id="nextToCarryoverBtn" onclick="showCarryoverSettings()" class="hidden flex-1 bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                Next
                            </button>
                            <button id="startOptimisationBtn" onclick="startOptimisationWithSettings()" class="hidden flex-1 bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md text-sm font-medium transition-colors">
                                Start Optimisation
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Ensure day selection section is visible when popup opens
            const daySelectionSection = document.getElementById('day-selection-section');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            if (daySelectionSection) {
                daySelectionSection.style.display = 'block';
            }
            if (weekDaysContainer) {
                weekDaysContainer.style.display = 'block';
            }
            
            // Initialize day selection
            initializeOptimiseDaySelection();
        }

        // Global variables for optimise settings
        let selectedOptimiseDay = null;
        let tempDriversOff = []; // Temporary list of drivers marked as off
        let allDrivers = []; // All drivers for the office

        // Initialize day selection for optimise settings
        function initializeOptimiseDaySelection() {
            const weekSelect = document.getElementById('weekSelectOptimise');
            const markAsOffBtn = document.getElementById('markAsOffBtn');
            
            weekSelect.addEventListener('change', populateOptimiseWeekDays);
            markAsOffBtn.addEventListener('click', toggleDriverSelectionDropdown);
            
            // Click outside to close dropdown
            document.addEventListener('click', (e) => {
                const dropdown = document.getElementById('driverSelectionDropdown');
                const btn = document.getElementById('markAsOffBtn');
                const allDriversList = document.getElementById('allDriversList');
                
                // Only close if clicking outside the dropdown, button, and driver list
                if (dropdown && !dropdown.contains(e.target) && !btn.contains(e.target) && !allDriversList.contains(e.target)) {
                    dropdown.classList.add('hidden');
                    // Reset button state when closing
                    btn.classList.remove('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                    btn.classList.add('bg-red-600', 'hover:bg-red-700');
                }
            });
        }

        // Populate week days for optimise settings
        function populateOptimiseWeekDays() {
            const weekSelect = document.getElementById('weekSelectOptimise');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            
            if (!weekSelect.value || weekSelect.value === 'selected') {
                weekDaysContainer.innerHTML = '';
                weekDaysContainer.style.display = 'none';
                return;
            }
            
            const weekType = weekSelect.value;
            const days = generateOptimiseWeekDays(weekType);
            
            weekDaysContainer.innerHTML = days.map(day => `
                <button onclick="selectOptimiseDay('${day.date.toISOString()}', '${day.dayName}', '${day.week}')" 
                        class="p-3 bg-[#283039] border border-gray-600 rounded-lg text-white text-sm hover:bg-[#3a4049] transition-colors">
                    <div class="font-medium">${day.dayName}</div>
                    <div class="text-xs text-gray-400">${day.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}</div>
                </button>
            `).join('');
            
            // Show the week days container
            weekDaysContainer.style.display = 'block';
        }

        // Generate week days for optimise settings
        function generateOptimiseWeekDays(weekType) {
            const today = new Date();
            let startDate;
            
            if (weekType === 'current') {
                startDate = getWeekStart(today);
            } else { // next week
                startDate = getWeekStart(today);
                startDate.setDate(startDate.getDate() + 7);
            }
            
            const days = [];
            for (let i = 0; i < 5; i++) { // Monday to Friday only
                const dayDate = new Date(startDate);
                dayDate.setDate(startDate.getDate() + i);
                
                const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'];
                const week = getWeekNumber(dayDate);
                
                days.push({
                    date: dayDate,
                    dayName: dayNames[i],
                    week: `${dayDate.getFullYear()}-W${week.toString().padStart(2, '0')}`
                });
            }
            
            return days;
        }

        // Select day for optimise settings
        async function selectOptimiseDay(dateString, dayName, week) {
            selectedOptimiseDay = {
                date: new Date(dateString),
                dayName: dayName,
                week: week
            };
            
            // Minimize the day selection section but keep the week dropdown
            const daySelectionSection = document.getElementById('day-selection-section');
            const weekDaysContainer = document.getElementById('weekDaysOptimise');
            if (weekDaysContainer) {
                weekDaysContainer.style.display = 'none';
            }
            
            // Show driver overview section
            const driverOverviewSection = document.getElementById('driver-overview-section');
            driverOverviewSection.classList.remove('hidden');
            
            // Update the section title to show selected day
            const sectionTitle = driverOverviewSection.querySelector('h4');
            if (sectionTitle) {
                sectionTitle.textContent = `2. Driver Availability - ${dayName} ${selectedOptimiseDay.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`;
            }
            
            // Update the week dropdown to show selected day but keep functionality
            const weekSelect = document.getElementById('weekSelectOptimise');
            if (weekSelect) {
                const selectedText = `${dayName} ${selectedOptimiseDay.date.toLocaleDateString('en-GB', { day: 'numeric', month: 'short' })}`;
                // Keep the original options but update the selected one
                const currentValue = weekSelect.value;
                weekSelect.innerHTML = `
                    <option value="">Choose a week...</option>
                    <option value="current" ${currentValue === 'current' ? 'selected' : ''}>Current Week</option>
                    <option value="next" ${currentValue === 'next' ? 'selected' : ''}>Next Week</option>
                `;
                // Add a custom option to show the selected day
                const selectedOption = document.createElement('option');
                selectedOption.value = 'selected';
                selectedOption.textContent = selectedText;
                selectedOption.selected = true;
                weekSelect.appendChild(selectedOption);
            }
            
            // Load drivers and their availability
            await loadDriversForOptimise();
            await loadDriversOffForOptimise();
            
            // Show "Next" button instead of "Start Optimisation"
            document.getElementById('nextToCarryoverBtn').classList.remove('hidden');
            document.getElementById('nextToCarryoverBtn').disabled = false;
        }
        
        // Global variable for carryovers
        let driversWithCarryover = new Map(); // Map<driverId, carryoverPostcode>
        
        // Show carryover settings
        function showCarryoverSettings() {
            // Hide day selection section
            const daySelectionSection = document.getElementById('day-selection-section');
            if (daySelectionSection) {
                daySelectionSection.style.display = 'none';
            }
            
            // Hide driver availability section
            const driverSection = document.querySelector('#optimise-settings-overlay .space-y-6 > div:nth-child(2)');
            if (driverSection) {
                driverSection.style.display = 'none';
            }
            
            // Show carryover section
            const carryoverSection = document.getElementById('carryoverSection');
            carryoverSection.classList.remove('hidden');
            
            // Hide "Next" button, show "Start Optimisation" button
            document.getElementById('nextToCarryoverBtn').classList.add('hidden');
            document.getElementById('startOptimisationBtn').classList.remove('hidden');
            
            // Populate driver list for carryover selection
            populateCarryoverDriverList();
        }
        
        // Populate driver list with search functionality
        function populateCarryoverDriverList() {
            const driverList = document.getElementById('carryoverDriverList');
            const searchInput = document.getElementById('carryoverDriverSearch');
            
            const renderDriverList = (searchTerm = '') => {
                const filteredDrivers = allDrivers.filter(driver => {
                    const driverName = driver.name || `${driver.firstName} ${driver.lastName}`;
                    const isOff = tempDriversOff.some(off => off.id === driver.id || off.id === driver.uid);
                    const matchesSearch = searchTerm === '' || driverName.toLowerCase().includes(searchTerm.toLowerCase());
                    return !isOff && matchesSearch; // Only show available drivers
                });
                
                driverList.innerHTML = filteredDrivers.map(driver => {
                    const driverName = driver.name || `${driver.firstName} ${driver.lastName}`;
                    const hasCarryover = driversWithCarryover.has(driver.id);
                    
                    return `
                        <div onclick="selectDriverForCarryover('${driver.id}', '${driverName.replace(/'/g, "\\'")}  ')" 
                            class="p-3 hover:bg-[#3a4049] transition-colors cursor-pointer border-b border-gray-700 last:border-0 ${hasCarryover ? 'bg-green-900 bg-opacity-20' : ''}">
                            <div class="flex items-center justify-between">
                                <span class="text-white text-sm">${driverName}</span>
                                ${hasCarryover ? '<span class="material-symbols-outlined text-green-500 text-sm">check_circle</span>' : ''}
                            </div>
                        </div>
                    `;
                }).join('') || '<div class="p-3 text-gray-400 text-sm text-center">No drivers found</div>';
            };
            
            // Initial render
            renderDriverList();
            
            // Search functionality
            searchInput.addEventListener('input', (e) => {
                renderDriverList(e.target.value);
            });
        }
        
        // Select driver for carryover
        function selectDriverForCarryover(driverId, driverName) {
            // Show input modal for carryover postcode
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[110]';
            overlay.id = 'carryover-postcode-overlay';
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-6 max-w-md w-full mx-4 border border-gray-600">
                    <h3 class="text-lg font-bold text-white mb-4">Carryover for ${driverName}</h3>
                    <div class="mb-4">
                        <label class="block text-sm text-gray-400 mb-2">Carryover Postcode</label>
                        <input type="text" id="carryover-postcode-input" 
                            class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white text-sm focus:outline-none focus:ring-2 focus:ring-green-500"
                            placeholder="e.g., SW1A 1AA">
                        <p id="carryover-validation-error" class="text-red-500 text-xs mt-1 hidden"></p>
                    </div>
                    <div class="flex gap-3">
                        <button onclick="closeCarryoverPostcodeModal()" 
                            class="flex-1 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors text-sm font-bold">
                            Cancel
                        </button>
                        <button onclick="saveCarryoverPostcode('${driverId}', '${driverName.replace(/'/g, "\\'")} ')" 
                            class="flex-1 px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-sm font-bold">
                            Save
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Focus and pre-fill if exists
            setTimeout(() => {
                const input = document.getElementById('carryover-postcode-input');
                if (driversWithCarryover.has(driverId)) {
                    input.value = driversWithCarryover.get(driverId);
                }
                input.focus();
                input.select();
            }, 100);
        }
        
        // Save carryover postcode
        function saveCarryoverPostcode(driverId, driverName) {
            const input = document.getElementById('carryover-postcode-input');
            const errorElement = document.getElementById('carryover-validation-error');
            const value = input.value.trim().toUpperCase();
            
            if (!value) {
                errorElement.textContent = 'Postcode is required';
                errorElement.classList.remove('hidden');
                return;
            }
            
            // Validate UK postcode format
            const postcodePattern = /^[A-Z]{1,2}\d{1,2}[A-Z]?\s?\d[A-Z]{2}$/i;
            if (!postcodePattern.test(value)) {
                errorElement.textContent = 'Please enter a valid UK postcode';
                errorElement.classList.remove('hidden');
                return;
            }
            
            // Normalize postcode (add space before last 3 chars if needed)
            const cleaned = value.replace(/\s+/g, '');
            const normalized = `${cleaned.slice(0, -3)} ${cleaned.slice(-3)}`;
            
            // Save carryover
            driversWithCarryover.set(driverId, normalized);
            
            // Close modal
            closeCarryoverPostcodeModal();
            
            // Update UI
            updateCarryoverDisplay();
            populateCarryoverDriverList();
        }
        
        // Close carryover postcode modal
        function closeCarryoverPostcodeModal() {
            const overlay = document.getElementById('carryover-postcode-overlay');
            if (overlay) {
                overlay.remove();
            }
        }
        
        // Update carryover display
        function updateCarryoverDisplay() {
            const selectedCarryoversSection = document.getElementById('selectedCarryovers');
            const carryoversList = document.getElementById('carryoversList');
            
            if (driversWithCarryover.size > 0) {
                selectedCarryoversSection.classList.remove('hidden');
                
                const items = [];
                driversWithCarryover.forEach((postcode, driverId) => {
                    const driver = allDrivers.find(d => d.id === driverId);
                    const driverName = driver ? (driver.name || `${driver.firstName} ${driver.lastName}`) : 'Unknown';
                    
                    items.push(`
                        <div class="flex items-center justify-between p-2 bg-[#283039] rounded">
                            <div>
                                <span class="text-white text-sm font-medium">${driverName}</span>
                                <span class="text-red-400 text-sm font-bold ml-2">${postcode}</span>
                            </div>
                            <button onclick="removeCarryover('${driverId}')" class="text-gray-400 hover:text-white transition-colors">
                                <span class="material-symbols-outlined text-sm">close</span>
                            </button>
                        </div>
                    `);
                });
                
                carryoversList.innerHTML = items.join('');
            } else {
                selectedCarryoversSection.classList.add('hidden');
            }
        }
        
        // Remove carryover
        function removeCarryover(driverId) {
            driversWithCarryover.delete(driverId);
            updateCarryoverDisplay();
            populateCarryoverDriverList();
        }

        // Load office logo from Firebase
        async function loadOfficeLogo(officeId) {
            if (!officeId) {
                console.log('No officeId provided, skipping logo load');
                return;
            }
            
            console.log('Loading office logo for officeId:', officeId);
            
            try {
                // Wait for Firebase to be ready with retries
                let attempts = 0;
                while (attempts < 20 && (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc)) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (!window.firestore || !window.firebaseGetDoc || !window.firebaseDoc) {
                    console.error('Firebase not ready after waiting');
                    console.log('Available Firebase:', { firestore: !!window.firestore, firebaseGetDoc: !!window.firebaseGetDoc, firebaseDoc: !!window.firebaseDoc });
                    return;
                }
                
                console.log('Fetching office document...');
                const officeDoc = await window.firebaseGetDoc(window.firebaseDoc(window.firestore, 'offices', officeId));
                
                if (!officeDoc.exists()) {
                    console.log('Office document does not exist');
                    return;
                }
                
                const officeData = officeDoc.data();
                console.log('Office data:', officeData);
                console.log('Office logoUrl:', officeData.logoUrl);
                
                const logoImg = document.getElementById('officeLogoImg');
                if (!logoImg) {
                    console.error('Logo image element not found');
                    return;
                }
                
                if (officeData.logoUrl) {
                    console.log('Setting logo image source to:', officeData.logoUrl);
                    logoImg.src = officeData.logoUrl;
                    // Force reload if image is cached
                    logoImg.onload = function() {
                        console.log('Logo image loaded successfully');
                    };
                    logoImg.onerror = function() {
                        console.error('Error loading logo image, falling back to default');
                        logoImg.src = '/assets/logos/favicon.svg';
                    };
                } else {
                    console.log('No logoUrl in office data, keeping default logo');
                }
            } catch (error) {
                console.error('Error loading office logo:', error);
                console.error('Error details:', error.message, error.stack);
                // Fallback to default logo (already set in HTML)
            }
        }

        // Load all drivers for the office
        async function loadDriversForOptimise() {
            try {
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] No office context available when loading drivers.');
                    document.getElementById('totalDriversCount').textContent = '0';
                    return;
                }
                
                // Load office logo
                await loadOfficeLogo(officeId);
                
                console.log('Loading drivers for office:', officeId);
                
                const driversCollection = window.firebaseCollection(window.firestore, 'drivers');
                const driversQuery = window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', officeId));
                
                let [driversSnapshot, legacySnapshot] = await Promise.all([
                    window.firebaseGetDocs(driversQuery),
                    (async () => {
                        try {
                            return await window.firebaseGetDocs(
                                window.firebaseQuery(driversCollection, window.firebaseWhere('officeId', '==', null))
                            );
                        } catch (legacyError) {
                            console.warn('[OPTIMISATION] Legacy drivers query failed (likely no legacy docs):', legacyError);
                            return { docs: [] };
                        }
                    })()
                ]);
                
                allDrivers = [];
                
                const driverDocs = [...driversSnapshot.docs, ...(legacySnapshot?.docs || [])];
                
                for (const doc of driverDocs) {
                    const driverData = doc.data();
                    if (driverData.officeId && driverData.officeId !== officeId) {
                        continue;
                    }
                    
                    if (!driverData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(doc.ref, { officeId });
                            driverData.officeId = officeId;
                        } catch (error) {
                            console.warn(`Failed to backfill officeId for driver ${doc.id}:`, error);
                            continue;
                        }
                    }
                    
                    allDrivers.push({
                        id: doc.id,
                        ...driverData
                    });
                }
                
                // Sort drivers alphabetically by name (handle missing names)
                allDrivers.sort((a, b) => {
                    const nameA = a.name || a.firstName + ' ' + a.lastName || 'Unknown';
                    const nameB = b.name || b.firstName + ' ' + b.lastName || 'Unknown';
                    return nameA.localeCompare(nameB);
                });
                
                // Update total drivers count (will be updated with fraction in updateDriversOffDisplay)
                // document.getElementById('totalDriversCount').textContent = allDrivers.length;
                
                console.log(`Loaded ${allDrivers.length} drivers for optimise settings:`, allDrivers);
                console.log('Driver IDs in collection:', allDrivers.map(d => d.id));
                console.log('Driver UIDs in collection:', allDrivers.map(d => d.uid));
            } catch (error) {
                console.error('Error loading drivers for optimise:', error);
                // Set count to 0 on error
                document.getElementById('totalDriversCount').textContent = '0';
            }
        }

        // Load drivers off for the selected day
        async function loadDriversOffForOptimise() {
            try {
                if (!selectedOptimiseDay) return;
                
                const officeId = getCurrentOfficeId();
                if (!officeId) {
                    console.warn('[OPTIMISATION] Missing office context when loading drivers off.');
                    tempDriversOff = [];
                    updateDriversOffDisplay();
                    return;
                }
                
                const dateString = selectedOptimiseDay.date.toISOString().split('T')[0]; // YYYY-MM-DD
                console.log('Loading drivers off for date:', dateString);
                console.log('Available drivers:', allDrivers);
                
                const calendarDoc = await window.firebaseGetDoc(
                    window.firebaseDoc(window.firestore, 'calendar', dateString)
                );
                
                tempDriversOff = []; // Reset temporary list
                
                if (calendarDoc.exists()) {
                    const calendarData = calendarDoc.data();
                    
                    if (calendarData.officeId && calendarData.officeId !== officeId) {
                        console.warn('[OPTIMISATION] Calendar entry belongs to a different office. Ignoring legacy data.');
                        updateDriversOffDisplay();
                        return;
                    }
                    
                    if (!calendarData.officeId) {
                        try {
                            await window.firebaseUpdateDoc(calendarDoc.ref, { officeId });
                        } catch (error) {
                            console.warn('Failed to backfill officeId on calendar entry:', error);
                        }
                    }
                    
                    const driversOff = calendarData.driversOff || [];
                    console.log('Calendar document found:', calendarData);
                    console.log('Drivers off in calendar:', driversOff);
                    
                    // Populate tempDriversOff with actual drivers off from Firebase
                    driversOff.forEach(driverOff => {
                        console.log('Looking for driver with ID:', driverOff.driverId);
                        console.log('Driver off object structure:', driverOff);
                        console.log('Available driver IDs:', allDrivers.map(d => d.id));
                        console.log('Available driver UIDs:', allDrivers.map(d => d.uid));
                        
                        // Try to match by Firebase Auth UID first, then by Firestore document ID
                        const driver = allDrivers.find(d => d.uid === driverOff.driverId || d.id === driverOff.driverId);
                        if (driver) {
                            console.log('Found matching driver:', driver);
                            tempDriversOff.push({
                                id: driver.id,
                                name: driver.name || (driver.firstName + ' ' + driver.lastName) || driverOff.driverName || 'Unknown Driver',
                                email: driver.email
                            });
                        } else {
                            console.log('No matching driver found for ID:', driverOff.driverId);
                            console.log('Available drivers:', allDrivers);
                        }
                    });
                } else {
                    console.log('No calendar document found for date:', dateString);
                }
                
                updateDriversOffDisplay();
                console.log(`Loaded ${tempDriversOff.length} drivers off for ${dateString}`);
            } catch (error) {
                console.error('Error loading drivers off for optimise:', error);
            }
        }

        // Update the drivers off display
        function updateDriversOffDisplay() {
            const driversOffList = document.getElementById('driversOffList');
            const driversOffCount = document.getElementById('driversOffCount');
            const totalDriversCount = document.getElementById('totalDriversCount');
            const totalRoutesCount = document.getElementById('totalRoutesCount');
            
            const totalDrivers = allDrivers.length;
            const driversOff = tempDriversOff.length;
            const availableDrivers = totalDrivers - driversOff;
            
            // Update drivers off count
            driversOffCount.textContent = driversOff;
            
            // Update total drivers count with fraction format
            totalDriversCount.textContent = `${availableDrivers}/${totalDrivers}`;
            
            // Update total routes count
            const routeCount = savedRoutes ? savedRoutes.length : 0;
            totalRoutesCount.textContent = routeCount;
            
            if (tempDriversOff.length === 0) {
                driversOffList.innerHTML = '<p class="text-gray-400 text-sm">No drivers off today</p>';
            } else {
                driversOffList.innerHTML = tempDriversOff.map(driver => `
                    <div class="flex items-center justify-between bg-[#1a1f24] rounded-lg p-2">
                        <span class="text-white text-sm">${driver.name}</span>
                        <button onclick="removeDriverFromOff('${driver.id}')" class="text-red-400 hover:text-red-300 text-sm">
                            Remove
                        </button>
                    </div>
                `).join('');
            }
        }

        // Toggle driver selection dropdown
        function toggleDriverSelectionDropdown() {
            const dropdown = document.getElementById('driverSelectionDropdown');
            const button = document.getElementById('markAsOffBtn');
            
            dropdown.classList.toggle('hidden');
            
            if (!dropdown.classList.contains('hidden')) {
                // Show dropdown - indicate button is active with red gradient
                button.classList.remove('bg-red-600', 'hover:bg-red-700');
                button.classList.add('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                populateAllDriversList();
            } else {
                // Hide dropdown - reset button to normal red state
                button.classList.remove('bg-gradient-to-r', 'from-red-500', 'to-red-700', 'hover:from-red-600', 'hover:to-red-800');
                button.classList.add('bg-red-600', 'hover:bg-red-700');
            }
        }

        // Populate all drivers list for selection
        function populateAllDriversList() {
            const allDriversList = document.getElementById('allDriversList');
            
            // Sort drivers: off drivers first, then alphabetical
            const sortedDrivers = [...allDrivers].sort((a, b) => {
                const aIsOff = tempDriversOff.some(off => off.id === a.id);
                const bIsOff = tempDriversOff.some(off => off.id === b.id);
                
                if (aIsOff && !bIsOff) return -1;
                if (!aIsOff && bIsOff) return 1;
                
                const nameA = a.name || (a.firstName + ' ' + a.lastName) || 'Unknown';
                const nameB = b.name || (b.firstName + ' ' + b.lastName) || 'Unknown';
                return nameA.localeCompare(nameB);
            });
            
            allDriversList.innerHTML = sortedDrivers.map(driver => {
                const isOff = tempDriversOff.some(off => off.id === driver.id);
                const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
                return `
                    <button onclick="event.stopPropagation(); toggleDriverOffStatus('${driver.id}', '${driverName}', '${driver.email}')" 
                            class="w-full flex items-center justify-between p-2 rounded-lg text-left transition-colors ${
                                isOff ? 'bg-red-600 hover:bg-red-700 text-white' : 'bg-[#1a1f24] hover:bg-[#3a4049] text-white'
                            }">
                        <span class="text-sm">${driverName}</span>
                        <span class="text-xs ${isOff ? 'text-red-200' : 'text-gray-400'}">
                            ${isOff ? 'OFF' : 'Available'}
                        </span>
                    </button>
                `;
            }).join('');
        }

        // Toggle driver off status
        function toggleDriverOffStatus(driverId, driverName, driverEmail) {
            const existingIndex = tempDriversOff.findIndex(driver => driver.id === driverId);
            
            if (existingIndex > -1) {
                // Remove from off list
                tempDriversOff.splice(existingIndex, 1);
            } else {
                // Add to off list
                tempDriversOff.push({
                    id: driverId,
                    name: driverName,
                    email: driverEmail
                });
            }
            
            updateDriversOffDisplay();
            populateAllDriversList(); // Refresh the dropdown
        }

        // Remove driver from off list
        function removeDriverFromOff(driverId) {
            const index = tempDriversOff.findIndex(driver => driver.id === driverId);
            if (index > -1) {
                tempDriversOff.splice(index, 1);
                updateDriversOffDisplay();
                populateAllDriversList(); // Refresh the dropdown
            }
        }

        // Close optimise settings popup
        function closeOptimiseSettings() {
            const overlay = document.getElementById('optimise-settings-overlay');
            if (overlay) {
                overlay.remove();
            }
            
            // Reset variables
            selectedOptimiseDay = null;
            tempDriversOff = [];
            allDrivers = [];
        }

        // Start optimisation with settings
        async function startOptimisationWithSettings() {
            if (!selectedOptimiseDay) {
                alert('Please select a day first');
                return;
            }
            
            // Simple approach: Get all office drivers, filter out the ones marked as off (BEFORE closing popup)
            console.log('Starting simple optimization...');
            console.log('All drivers:', allDrivers);
            console.log('Drivers marked as off:', tempDriversOff);
            
            const availableDrivers = allDrivers.filter(driver => {
                const isOff = tempDriversOff.some(off => off.id === driver.id || off.id === driver.uid);
                return !isOff;
            });
            
            console.log(`Available drivers for optimization: ${availableDrivers.length}`);
            
            if (availableDrivers.length === 0) {
                alert('No drivers available for optimization');
                closeOptimiseSettings();
                return;
            }
            
            // Close the settings popup
            closeOptimiseSettings();
            
            // Show progress modal
            showOptimizationProgress();
            
            // Use the optimal assignment algorithm instead of simple direct assignment
            await assignDriversToSavedRoutes(availableDrivers);
            
            // Track optimization usage for billing
            await trackOptimizationUsage();
            
            // Hide progress modal
            hideOptimizationProgress();
        }
        
        // Global progress tracking variables
        let optimizationStartTime = null;
        let totalCalculations = 0;
        let completedCalculations = 0;
        
        // Show optimization progress modal
        function showOptimizationProgress() {
            optimizationStartTime = Date.now();
            completedCalculations = 0;
            
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-[100]';
            overlay.id = 'optimization-progress-overlay';
            
            overlay.innerHTML = `
                <div class="bg-[#1a1f24] rounded-lg p-8 w-full max-w-md mx-4 border border-[#283039]">
                    <!-- Header -->
                    <div class="text-center mb-6">
                        <div class="inline-flex items-center justify-center w-16 h-16 bg-green-600 bg-opacity-20 rounded-full mb-4">
                            <span class="material-symbols-outlined text-4xl text-green-500 animate-spin">settings</span>
                        </div>
                        <h3 class="text-2xl font-bold text-white mb-2">Optimizing Routes</h3>
                        <p class="text-gray-400 text-sm">Please wait while we find the best driver assignments...</p>
                    </div>
                    
                    <!-- Progress Bar -->
                    <div class="mb-6">
                        <div class="w-full bg-[#283039] rounded-full h-3 overflow-hidden">
                            <div id="optimization-progress-bar" class="h-full bg-gradient-to-r from-green-600 to-green-400 rounded-full transition-all duration-500" style="width: 0%"></div>
                        </div>
                        <p id="optimization-progress-text" class="text-center text-sm text-gray-400 mt-2">Initializing...</p>
                        <p id="optimization-time-estimate" class="text-center text-xs text-gray-500 mt-1">Calculating time estimate...</p>
                    </div>
                    
                    <!-- Current Step -->
                    <div class="space-y-3">
                        <div id="optimization-step-1" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Loading routes</span>
                        </div>
                        <div id="optimization-step-2" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Fetching driver data</span>
                        </div>
                        <div id="optimization-step-3" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Calculating distances</span>
                        </div>
                        <div id="optimization-step-4" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Running optimization</span>
                        </div>
                        <div id="optimization-step-5" class="flex items-center gap-3 p-3 bg-[#283039] rounded-lg opacity-50">
                            <span class="material-symbols-outlined text-gray-500">pending</span>
                            <span class="text-sm text-gray-400">Assigning drivers</span>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
        }
        
        // Update optimization progress with time estimate
        function updateOptimizationProgress(step, percentage, text, currentCalc = null, total = null) {
            const progressBar = document.getElementById('optimization-progress-bar');
            const progressText = document.getElementById('optimization-progress-text');
            const timeEstimate = document.getElementById('optimization-time-estimate');
            const stepElement = document.getElementById(`optimization-step-${step}`);
            
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
            
            if (progressText) {
                progressText.textContent = text || `${percentage}%`;
            }
            
            // Update time estimate if we have calculation progress
            if (timeEstimate && currentCalc && total && completedCalculations > 0) {
                const elapsed = (Date.now() - optimizationStartTime) / 1000; // seconds
                const avgTimePerCalc = elapsed / completedCalculations;
                const remaining = total - completedCalculations;
                const estimatedRemaining = Math.ceil(avgTimePerCalc * remaining);
                
                if (estimatedRemaining > 60) {
                    const mins = Math.floor(estimatedRemaining / 60);
                    const secs = estimatedRemaining % 60;
                    timeEstimate.textContent = `Estimated time remaining: ${mins}m ${secs}s`;
                } else {
                    timeEstimate.textContent = `Estimated time remaining: ${estimatedRemaining}s`;
                }
            } else if (timeEstimate) {
                timeEstimate.textContent = 'Calculating time estimate...';
            }
            
            if (stepElement) {
                // Mark current step as active
                stepElement.classList.remove('opacity-50');
                stepElement.classList.add('bg-green-600', 'bg-opacity-20');
                stepElement.querySelector('.material-symbols-outlined').textContent = 'check_circle';
                stepElement.querySelector('.material-symbols-outlined').classList.remove('text-gray-500');
                stepElement.querySelector('.material-symbols-outlined').classList.add('text-green-500');
                stepElement.querySelector('span:last-child').classList.remove('text-gray-400');
                stepElement.querySelector('span:last-child').classList.add('text-white');
            }
        }
        
        // Track optimization usage for billing
        async function trackOptimizationUsage() {
            try {
                const officeId = getCurrentOfficeId();
                
                if (!officeId) {
                    console.warn('No office ID found for tracking');
                    return;
                }
                
                // Get current date
                const now = new Date();
                const year = now.getFullYear();
                const month = now.getMonth() + 1; // 1-12
                const day = now.getDate();
                
                // Create document ID based on office, year, month, day
                const docId = `${officeId}_${year}_${String(month).padStart(2, '0')}_${String(day).padStart(2, '0')}`;
                
                // Check if document exists for today
                const usageDocRef = window.firebaseDoc(window.firestore, 'optimization_usage', docId);
                const usageDoc = await window.firebaseGetDoc(usageDocRef);
                
                if (usageDoc.exists()) {
                    // Increment count
                    const currentCount = usageDoc.data().count || 0;
                    await window.firebaseSetDoc(usageDocRef, {
                        officeId: officeId,
                        year: year,
                        month: month,
                        day: day,
                        count: currentCount + 1,
                        lastOptimization: now
                    });
                    console.log(` Usage tracked: ${officeId} - Day ${day}/${month}/${year} - Count: ${currentCount + 1}`);
                } else {
                    // Create new document with count = 1
                    await window.firebaseSetDoc(usageDocRef, {
                        officeId: officeId,
                        year: year,
                        month: month,
                        day: day,
                        count: 1,
                        firstOptimization: now,
                        lastOptimization: now
                    });
                    console.log(` Usage tracked: ${officeId} - Day ${day}/${month}/${year} - Count: 1 (first)`);
                }
            } catch (error) {
                console.error('Error tracking optimization usage:', error);
                // Don't throw error - tracking shouldn't block optimization
            }
        }
        
        // Hide optimization progress modal with completion animation
        function hideOptimizationProgress() {
            // Show 100% completion
            updateOptimizationProgress(5, 100, 'Complete!');
            
            // Change spinner to check icon
            setTimeout(() => {
                const spinner = document.querySelector('#optimization-progress-overlay .material-symbols-outlined.animate-spin');
                if (spinner) {
                    spinner.classList.remove('animate-spin');
                    spinner.textContent = 'check_circle';
                }
            }, 100);
            
            // Hide after a delay
            setTimeout(() => {
                const overlay = document.getElementById('optimization-progress-overlay');
                if (overlay) {
                    overlay.remove();
                }
            }, 1500);
        }

        // Simple direct assignment function
        async function assignDriversToRoutesDirect(driversToUse) {
            console.log('Direct assignment with drivers:', driversToUse.length);
            console.log('Routes to assign:', savedRoutes.length);
            
            if (savedRoutes.length === 0 || driversToUse.length === 0) {
                console.log('No routes or drivers available for assignment');
                return;
            }
            
            // Simple assignment: assign drivers to routes in order
            for (let i = 0; i < savedRoutes.length && i < driversToUse.length; i++) {
                const route = savedRoutes[i];
                const driver = driversToUse[i];
                
                console.log(`Assigning driver ${driver.name || (driver.firstName + ' ' + driver.lastName)} to route ${i + 1}`);
                
                // Update the route with driver assignment (save in nested route object)
                route.route.assignedDriver = driver;
                route.route.assignedDriverName = driver.name || (driver.firstName + ' ' + driver.lastName);
                route.route.assignedDriverPostcode = driver.homePostcode || driver.postcode;
                
                // Update the UI elements immediately
                const routeNumber = i + 1;
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                
                if (driverElement) {
                    driverElement.textContent = route.route.assignedDriverName;
                }
                if (locationElement) {
                    locationElement.textContent = route.route.assignedDriverPostcode;
                }
                
                // Calculate and display distances
                await updateRouteDistances(routeNumber, route.route.assignedDriverPostcode, route.jobs);
            }
            
            // Save the assignments to Firebase (with driver assignment data)
            await saveRoutesToFirebase();
            
            // Don't reload from Firebase - keep current assignments in memory
            // await displayRoutesFromFirebase(); // Removed to preserve driver assignments
            
            alert(`Optimization complete! Assigned ${Math.min(savedRoutes.length, driversToUse.length)} drivers to routes.`);
        }

        // Convert minutes to hours and minutes
        function formatTime(minutes) {
            if (minutes < 60) {
                return `${minutes}m`;
            }
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
        }

        // Format travel option for display (collapsed by default)
        function formatTravelOptionForRoute(option, routeNumber, direction, useMixedMode = false) {
            if (!option || !option.success) {
                return '<span class="text-red-400 text-xs">Error</span>';
            }
            
            const detailsId = `${routeNumber}-${direction}-details`;
            const mixedDetailsId = `${routeNumber}-${direction}-mixed-details`;
            
            // Handle requires_authorization mode (show train station route with red car)
            if (option.mode === 'requires_authorization') {
                if (option.driveToStation && option.transitFromStation) {
                    const totalTime = option.totalDuration;
                    const driveTime = option.driveToStation.duration;
                    const transitTime = option.transitFromStation.duration;
                    
                    const stepsHTML = `
                        <div class="flex items-center gap-1">
                            <span class="material-symbols-outlined text-red-500 font-bold" style="font-size: 12px;">local_taxi</span>
                            <span class="text-white text-xs font-bold">${formatTime(driveTime)}</span>
                            <span class="text-gray-400 text-xs">to ${option.trainStation.name}</span>
                        </div>
                        ${option.transitFromStation.steps.map(step => {
                            if (step.type === 'transit') {
                                const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                                const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                                return `
                                    <div class="flex items-center gap-1">
                                        <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                        <span class="text-white text-xs">${formatTime(step.duration)}</span>
                                    </div>
                                `;
                            } else if (step.type === 'walk') {
                                return `
                                    <div class="flex items-center gap-1">
                                        <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                        <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                    </div>
                                `;
                            }
                            return '';
                        }).join('')}
                    `;
                    
                    return `
                        <div>
                            <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#1a1f24] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${detailsId}')">
                                <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">warning</span>
                                <span class="text-white text-xs font-bold">${formatTime(totalTime)}</span>
                                <span class="text-xs text-yellow-400">(Auth Req'd)</span>
                                <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${detailsId}-icon">expand_more</span>
                            </div>
                            <div id="${detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                ${stepsHTML}
                            </div>
                        </div>
                    `;
                } else {
                    // No station found or no transit from station
                    return `
                        <div class="flex items-center gap-1.5">
                            <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">warning</span>
                            <span class="text-white text-xs font-bold">${formatTime(option.originalDrivingDuration)}</span>
                            <span class="text-xs text-yellow-400">(Auth Req'd)</span>
                        </div>
                    `;
                }
            }
            
            if (option.mode === 'taxi') {
                return `
                    <div class="flex items-center gap-1.5">
                        <span class="material-symbols-outlined text-yellow-400" style="font-size: 14px;">local_taxi</span>
                        <span class="text-white text-xs font-bold">${formatTime(option.duration)}</span>
                    </div>
                `;
            } else {
                // Check if mixed mode route exists
                const hasMixedMode = option.mixedModeRoute && option.mixedModeRoute.duration < option.duration;
                
                if (hasMixedMode) {
                    // Display both routes side-by-side
                    const mixedMode = option.mixedModeRoute;
                    const timeSavings = option.duration - mixedMode.duration;
                    
                    // Render mixed mode steps
                    const mixedStepsHTML = mixedMode.allSteps.map(step => {
                        if (step.type === 'drive') {
                            // Check if this is an authorized route (red car) or regular mixed mode (green car)
                            const isAuthorized = option.mode === 'requires_authorization';
                            const carColor = isAuthorized ? 'text-red-500 font-bold' : 'text-green-500';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${carColor}" style="font-size: 12px; font-weight: ${isAuthorized ? 'bold' : 'normal'};">local_taxi</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        } else if (step.type === 'transit') {
                            const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                            const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        } else if (step.type === 'walk') {
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                    <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        }
                        return '';
                    }).filter(h => h).join('');
                    
                    // Render original transit steps
                    const originalStepsHTML = (option.allSteps || []).map(step => {
                        if (step.type === 'transit') {
                            const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                            const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                    <span class="text-white text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        } else if (step.type === 'walk') {
                            return `
                                <div class="flex items-center gap-1">
                                    <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                    <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                                </div>
                            `;
                        }
                        return '';
                    }).filter(h => h).join('');
                    
                    // Determine display order based on useMixedMode flag
                    const leftRoute = useMixedMode ? {
                        label: 'Mixed Mode',
                        time: mixedMode.duration,
                        stepsHTML: mixedStepsHTML,
                        detailsId: mixedDetailsId,
                        icon: 'add_road',
                        iconColor: 'text-green-500',
                        timeSavings: timeSavings
                    } : {
                        label: 'Full Transit',
                        time: option.duration,
                        stepsHTML: originalStepsHTML,
                        detailsId: detailsId,
                        icon: 'directions_transit',
                        iconColor: 'text-blue-400',
                        timeSavings: null
                    };
                    
                    const rightRoute = useMixedMode ? {
                        label: 'Full Transit',
                        time: option.duration,
                        stepsHTML: originalStepsHTML,
                        detailsId: detailsId,
                        icon: 'directions_transit',
                        iconColor: 'text-blue-400',
                        timeSavings: null
                    } : {
                        label: 'Mixed Mode',
                        time: mixedMode.duration,
                        stepsHTML: mixedStepsHTML,
                        detailsId: mixedDetailsId,
                        icon: 'add_road',
                        iconColor: 'text-green-500',
                        timeSavings: timeSavings
                    };
                    
                    return `
                        <div class="grid grid-cols-2 gap-2">
                            <!-- Left Route (Always primary/used for optimization) -->
                            <div class="bg-[#1a1f24] rounded p-2 border-2 border-green-500">
                                <div class="text-xs text-gray-400 mb-1">${leftRoute.label}</div>
                                <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#283039] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${leftRoute.detailsId}')">
                                    <span class="material-symbols-outlined ${leftRoute.iconColor}" style="font-size: 14px;">${leftRoute.icon}</span>
                                    <span class="text-white text-xs font-bold">${formatTime(leftRoute.time)}</span>
                                    <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${leftRoute.detailsId}-icon">expand_more</span>
                                </div>
                                <div id="${leftRoute.detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                    ${leftRoute.timeSavings ? `<div class="text-green-500 text-xs font-bold mb-1">Saves ${formatTime(leftRoute.timeSavings)}</div>` : ''}
                                    ${leftRoute.stepsHTML}
                                </div>
                            </div>
                            
                            <!-- Right Route (Alternative option) -->
                            <div class="bg-[#1a1f24] rounded p-2">
                                <div class="text-xs text-gray-400 mb-1">${rightRoute.label}</div>
                                <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#283039] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${rightRoute.detailsId}')">
                                    <span class="material-symbols-outlined ${rightRoute.iconColor}" style="font-size: 14px;">${rightRoute.icon}</span>
                                    <span class="text-white text-xs font-bold">${formatTime(rightRoute.time)}</span>
                                    <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${rightRoute.detailsId}-icon">expand_more</span>
                                </div>
                                <div id="${rightRoute.detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                                    ${rightRoute.timeSavings ? `<div class="text-green-500 text-xs font-bold mb-1">Saves ${formatTime(rightRoute.timeSavings)}</div>` : ''}
                                    ${rightRoute.stepsHTML}
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // No mixed mode - show single transit route
                const allSteps = option.allSteps || [];
                const stepsHTML = allSteps.map(step => {
                    if (step.type === 'transit') {
                        const icon = step.mode === 'BUS' ? 'directions_bus' : 'train';
                        const iconColor = step.mode === 'BUS' ? 'text-blue-400' : 'text-purple-400';
                        return `
                            <div class="flex items-center gap-1">
                                <span class="material-symbols-outlined ${iconColor}" style="font-size: 12px;">${icon}</span>
                                <span class="text-white text-xs">${formatTime(step.duration)}</span>
                            </div>
                        `;
                    } else if (step.type === 'walk') {
                        return `
                            <div class="flex items-center gap-1">
                                <span class="material-symbols-outlined text-gray-400" style="font-size: 12px;">directions_walk</span>
                                <span class="text-gray-400 text-xs">${formatTime(step.duration)}</span>
                            </div>
                        `;
                    }
                    return '';
                }).filter(h => h).join('');
                
                return `
                    <div>
                        <div class="flex items-center gap-1.5 cursor-pointer hover:bg-[#1a1f24] rounded px-1 -mx-1 py-0.5 transition-colors" onclick="toggleTravelDetails('${detailsId}')">
                            <span class="material-symbols-outlined text-blue-400" style="font-size: 14px;">directions_transit</span>
                            <span class="text-white text-xs font-bold">${formatTime(option.duration)}</span>
                            <span class="material-symbols-outlined text-gray-500" style="font-size: 12px;" id="${detailsId}-icon">expand_more</span>
                        </div>
                        <div id="${detailsId}" class="hidden flex flex-col gap-0.5 mt-1 pl-2">
                            ${stepsHTML}
                        </div>
                    </div>
                `;
                }
            }
        }
        
        // Toggle travel details expansion
        function toggleTravelDetails(detailsId) {
            const detailsElement = document.getElementById(detailsId);
            const iconElement = document.getElementById(`${detailsId}-icon`);
            if (detailsElement && iconElement) {
                detailsElement.classList.toggle('hidden');
                iconElement.textContent = detailsElement.classList.contains('hidden') ? 'expand_more' : 'expand_less';
            }
        }

        // Update route distances using Google Maps API
        async function updateRouteDistances(routeNumber, driverPostcode, jobs) {
            console.log(` updateRouteDistances called for route ${routeNumber}`);
            if (!jobs || jobs.length === 0) {
                console.log(` No jobs for route ${routeNumber}`);
                return;
            }
            
            
            try {
                const firstJob = jobs[0];
                const lastJob = jobs[jobs.length - 1];
                
                const collectionAddress = firstJob.parsedData?.collection_address || firstJob.collectionAddress;
                const deliveryAddress = lastJob.parsedData?.postcode_delivery || lastJob.deliveryAddress;
                
                console.log(` Route ${routeNumber} - Driver: ${driverPostcode}, Collection: ${collectionAddress}, Delivery: ${deliveryAddress}`);
                
                // Calculate travel options from driver to first collection (arrive by 8 AM)
                console.log(` Calculating TO work for route ${routeNumber}...`);
                const toWorkOptions = await calculateTravelOptions(driverPostcode, collectionAddress, true);
                
                // Calculate travel options from last delivery back to driver (depart at 6 PM)
                console.log(` Calculating FROM work for route ${routeNumber}...`);
                const fromWorkOptions = await calculateTravelOptions(deliveryAddress, driverPostcode, false);
                
                // Update the UI elements
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                
                if (toWorkElement) {
                    toWorkElement.innerHTML = formatTravelOptionForRoute(toWorkOptions, `route-${routeNumber}`, 'to-work');
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = formatTravelOptionForRoute(fromWorkOptions, `route-${routeNumber}`, 'from-work');
                }
                
            } catch (error) {
                console.error(`Error calculating travel options for route ${routeNumber}:`, error);
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                if (toWorkElement) {
                    toWorkElement.innerHTML = '<span class="text-red-400 text-xs">Error</span>';
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = '<span class="text-red-400 text-xs">Error</span>';
                }
            }
        }

        // Calculate distance between two addresses using Firebase Functions
        async function calculateDistance(origin, destination) {
            try {
                const calculateDistanceFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateDistance');
                const result = await calculateDistanceFunction({
                    origin: origin,
                    destination: destination
                });
                
                if (result.data.success) {
                    return result.data.distance;
                } else {
                    throw new Error(result.data.error || 'Distance calculation failed');
                }
            } catch (error) {
                console.error('Error calculating distance:', error);
                throw error;
            }
        }

        // Get next Monday for accurate weekday transit schedules
        function getNextMonday() {
            const today = new Date();
            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            let daysUntilMonday;
            if (dayOfWeek === 0) {
                // Today is Sunday, next Monday is tomorrow
                daysUntilMonday = 1;
            } else if (dayOfWeek === 1) {
                // Today is Monday, use next Monday
                daysUntilMonday = 7;
            } else {
                // Today is Tuesday-Saturday, calculate days until next Monday
                daysUntilMonday = (8 - dayOfWeek) % 7;
                if (daysUntilMonday === 0) daysUntilMonday = 7;
            }
            
            const nextMonday = new Date(today);
            nextMonday.setDate(today.getDate() + daysUntilMonday);
            
            console.log(` Today: ${today.toLocaleDateString()} (${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]})`);
            console.log(` Using next Monday: ${nextMonday.toLocaleDateString()} for transit calculations`);
            
            return nextMonday;
        }

        // Calculate travel options (taxi vs public transport) using Firebase Functions
        async function calculateTravelOptions(origin, destination, isToWork = true) {
            try {
                console.log(` Calculating travel options: ${origin}  ${destination} (${isToWork ? 'TO work' : 'FROM work'})`);
                
                // Use departure times for more realistic routes
                // TO work: Depart at 7 AM (arrive by 8 AM)
                // FROM work: Depart at 6 PM
                // Calculate for next Monday to get accurate weekday transit schedules
                const nextMonday = getNextMonday();
                
                const departAt7AM = new Date(nextMonday.getFullYear(), nextMonday.getMonth(), nextMonday.getDate(), 7, 0, 0);
                const departAt6PM = new Date(nextMonday.getFullYear(), nextMonday.getMonth(), nextMonday.getDate(), 18, 0, 0);
                
                const departureTime = Math.floor((isToWork ? departAt7AM : departAt6PM).getTime() / 1000);
                
                console.log(` Departure time: ${(isToWork ? departAt7AM : departAt6PM).toLocaleString()}`);
                
                const calculateTravelOptionsFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateTravelOptions');
                const result = await calculateTravelOptionsFunction({
                    origin: origin,
                    destination: destination,
                    departureTime: departureTime
                });
                
                console.log(` Travel options result:`, result.data);
                return result.data;
            } catch (error) {
                console.error(' Error calculating travel options:', error);
                console.error('Error details:', error.message, error.stack);
                return {
                    success: false,
                    error: error.message
                };
            }
        }

        // Start optimization after alterations
        async function startOptimization() {
            closeAlterationsPopup();
            
            console.log('Starting optimization with carry-overs:', carryOverPostcodes);
            
            // If no saved routes, show demo routes for optimization
            if (savedRoutes.length === 0) {
                showDemoRoutes();
                optimizeDemoRoutes();
                return;
            }
            
            // Optimize saved routes
            const optimizeButton = document.querySelector('button[onclick="showOptimiseSettings()"]');
            optimizeButton.disabled = true;
            optimizeButton.innerHTML = '<span class="truncate">Optimising...</span>';
            optimizeButton.classList.add('opacity-50');

            // Assign drivers to saved routes using Google Maps API
            try {
                await assignDriversToSavedRoutes();
                
                // Reset button
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert(`Routes optimized successfully! Optimized ${savedRoutes.length} saved routes using Google Maps API and ${drivers.length} drivers.`);
            } catch (error) {
                console.error('Error during optimization:', error);
                
                // Reset button
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert('Error during optimization. Please check console for details.');
            }
        }

        // Optimize demo routes (when no saved routes exist)
        function optimizeDemoRoutes() {
            const optimizeButton = document.querySelector('button[onclick="showOptimiseSettings()"]');
            optimizeButton.disabled = true;
            optimizeButton.innerHTML = '<span class="truncate">Optimising...</span>';
            optimizeButton.classList.add('opacity-50');

            setTimeout(async () => {
                await assignDriversToRoutes();
                
                optimizeButton.disabled = false;
                optimizeButton.innerHTML = '<span class="truncate">Optimise</span>';
                optimizeButton.classList.remove('opacity-50');
                
                alert('Demo routes optimized! Go to the Routes page to create and save your own routes.');
            }, 2000);
        }

        // Assign drivers to saved routes from Firebase using optimal assignment algorithm
        async function assignDriversToSavedRoutes(driversToUse = null) {
            // Step 1: Loading routes
            updateOptimizationProgress(1, 20, 'Loading routes...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            const driversForAssignment = driversToUse || drivers;
            console.log('Assigning drivers using PRIORITY-BASED assignment algorithm...');
            console.log('Saved routes count:', savedRoutes.length);
            console.log('Drivers count:', driversForAssignment.length);
            
            if (savedRoutes.length === 0 || driversForAssignment.length === 0) {
                console.log('No routes or drivers available for assignment');
                return;
            }
            
            // Step 2: Fetching driver data
            updateOptimizationProgress(2, 40, 'Fetching driver data...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Calculate total number of API calls for time estimation
            totalCalculations = savedRoutes.length * driversForAssignment.length;
            console.log(` Total calculations needed: ${totalCalculations} (${savedRoutes.length} routes  ${driversForAssignment.length} drivers)`);
            
            // First pass: Calculate all routes to determine which ones need mixed mode
            // A route needs mixed mode if ALL drivers have >2 hour original transit time
            const routeNeedsMixedMode = new Array(savedRoutes.length).fill(false);
            const routeCalculations = []; // Store all calculations
            
            // Calculate all possible driver-route combinations with travel options
            const assignments = [];
            
            for (let routeIndex = 0; routeIndex < savedRoutes.length; routeIndex++) {
                const routeData = savedRoutes[routeIndex];
                const jobs = routeData.jobs;
                
                if (jobs.length > 0) {
                    const firstJob = jobs[0];
                    const lastJob = jobs[jobs.length - 1];
                    const collectionAddress = firstJob.parsedData?.collection_address || 'B797RU';
                    const deliveryAddress = lastJob.parsedData?.postcode_delivery || 'M1 4AN';
                    
                    const routeDriverTimes = []; // Track times for this route across all drivers
                    
                    // Calculate travel options for each driver with this route
                    for (let driverIndex = 0; driverIndex < driversForAssignment.length; driverIndex++) {
                        const driver = driversForAssignment[driverIndex];
                        
                        // Step 3: Calculating distances (update progress for each calculation)
                        completedCalculations = routeIndex * driversForAssignment.length + driverIndex + 1;
                        const calculationProgress = 40 + Math.floor((completedCalculations / totalCalculations) * 20);
                        updateOptimizationProgress(3, calculationProgress, `Calculating distances (${completedCalculations}/${totalCalculations})...`, completedCalculations, totalCalculations);
                        
                        try {
                            const driverHomePostcode = driver.homePostcode || driver.postcode;
                            const hasCarryover = driversWithCarryover.has(driver.id);
                            const carryoverPostcode = driversWithCarryover.get(driver.id);
                            
                            // Use carryover postcode for "to work" if driver has one
                            const toWorkOrigin = hasCarryover ? carryoverPostcode : driverHomePostcode;
                            
                            console.log(`Calculating travel options for driver ${driverIndex + 1} and route ${routeIndex + 1}... ${hasCarryover ? '(with carryover)' : ''}`);
                            
                            // Get travel options for both directions
                            const toWorkOptions = await calculateTravelOptions(toWorkOrigin, collectionAddress, true);
                            const fromWorkOptions = await calculateTravelOptions(deliveryAddress, driverHomePostcode, false);
                            
                            // Track original total time for this driver on this route
                            const originalTotalTime = toWorkOptions.duration + fromWorkOptions.duration;
                            routeDriverTimes.push(originalTotalTime);
                            
                            // Store the calculation for later processing
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions,
                                fromWorkOptions,
                                originalTotalTime,
                                hasCarryover: hasCarryover,
                                carryoverPostcode: carryoverPostcode
                            });
                            
                        } catch (error) {
                            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
                            console.error(`Error calculating travel options for driver ${driverName} and route ${routeIndex + 1}:`, error);
                            // Add error placeholder
                            routeCalculations.push({
                                routeIndex,
                                driverIndex,
                                driver,
                                routeData,
                                toWorkOptions: { success: false },
                                fromWorkOptions: { success: false },
                                originalTotalTime: 999
                            });
                            routeDriverTimes.push(999);
                        }
                    }
                    
                    // Check if ALL drivers have >2 hours for this route
                    const allDriversOverThreshold = routeDriverTimes.every(time => time > 120);
                    routeNeedsMixedMode[routeIndex] = allDriversOverThreshold;
                    
                    if (allDriversOverThreshold) {
                        console.log(` Route ${routeIndex + 1} needs mixed mode (all drivers >2hrs)`);
                    }
                }
            }
            
            // Second pass: Build assignments with correct mode based on route analysis
            console.log('Building assignments with mixed mode decisions...');
            console.log('Routes needing mixed mode:', routeNeedsMixedMode.map((needs, i) => needs ? `Route ${i+1}` : null).filter(r => r).join(', ') || 'None');
            
            for (const calc of routeCalculations) {
                const useMixedMode = routeNeedsMixedMode[calc.routeIndex];
                
                let effectiveToWorkDuration = calc.toWorkOptions.duration;
                let effectiveFromWorkDuration = calc.fromWorkOptions.duration;
                let useMixedModeToWork = false;
                let useMixedModeFromWork = false;
                
                // If this route needs mixed mode (all drivers >2hrs), use it for optimization
                if (useMixedMode) {
                    if (calc.toWorkOptions.mixedModeRoute) {
                        const originalTime = calc.toWorkOptions.duration;
                        const mixedTime = calc.toWorkOptions.mixedModeRoute.duration;
                        effectiveToWorkDuration = mixedTime;
                        useMixedModeToWork = true;
                        console.log(`  Route ${calc.routeIndex + 1} TO work: Using mixed mode ${mixedTime}min (was ${originalTime}min)`);
                    }
                    if (calc.fromWorkOptions.mixedModeRoute) {
                        const originalTime = calc.fromWorkOptions.duration;
                        const mixedTime = calc.fromWorkOptions.mixedModeRoute.duration;
                        effectiveFromWorkDuration = mixedTime;
                        useMixedModeFromWork = true;
                        console.log(`  Route ${calc.routeIndex + 1} FROM work: Using mixed mode ${mixedTime}min (was ${originalTime}min)`);
                    }
                }
                
                const totalTime = effectiveToWorkDuration + effectiveFromWorkDuration;
                const bothTaxi = calc.toWorkOptions.mode === 'taxi' && calc.fromWorkOptions.mode === 'taxi';
                const oneTaxi = (calc.toWorkOptions.mode === 'taxi') !== (calc.fromWorkOptions.mode === 'taxi');
                const requiresAuth = calc.toWorkOptions.mode === 'requires_authorization' || calc.fromWorkOptions.mode === 'requires_authorization';
                            
                            let priorityScore;
                            if (requiresAuth) {
                                // Very low priority - these need manual authorization
                                priorityScore = -10000 + totalTime; // Negative score to de-prioritize
                            } else if (bothTaxi) {
                                priorityScore = 10000 - totalTime;
                            } else if (oneTaxi) {
                    const transitTime = calc.toWorkOptions.mode === 'transit' ? effectiveToWorkDuration : effectiveFromWorkDuration;
                                priorityScore = 5000 - transitTime;
                            } else {
                                priorityScore = 1000 - totalTime;
                }
                
                // BOOST priority for drivers with carryovers (add 50000 to ensure they get preference)
                if (calc.hasCarryover) {
                    priorityScore += 50000;
                    console.log(`   Carryover driver - boosting priority: ${priorityScore}`);
                            }
                            
                const assignment = {
                    routeIndex: calc.routeIndex,
                    driverIndex: calc.driverIndex,
                    driver: calc.driver,
                    routeData: calc.routeData,
                    toWorkOptions: calc.toWorkOptions,
                    fromWorkOptions: calc.fromWorkOptions,
                    totalTime: totalTime,
                    priorityScore: priorityScore,
                    bothTaxi: bothTaxi,
                    oneTaxi: oneTaxi,
                    useMixedModeToWork: useMixedModeToWork,
                    useMixedModeFromWork: useMixedModeFromWork,
                    hasCarryover: calc.hasCarryover,
                    carryoverPostcode: calc.carryoverPostcode
                };
                
                assignments.push(assignment);
            }
            
            // Store assignments globally for authorization function
            window.currentAssignments = assignments;
            
            // Step 4: Running optimization
            updateOptimizationProgress(4, 80, 'Running optimization algorithm...');
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // Find optimal assignment using priority score (not distance)
            // Modified Hungarian algorithm to use priorityScore instead of totalDistance
            const optimalAssignment = findOptimalAssignmentByPriority(assignments, savedRoutes.length, driversForAssignment.length);
            
            console.log(` Optimal assignment found with ${optimalAssignment.length} assignments`);
            
            // Step 5: Assigning drivers
            updateOptimizationProgress(5, 95, 'Assigning drivers to routes...');
            await new Promise(resolve => setTimeout(resolve, 300));
            
            // Sort assignments by priority score (highest first)
            optimalAssignment.sort((a, b) => {
                return b.priorityScore - a.priorityScore; // Highest priority first
            });
            
            // Apply the optimal assignment to UI and calculate scores
            const assignmentsWithScores = [];
            
            for (const assignment of optimalAssignment) {
                const routeNumber = assignment.routeIndex + 1;
                const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                const toWorkElement = document.getElementById(`firebase-route-${routeNumber}-to-work`);
                const fromWorkElement = document.getElementById(`firebase-route-${routeNumber}-from-work`);
                
                const driverName = assignment.driver.name || (assignment.driver.firstName + ' ' + assignment.driver.lastName) || 'Unknown Driver';
                const driverHome = assignment.driver.homePostcode || assignment.driver.postcode || 'Unknown';
                
                // CRITICAL: Update the route object in savedRoutes with driver assignment
                assignment.routeData.route.assignedDriver = assignment.driver;
                assignment.routeData.route.assignedDriverName = driverName;
                assignment.routeData.route.assignedDriverPostcode = driverHome;
                
                // Store carryover information if it exists
                if (assignment.hasCarryover) {
                    assignment.routeData.route.carryoverPostcode = assignment.carryoverPostcode;
                }
                
                // Get REG number from first job
                const firstJob = assignment.routeData.jobs[0];
                const regNumber = firstJob?.parsedData?.reg_number || '-';
                
                // Update REG display
                const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                if (regElement) {
                    regElement.textContent = regNumber;
                }
                
                // Update driver name
                if (driverElement) {
                    driverElement.textContent = driverName;
                }
                
                // Update driver home
                if (locationElement) {
                    locationElement.textContent = driverHome;
                }
                
                // Show carryover if driver has one
                if (assignment.hasCarryover && assignment.carryoverPostcode) {
                    const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                    const carryoverPostcodeElement = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                    
                    if (carryoverDisplay) {
                        carryoverDisplay.classList.remove('hidden');
                    }
                    if (carryoverPostcodeElement) {
                        carryoverPostcodeElement.textContent = assignment.carryoverPostcode;
                    }
                    
                    // Change "To First Job" label to "From Carryover"
                    const toWorkLabel = document.getElementById(`firebase-route-${routeNumber}-to-work-label`);
                    if (toWorkLabel) {
                        toWorkLabel.textContent = 'From Carryover';
                    }
                }
                
                // Display travel options - check EACH DIRECTION separately
                // TO work: Show mixed mode only if TO work time > 2 hours
                const toWorkOriginalTime = assignment.toWorkOptions.duration;
                const fromWorkOriginalTime = assignment.fromWorkOptions.duration;
                const shouldShowMixedModeToWork = toWorkOriginalTime > 120;
                const shouldShowMixedModeFromWork = fromWorkOriginalTime > 120;
                
                // Calculate effective times for SCORING based on what's actually displayed
                // Use mixed mode if available AND original time > 2 hours (matches display logic)
                const effectiveToWork = shouldShowMixedModeToWork && assignment.toWorkOptions.mixedModeRoute 
                    ? { ...assignment.toWorkOptions, duration: assignment.toWorkOptions.mixedModeRoute.duration, mode: 'mixed' }
                    : assignment.toWorkOptions;
                const effectiveFromWork = shouldShowMixedModeFromWork && assignment.fromWorkOptions.mixedModeRoute
                    ? { ...assignment.fromWorkOptions, duration: assignment.fromWorkOptions.mixedModeRoute.duration, mode: 'mixed' }
                    : assignment.fromWorkOptions;
                
                // Log the ACTUAL times being used for scoring (match what's displayed)
                const displayToWorkTime = shouldShowMixedModeToWork && assignment.toWorkOptions.mixedModeRoute 
                    ? assignment.toWorkOptions.mixedModeRoute.duration 
                    : toWorkOriginalTime;
                const displayFromWorkTime = shouldShowMixedModeFromWork && assignment.fromWorkOptions.mixedModeRoute 
                    ? assignment.fromWorkOptions.mixedModeRoute.duration 
                    : fromWorkOriginalTime;
                
                console.log(`Route ${routeNumber}: TO work ${displayToWorkTime}min (${shouldShowMixedModeToWork ? 'Mixed Mode' : 'Original'} on left), FROM work ${displayFromWorkTime}min (${shouldShowMixedModeFromWork ? 'Mixed Mode' : 'Original'} on left)`);
                
                if (toWorkElement) {
                    toWorkElement.innerHTML = formatTravelOptionForRoute(assignment.toWorkOptions, `route-${routeNumber}`, 'to-work', shouldShowMixedModeToWork);
                }
                if (fromWorkElement) {
                    fromWorkElement.innerHTML = formatTravelOptionForRoute(assignment.fromWorkOptions, `route-${routeNumber}`, 'from-work', shouldShowMixedModeFromWork);
                }
                
                const routeScore = calculateTravelScore(effectiveToWork, effectiveFromWork);
                const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                
                // Log score calculation details for carryover drivers
                if (assignment.hasCarryover) {
                    console.log(` Route ${routeNumber} (Carryover driver): Score ${routeScore.score} - TO: ${effectiveToWork.duration}min, FROM: ${effectiveFromWork.duration}min`);
                }
                
                // Store assignment with score for sorting later
                assignmentsWithScores.push({
                    routeNumber: routeNumber,
                    score: routeScore.score,
                    routeElement: document.getElementById(`firebase-route-${routeNumber}`)
                });
                
                if (scoreElement) {
                    scoreElement.textContent = `${routeScore.score}`;
                }
                if (scoreContainer) {
                    // Apply color based on score
                    if (routeScore.color === 'green') {
                        scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                    } else if (routeScore.color === 'orange') {
                        scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                    } else {
                        scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                    }
                }
                
                // CRITICAL: Save the route score to the route data for persistence
                assignment.routeData.route.routeScore = routeScore;
                
                console.log(` Assigned ${driverName} to route ${routeNumber} (Score: ${routeScore.score}/100)`);
            }
            
            // Sort routes by score (highest first) and reorder in DOM
            assignmentsWithScores.sort((a, b) => b.score - a.score);
            
            console.log('Routes sorted by score:', assignmentsWithScores.map(a => `Route ${a.routeNumber}: ${a.score}`).join(', '));
            
            // Wait for DOM updates to complete before reordering
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const routesContainer = document.getElementById('routes-container');
            if (routesContainer && assignmentsWithScores.length > 0) {
                // Re-fetch elements to ensure they exist
                const sortedElements = assignmentsWithScores
                    .map(item => {
                        const el = document.getElementById(`firebase-route-${item.routeNumber}`);
                        if (!el) {
                            console.warn(`Route element not found: firebase-route-${item.routeNumber}`);
                        }
                        return el;
                    })
                    .filter(el => el);
                
                console.log(`Found ${sortedElements.length} route elements to sort`);
                
                // Detach elements from DOM first (preserves them)
                sortedElements.forEach(el => el.remove());
                
                // Re-append in sorted order (highest score first)
                sortedElements.forEach(element => {
                    routesContainer.appendChild(element);
                });
                
                console.log(' Routes reordered: Top-left (highest) to bottom-right (lowest)');
            }
            
            // Display routes requiring authorization (detected during calculations)
            // Only show routes that require auth AND were NOT assigned in optimal assignment
            const assignedRouteIndices = new Set(optimalAssignment.map(a => a.routeIndex));
            const routesRequiringAuth = assignments.filter(assignment => 
                (assignment.toWorkOptions.mode === 'requires_authorization' || 
                 assignment.fromWorkOptions.mode === 'requires_authorization') &&
                !assignedRouteIndices.has(assignment.routeIndex)
            );
            
            const authSection = document.getElementById('authorization-routes-section');
            const authContainer = document.getElementById('authorization-routes-container');
            
            if (routesRequiringAuth.length > 0) {
                authContainer.innerHTML = '';
                // Group by route and find best driver for each route
                const routeAuthMap = new Map();
                routesRequiringAuth.forEach(assignment => {
                    if (!routeAuthMap.has(assignment.routeIndex)) {
                        routeAuthMap.set(assignment.routeIndex, assignment);
                    } else {
                        // Keep the one with higher priority score
                        const existing = routeAuthMap.get(assignment.routeIndex);
                        if (assignment.priorityScore > existing.priorityScore) {
                            routeAuthMap.set(assignment.routeIndex, assignment);
                        }
                    }
                });
                
                routeAuthMap.forEach(assignment => {
                    const card = createAuthorizationRouteCard(assignment);
                    authContainer.appendChild(card);
                });
                authSection.classList.remove('hidden');
            } else {
                authSection.classList.add('hidden');
            }
            
            // Display unassigned drivers (jobless drivers)
            const assignedDriverIndices = new Set(optimalAssignment.map(a => a.driverIndex));
            const joblessDrivers = driversForAssignment.filter((driver, index) => !assignedDriverIndices.has(index));
            
            const joblessDriversSection = document.getElementById('jobless-drivers-section');
            const joblessDriversContainer = document.getElementById('jobless-drivers-container');
            
            if (joblessDrivers.length > 0) {
                joblessDriversContainer.innerHTML = '';
                joblessDrivers.forEach(driver => {
                    const card = createJoblessDriverCard(driver);
                    joblessDriversContainer.appendChild(card);
                });
                joblessDriversSection.classList.remove('hidden');
            } else {
                joblessDriversSection.classList.add('hidden');
            }
            
            // Display unassigned routes (driverless routes)
            const driverlessRoutes = savedRoutes.filter((route, index) => !assignedRouteIndices.has(index));
            
            const driverlessRoutesSection = document.getElementById('driverless-routes-section');
            const driverlessRoutesContainer = document.getElementById('driverless-routes-container');
            
            if (driverlessRoutes.length > 0) {
                driverlessRoutesContainer.innerHTML = '';
                driverlessRoutes.forEach((route, index) => {
                    const card = createDriverlessRouteCard(route, index);
                    driverlessRoutesContainer.appendChild(card);
                });
                driverlessRoutesSection.classList.remove('hidden');
            } else {
                driverlessRoutesSection.classList.add('hidden');
            }
            
            const totalDistance = optimalAssignment.reduce((sum, assignment) => sum + assignment.totalDistance, 0);
            
            // Save all driver assignments to Firebase
            console.log(' Saving driver assignments to Firebase...');
            await saveRoutesToFirebase();
            console.log(' Driver assignments saved to Firebase');
        }
        
        // Calculate route score based on total distance (for backward compatibility)
        function calculateRouteScore(totalDistance) {
            if (totalDistance <= 20) return { score: 10, color: 'green' };
            if (totalDistance <= 40) return { score: 9, color: 'green' };
            if (totalDistance <= 60) return { score: 8, color: 'orange' };
            if (totalDistance <= 80) return { score: 7, color: 'orange' };
            if (totalDistance <= 100) return { score: 6, color: 'orange' };
            if (totalDistance <= 120) return { score: 5, color: 'red' };
            if (totalDistance <= 140) return { score: 4, color: 'red' };
            if (totalDistance <= 160) return { score: 3, color: 'red' };
            if (totalDistance <= 180) return { score: 2, color: 'red' };
            return { score: 1, color: 'red' };
        }

        // Calculate route score based on travel time and mode (out of 100)
        function calculateTravelScore(toWork, fromWork) {
            // Handle requires_authorization mode - use totalDuration if available
            const toWorkDuration = toWork.mode === 'requires_authorization' && toWork.totalDuration ? toWork.totalDuration : toWork.duration;
            const fromWorkDuration = fromWork.mode === 'requires_authorization' && fromWork.totalDuration ? fromWork.totalDuration : fromWork.duration;
            
            const totalMinutes = toWorkDuration + fromWorkDuration;
            const bothTaxi = toWork.mode === 'taxi' && fromWork.mode === 'taxi';
            const oneTaxi = (toWork.mode === 'taxi') !== (fromWork.mode === 'taxi');
            const requiresAuth = toWork.mode === 'requires_authorization' || fromWork.mode === 'requires_authorization';
            
            let score = 0;
            
            // Routes requiring authorization get penalty (20-40 points based on total time)
            if (requiresAuth) {
                // Lower score for auth-required routes to prioritize them less
                if (totalMinutes <= 60) {
                    score = 40; // Best case for auth routes
                } else if (totalMinutes <= 120) {
                    score = 35 - Math.floor((totalMinutes - 60) / 12); // 35 down to 30
                } else {
                    score = Math.max(20, 30 - Math.floor((totalMinutes - 120) / 20)); // 30 down to 20
                }
                return score;
            }
            
            // BOTH TAXI: 90-100 points (based on total taxi time)
            if (bothTaxi) {
                // Perfect: 0-4min total = 100
                // Excellent: 5-8min = 99
                // Very good: 9-20min = 95-98
                // Good: 21-30min = 90-94
                if (totalMinutes <= 4) {
                    score = 100;
                } else if (totalMinutes <= 8) {
                    score = 99;
                } else if (totalMinutes <= 30) {
                    score = 98 - Math.floor((totalMinutes - 8) / 3); // 98 down to 90
                } else {
                    score = Math.max(85, 90 - Math.floor((totalMinutes - 30) / 2)); // Slowly decrease
                }
            }
            // ONE TAXI: 70-90 points (based on transit time)
            else if (oneTaxi) {
                const transitTime = toWork.mode === 'transit' ? toWork.duration : fromWork.duration;
                
                if (transitTime <= 30) {
                    // 30min transit = 90 points
                    score = 90;
                } else if (transitTime <= 60) {
                    // 30-60min transit = 80-89
                    // 30min = 90, 60min = 80
                    score = 90 - Math.floor((transitTime - 30) / 3);
                } else if (transitTime <= 90) {
                    // 60-90min transit = 75-79
                    score = 80 - Math.floor((transitTime - 60) / 6);
                } else {
                    // >90min transit = 70-74
                    score = Math.max(70, 75 - Math.floor((transitTime - 90) / 10));
                }
            }
            // BOTH TRANSIT: 10-70 points (based on total transit time)
            else {
                const totalHours = totalMinutes / 60;
                
                if (totalHours <= 2) {
                    // 2hr = 70 points
                    score = 70;
                } else if (totalHours <= 2.5) {
                    // 2-2.5hr = 60-69
                    score = 70 - Math.floor((totalMinutes - 120) / 3);
                } else if (totalHours <= 3) {
                    // 2.5-3hr = 50-59
                    score = 60 - Math.floor((totalMinutes - 150) / 3);
                } else if (totalHours <= 3.5) {
                    // 3-3.5hr = 40-49
                    score = 50 - Math.floor((totalMinutes - 180) / 3);
                } else if (totalHours <= 4) {
                    // 3.5-4hr = 30-39
                    score = 40 - Math.floor((totalMinutes - 210) / 3);
                } else if (totalHours <= 4.5) {
                    // 4-4.5hr = 20-29
                    score = 30 - Math.floor((totalMinutes - 240) / 3);
                } else if (totalHours <= 5) {
                    // 4.5-5hr = 10-19
                    score = 20 - Math.floor((totalMinutes - 270) / 3);
                } else {
                    // >5hr = 1-9
                    score = Math.max(1, 10 - Math.floor((totalMinutes - 300) / 10));
                }
            }
            
            // Ensure score stays between 1-100
            score = Math.max(1, Math.min(100, score));
            
            // Determine color based on score
            let color = 'red';
            if (score >= 80) color = 'green';
            else if (score >= 50) color = 'orange';
            
            return { score, color };
        }

        // Create jobless driver card
        // Create authorization route card with "Authorise Drive" button
        function createAuthorizationRouteCard(assignment) {
            const route = assignment.routeData;
            const driver = assignment.driver;
            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
            const driverPostcode = driver.homePostcode || driver.postcode || 'Unknown';
            const totalTime = assignment.totalTime;
            
            // Check which direction requires authorization
            const toWorkAuth = assignment.toWorkOptions.mode === 'requires_authorization';
            const fromWorkAuth = assignment.fromWorkOptions.mode === 'requires_authorization';
            
            // Get train station info
            let stationInfo = '';
            if (toWorkAuth && assignment.toWorkOptions.trainStation) {
                stationInfo = assignment.toWorkOptions.trainStation.name;
            } else if (fromWorkAuth && assignment.fromWorkOptions.trainStation) {
                stationInfo = assignment.fromWorkOptions.trainStation.name;
            }
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-yellow-500/30 bg-yellow-900/10 p-4';
            card.id = `auth-route-${assignment.routeIndex}`;
            
            // Format total time
            const hours = Math.floor(totalTime / 60);
            const minutes = totalTime % 60;
            const timeText = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;
            
            card.innerHTML = `
                <div class="flex items-center justify-between gap-3">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-10 bg-yellow-600 rounded-full flex items-center justify-center">
                            <span class="material-symbols-outlined text-white text-lg">warning</span>
                        </div>
                        <div class="flex-1">
                            <h3 class="font-semibold text-white">Route ${route.route.routeNumber || assignment.routeIndex + 1}</h3>
                            <p class="text-sm text-gray-400">${stationInfo ? `Via ${stationInfo}` : 'No direct transit'}</p>
                        </div>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-yellow-400 font-medium">Needs Authorization</span>
                    </div>
                </div>
                
                <div class="border-t border-gray-700 pt-3">
                    <div class="grid grid-cols-2 gap-3 text-sm mb-3">
                        <div>
                            <span class="text-gray-400">Best Driver:</span>
                            <p class="text-white font-semibold">${driverName}</p>
                            <p class="text-gray-500 text-xs">${driverPostcode}</p>
                        </div>
                        <div>
                            <span class="text-gray-400">Total Time:</span>
                            <p class="text-white font-semibold">${timeText}</p>
                            <p class="text-gray-500 text-xs">Including drive</p>
                        </div>
                    </div>
                    
                    ${toWorkAuth ? '<p class="text-xs text-yellow-300 mb-2"> TO work requires driving to station</p>' : ''}
                    ${fromWorkAuth ? '<p class="text-xs text-yellow-300 mb-2"> FROM work requires driving from station</p>' : ''}
                    
                    <button onclick="authorizeRoute(${assignment.routeIndex}, ${assignment.driverIndex})" 
                            class="w-full bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-lg transition-colors text-sm font-semibold">
                        Authorise Drive
                    </button>
                </div>
            `;
            
            return card;
        }

        function createJoblessDriverCard(driver) {
            const driverName = driver.name || (driver.firstName + ' ' + driver.lastName) || 'Unknown Driver';
            const driverPostcode = driver.homePostcode || driver.postcode || 'Unknown';
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-red-500/30 bg-red-900/10 p-4';
            
            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-red-600 rounded-full flex items-center justify-center">
                        <span class="material-symbols-outlined text-white text-lg">person_off</span>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-white">${driverName}</h3>
                        <p class="text-sm text-gray-400">${driverPostcode}</p>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-red-400 font-medium">No Route</span>
                    </div>
                </div>
                <div class="text-sm text-gray-400">
                    This driver was not assigned to any routes during optimization.
                </div>
            `;
            
            return card;
        }

        // Create driverless route card
        function createDriverlessRouteCard(routeData, routeIndex) {
            const routeNumber = routeIndex + 1;
            const jobs = routeData.jobs || [];
            
            // Create job pairs display
            let jobPairsHTML = '';
            jobs.forEach((job, index) => {
                const jobLetter = String.fromCharCode(65 + index);
                const collectionPostcode = job.parsedData?.collection_address || 'N/A';
                const deliveryPostcode = job.parsedData?.postcode_delivery || 'N/A';
                
                jobPairsHTML += `
                    <div class="flex items-center gap-2 text-xs">
                        <span class="text-green-400">${collectionPostcode}</span>
                        <span class="material-symbols-outlined text-gray-400 text-sm">arrow_forward</span>
                        <span class="text-red-400">${deliveryPostcode}</span>
                    </div>
                `;
            });
            
            const card = document.createElement('div');
            card.className = 'flex flex-col gap-3 rounded-lg border border-orange-500/30 bg-orange-900/10 p-4';
            
            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 bg-orange-600 rounded-full flex items-center justify-center">
                        <span class="material-symbols-outlined text-white text-lg">route</span>
                    </div>
                    <div class="flex-1">
                        <h3 class="font-semibold text-white">Route ${routeNumber}</h3>
                        <p class="text-sm text-gray-400">${jobs.length} job${jobs.length !== 1 ? 's' : ''}</p>
                    </div>
                    <div class="text-right">
                        <span class="text-xs text-orange-400 font-medium">No Driver</span>
                    </div>
                </div>
                <div class="space-y-1">
                    ${jobPairsHTML}
                </div>
                <div class="text-sm text-gray-400">
                    This route was not assigned to any drivers during optimization.
                </div>
            `;
            
            return card;
        }
        
        // Find optimal assignment using a greedy approach (simplified Hungarian algorithm)
        function findOptimalAssignment(assignments, numRoutes, numDrivers) {
            // Sort assignments by total distance (ascending)
            assignments.sort((a, b) => a.totalDistance - b.totalDistance);
            
            const assignedRoutes = new Set();
            const assignedDrivers = new Set();
            const optimalAssignment = [];
            
            // Greedy assignment: pick the best available option at each step
            for (const assignment of assignments) {
                // Skip if this route or driver is already assigned
                if (assignedRoutes.has(assignment.routeIndex) || assignedDrivers.has(assignment.driverIndex)) {
                    continue;
                }
                
                // Assign this driver to this route
                assignedRoutes.add(assignment.routeIndex);
                assignedDrivers.add(assignment.driverIndex);
                optimalAssignment.push(assignment);
                
                // Stop if we've assigned all routes
                if (optimalAssignment.length === numRoutes) {
                    break;
                }
            }
            
            // If we have more drivers than routes, we're done
            // If we have more routes than drivers, assign remaining routes to the best available driver
            if (optimalAssignment.length < numRoutes) {
                console.warn(` More routes (${numRoutes}) than drivers (${numDrivers}). Some routes will be unassigned.`);
            }
            
            return optimalAssignment;
        }

        // Find optimal assignment using priority score (taxi priority over transit)
        function findOptimalAssignmentByPriority(assignments, numRoutes, numDrivers) {
            // Sort assignments by priority score (descending - highest priority first)
            assignments.sort((a, b) => b.priorityScore - a.priorityScore);
            
            const assignedRoutes = new Set();
            const assignedDrivers = new Set();
            const optimalAssignment = [];
            
            // Greedy assignment: pick the best available option at each step
            for (const assignment of assignments) {
                // Skip if this route or driver is already assigned
                if (assignedRoutes.has(assignment.routeIndex) || assignedDrivers.has(assignment.driverIndex)) {
                    continue;
                }
                
                // Assign this driver to this route
                assignedRoutes.add(assignment.routeIndex);
                assignedDrivers.add(assignment.driverIndex);
                optimalAssignment.push(assignment);
                
                // Stop if we've assigned all routes or all drivers
                if (optimalAssignment.length === Math.min(numRoutes, numDrivers)) {
                    break;
                }
            }
            
            console.log(` Assignment summary: ${optimalAssignment.length} routes assigned`);
            
            return optimalAssignment;
        }

        // Assign drivers to demo routes using optimal assignment algorithm
        async function assignDriversToRoutes() {
            const routes = [
                { id: 1, delivery: "M1 4AN", collection: "B797RU" },
                { id: 2, delivery: "B775JA", collection: "CV1 1GF" },
                { id: 3, delivery: "LS1 4DY", collection: "S1 2HE" }
            ];

            if (drivers.length === 0) {
                console.log('No drivers available for demo assignment');
                return;
            }

            // Calculate all possible driver-route combinations for demo routes
            const assignments = [];
            
            for (let routeIndex = 0; routeIndex < routes.length; routeIndex++) {
                const route = routes[routeIndex];
                
                console.log(`Calculating distances for Demo Route ${route.id} (Collection: ${route.collection}, Delivery: ${route.delivery})`);
                
                // Calculate distances for each driver with this route
                for (let driverIndex = 0; driverIndex < drivers.length; driverIndex++) {
                    const driver = drivers[driverIndex];
                    
                    try {
                        // Use carry-over postcode for distance TO collection, home postcode for distance FROM delivery
                        const startingPostcode = carryOverPostcodes[driverIndex] || driver.postcode;
                        const endingPostcode = driver.postcode; // Always use home postcode for return journey
                        
                        const distanceToCollection = await calculateDistance(startingPostcode, route.collection);
                        const distanceFromDelivery = await calculateDistance(route.delivery, endingPostcode);
                        const totalDistance = distanceToCollection + distanceFromDelivery;
                        
                        assignments.push({
                            routeIndex: routeIndex,
                            routeId: route.id,
                            driverIndex: driverIndex,
                            driver: driver,
                            distanceToCollection: distanceToCollection,
                            distanceFromDelivery: distanceFromDelivery,
                            totalDistance: totalDistance
                        });
                        
                        const carryOverInfo = carryOverPostcodes[driverIndex] ? ` (carry-over: ${carryOverPostcodes[driverIndex]})` : '';
                        console.log(`Driver ${driver.name}${carryOverInfo}  Demo Route ${route.id}: ${distanceToCollection} mi to collection + ${distanceFromDelivery} mi from delivery = ${totalDistance} mi total`);
                        
                    } catch (error) {
                        console.error(`Error calculating distance for driver ${driver.name} and demo route ${route.id}:`, error);
                        // Add with default distances
                        assignments.push({
                            routeIndex: routeIndex,
                            routeId: route.id,
                            driverIndex: driverIndex,
                            driver: driver,
                            distanceToCollection: 100,
                            distanceFromDelivery: 100,
                            totalDistance: 200
                        });
                    }
                }
            }
            
            // Find optimal assignment
            const optimalAssignment = findOptimalAssignment(assignments, routes.length, drivers.length);
            
            console.log('Optimal demo assignment found:', optimalAssignment);
            
            // Apply the optimal assignment to demo UI
            for (const assignment of optimalAssignment) {
                const routeId = assignment.routeId;
                
                // Update UI
                document.getElementById(`route-${routeId}-driver`).textContent = assignment.driver.name;
                document.getElementById(`route-${routeId}-driver-location`).textContent = assignment.driver.postcode;
                
                // Display both distances
                document.getElementById(`route-${routeId}-distance-to-collection`).textContent = `${assignment.distanceToCollection} miles`;
                document.getElementById(`route-${routeId}-distance`).textContent = `${assignment.distanceFromDelivery} miles`;
                
                // Update progress bars
                const progressToCollectionBar = document.getElementById(`route-${routeId}-progress-to-collection`);
                const progressHomeBar = document.getElementById(`route-${routeId}-progress`);
                
                // Update collection distance progress bar
                if (progressToCollectionBar) {
                    const percentage = Math.min((assignment.distanceToCollection / 100) * 100, 100);
                    progressToCollectionBar.style.width = `${percentage}%`;
                    
                    // Apply gradient based on distance
                    if (assignment.distanceToCollection <= 20) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #10b981, #34d399)'; // Green gradient
                    } else if (assignment.distanceToCollection <= 40) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)'; // Orange gradient
                    } else if (assignment.distanceToCollection <= 60) {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #f97316, #fb923c)'; // Red-orange gradient
                } else {
                        progressToCollectionBar.className = 'h-full rounded-full';
                        progressToCollectionBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red gradient
                    }
                }
                
                // Update home distance progress bar
                if (progressHomeBar) {
                    const percentage = Math.min((assignment.distanceFromDelivery / 100) * 100, 100);
                    progressHomeBar.style.width = `${percentage}%`;
                    
                    // Apply gradient based on distance
                    if (assignment.distanceFromDelivery <= 20) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #10b981, #34d399)'; // Green gradient
                    } else if (assignment.distanceFromDelivery <= 40) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #f59e0b, #fbbf24)'; // Orange gradient
                    } else if (assignment.distanceFromDelivery <= 60) {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #f97316, #fb923c)'; // Red-orange gradient
                    } else {
                        progressHomeBar.className = 'h-full rounded-full';
                        progressHomeBar.style.background = 'linear-gradient(90deg, #dc2626, #ef4444)'; // Red gradient
                    }
                }
                
            }
            
            const totalDistance = optimalAssignment.reduce((sum, assignment) => sum + assignment.totalDistance, 0);
        }

        // Find best driver for a route based on minimizing sum of distance to first collection + distance from last delivery
        async function findBestDriver(deliveryAddress, collectionAddress) {
            if (!drivers || drivers.length === 0) {
                console.log('No drivers available');
                return { name: 'No Driver', postcode: 'Unknown' };
            }
            
            // Extract postcodes from addresses if they're full addresses
            let deliveryPostcode = deliveryAddress;
            let collectionPostcode = collectionAddress;
            
            if (deliveryAddress.includes(',')) {
                const parts = deliveryAddress.split(',');
                deliveryPostcode = parts[0].trim();
            }
            
            if (collectionAddress.includes(',')) {
                const parts = collectionAddress.split(',');
                collectionPostcode = parts[0].trim();
            }
            
            console.log('Finding best driver for collection:', collectionPostcode, 'and delivery:', deliveryPostcode);
            
            let bestDriver = drivers[0];
            let shortestTotalDistance = Infinity;
            let bestDistances = { toCollection: 0, fromDelivery: 0 };
            
            // Calculate total distance (to first collection + from last delivery) for each driver
            for (const driver of drivers) {
                try {
                    const distanceToCollection = await calculateDistance(driver.postcode, collectionPostcode);
                    const distanceFromDelivery = await calculateDistance(deliveryPostcode, driver.postcode);
                    const totalDistance = distanceToCollection + distanceFromDelivery;
                    
                    console.log(`Driver ${driver.name} (${driver.postcode}): ${distanceToCollection} mi to collection + ${distanceFromDelivery} mi from delivery = ${totalDistance} mi total`);
                    
                    if (totalDistance < shortestTotalDistance) {
                        shortestTotalDistance = totalDistance;
                        bestDriver = driver;
                        bestDistances = { toCollection: distanceToCollection, fromDelivery: distanceFromDelivery };
                    }
                } catch (error) {
                    console.error(`Error calculating distance for driver ${driver.name}:`, error);
                    // Use default distances for this driver
                    const defaultTotalDistance = 200;
                    if (defaultTotalDistance < shortestTotalDistance) {
                        shortestTotalDistance = defaultTotalDistance;
                        bestDriver = driver;
                        bestDistances = { toCollection: 100, fromDelivery: 100 };
                    }
                }
            }
            
            console.log(`Best driver: ${bestDriver.name} (${bestDriver.postcode}) - ${bestDistances.toCollection} mi to collection + ${bestDistances.fromDelivery} mi from delivery = ${shortestTotalDistance} mi total`);
            return { 
                ...bestDriver, 
                distance: bestDistances.fromDelivery, // Keep for backward compatibility
                distanceToCollection: bestDistances.toCollection,
                totalDistance: shortestTotalDistance
            };
        }

        // Google Maps Distance Matrix API integration
        let distanceMatrixService;
        let isGoogleMapsLoaded = false;
        let googleMapsError = null;

        // Google Maps callback function
        window.initGoogleMaps = function() {
            try {
                if (window.google && window.google.maps) {
                    distanceMatrixService = new google.maps.DistanceMatrixService();
                    isGoogleMapsLoaded = true;
                }
            } catch (error) {
                googleMapsError = error;
                console.error(' Google Maps API initialization error:', error);
                console.error('Make sure Distance Matrix API, Geocoding API, and Maps JavaScript API are enabled');
            }
        };

        // Wait for Google Maps to load
        function waitForGoogleMaps() {
            return new Promise((resolve, reject) => {
                if (googleMapsError) {
                    reject(googleMapsError);
                    return;
                }
                
                if (window.google && window.google.maps && distanceMatrixService) {
                    resolve(true);
                } else {
                    setTimeout(() => waitForGoogleMaps().then(resolve).catch(reject), 100);
                }
            });
        }

        // Calculate distance between two postcodes using Google Maps Distance Matrix API
        async function calculateDistance(postcode1, postcode2) {
            try {
                // Add UK to postcodes for better geocoding
                const origin = `${postcode1}, UK`;
                const destination = `${postcode2}, UK`;

                const calculateDistanceFunction = window.firebase.httpsCallable(window.firebase.functions, 'calculateDistance');
                const result = await calculateDistanceFunction({
                    origin: origin,
                    destination: destination
                });
                
                if (result.data.success) {
                    return Math.round(result.data.distance);
                } else {
                    console.warn(` Firebase Functions error for ${postcode1} to ${postcode2}:`, result.data.error);
                    return calculateFallbackDistance(postcode1, postcode2);
                }
            } catch (error) {
                console.warn('Firebase Functions not available, using fallback calculation:', error.message);
                return calculateFallbackDistance(postcode1, postcode2);
            }
        }

        // Enhanced fallback distance calculation when Google Maps API is not available
        function calculateFallbackDistance(postcode1, postcode2) {
            // More comprehensive UK postcode area distance mapping
            const area1 = postcode1.substring(0, 1);
            const area2 = postcode2.substring(0, 1);
            
            // If same area, estimate shorter distance
            if (area1 === area2) {
                const distance = Math.floor(Math.random() * 30) + 10; // 10-40 miles within same area
                console.log(` Same area (${area1}) distance from ${postcode1} to ${postcode2}: ${distance} miles`);
                return distance;
            }
            
            // Cross-area distances (more realistic UK distances)
            const areaDistances = {
                'B': { 'M': 85, 'L': 125, 'S': 120, 'E': 140, 'N': 130, 'default': 65 },
                'M': { 'B': 85, 'L': 45, 'S': 185, 'E': 200, 'N': 220, 'default': 55 },
                'L': { 'B': 125, 'M': 45, 'S': 205, 'E': 180, 'N': 100, 'default': 85 },
                'S': { 'B': 120, 'M': 185, 'L': 205, 'E': 50, 'N': 150, 'default': 110 },
                'E': { 'B': 140, 'M': 200, 'L': 180, 'S': 50, 'N': 120, 'default': 95 },
                'N': { 'B': 130, 'M': 220, 'L': 100, 'S': 150, 'E': 120, 'default': 90 }
            };
            
            const baseDistance = areaDistances[area1]?.[area2] || areaDistances[area1]?.['default'] || 60;
            // Add some variation to make it more realistic
            const variation = Math.floor(Math.random() * 20) - 10; // 10 miles variation
            const distance = Math.max(10, baseDistance + variation); // Minimum 10 miles
            
            console.log(` Fallback distance from ${postcode1} (${area1}) to ${postcode2} (${area2}): ${distance} miles`);
            return distance;
        }

        // Fallback straight-line distance calculation using Google Maps Geometry library
        function calculateStraightLineDistance(postcode1, postcode2) {
            const geocoder = new google.maps.Geocoder();
            
            return new Promise((resolve) => {
                const geocodePromises = [
                    new Promise((res) => geocoder.geocode({ address: `${postcode1}, UK` }, res)),
                    new Promise((res) => geocoder.geocode({ address: `${postcode2}, UK` }, res))
                ];

                Promise.all(geocodePromises).then(([result1, result2]) => {
                    if (result1[0] && result1[0].status === 'OK' && result2[0] && result2[0].status === 'OK') {
                        const location1 = result1[0].results[0].geometry.location;
                        const location2 = result2[0].results[0].geometry.location;
                        
                        const distance = google.maps.geometry.spherical.computeDistanceBetween(location1, location2);
                        const distanceInMiles = distance * 0.000621371;
                        console.log(`Straight-line distance from ${postcode1} to ${postcode2}: ${distanceInMiles.toFixed(1)} miles`);
                        resolve(Math.round(distanceInMiles));
                    } else {
                        console.warn('Geocoding failed, using fallback estimation');
                        resolve(calculateFallbackDistance(postcode1, postcode2));
                    }
                }).catch(() => {
                    resolve(calculateFallbackDistance(postcode1, postcode2));
                });
            });
        }

        // Clear all routes (both Firebase and localStorage)

        // Load and display routes function (can be called manually)
        async function loadAndDisplayRoutes() {
            const loadButton = document.querySelector('button[onclick="loadAndDisplayRoutes()"]');
            const originalText = loadButton ? loadButton.innerHTML : '';
            
            if (loadButton) {
                loadButton.innerHTML = '<span class="animate-spin"></span> Loading...';
                loadButton.disabled = true;
            }
            
            try {
                await displayRoutesFromFirebase();
                console.log('Routes loaded successfully');
            } catch (error) {
                console.error('Error loading routes:', error);
                alert('Error loading routes: ' + error.message);
            } finally {
                if (loadButton) {
                    loadButton.innerHTML = originalText;
                    loadButton.disabled = false;
                }
            }
        }

        // Load routes with their last assigned drivers (quick load)
        async function loadLastAssignedDrivers() {
            const loadButton = document.querySelector('button[onclick="loadLastAssignedDrivers()"]');
            const originalText = loadButton ? loadButton.innerHTML : '';
            
            if (loadButton) {
                loadButton.innerHTML = '<span class="animate-spin"></span> Loading...';
                loadButton.disabled = true;
            }
            
            try {
                console.log('Loading routes with last assigned drivers...');
                savedRoutes = await loadRoutesFromFirebase();
                
                if (savedRoutes.length === 0) {
                    showNoRoutesMessage();
                    return;
                }

                // Load drivers to check for unmatched routes/drivers
                await loadDriversFromFirebase();
                
                // Display routes with their assigned drivers
                await displayRoutesWithAssignments();
                
                // Handle unmatched routes and drivers
                await handleUnmatchedRoutesAndDrivers();
                
                console.log('Successfully loaded routes with last assigned drivers');
            } catch (error) {
                console.error('Error loading last assigned drivers:', error);
                showNoRoutesMessage(error);
            } finally {
                if (loadButton) {
                    loadButton.innerHTML = originalText;
                    loadButton.disabled = false;
                }
            }
        }

        // Display routes with their previously assigned drivers
        async function displayRoutesWithAssignments() {
            const routesContainer = document.getElementById('routes-container');
            if (!routesContainer) return;

            routesContainer.innerHTML = '';

            for (let i = 0; i < savedRoutes.length; i++) {
                const routeData = savedRoutes[i];
                const routeNumber = i + 1;
                
                // Create route card with assigned driver if available
                const routeDiv = createRouteElement(routeData.route, routeData.jobs, routeNumber);
                routesContainer.appendChild(routeDiv);
                
                // Populate driver assignment data if it exists
                if (routeData.route.assignedDriverName) {
                    const driverElement = document.getElementById(`firebase-route-${routeNumber}-driver`);
                    const locationElement = document.getElementById(`firebase-route-${routeNumber}-driver-location`);
                    const regElement = document.getElementById(`firebase-route-${routeNumber}-reg`);
                    
                    if (driverElement) {
                        driverElement.textContent = routeData.route.assignedDriverName;
                    }
                    
                    if (locationElement) {
                        locationElement.textContent = routeData.route.assignedDriverPostcode || '-';
                    }
                    
                    // Get REG number from first job
                    if (regElement && routeData.jobs.length > 0) {
                        const firstJob = routeData.jobs[0];
                        const regNumber = firstJob?.parsedData?.reg_number || '-';
                        regElement.textContent = regNumber;
                    }
                    
                    // Restore carryover information if it exists
                    if (routeData.route.carryoverPostcode) {
                        const carryoverDisplay = document.getElementById(`firebase-route-${routeNumber}-carryover-display`);
                        const carryoverPostcode = document.getElementById(`firebase-route-${routeNumber}-carryover-postcode`);
                        if (carryoverDisplay) carryoverDisplay.classList.remove('hidden');
                        if (carryoverPostcode) carryoverPostcode.textContent = routeData.route.carryoverPostcode;
                    }
                    
                    // Restore route score if it exists
                    if (routeData.route.routeScore) {
                        const scoreElement = document.getElementById(`firebase-route-${routeNumber}-score-text`);
                        const scoreContainer = document.getElementById(`firebase-route-${routeNumber}-score`);
                        
                        if (scoreElement) {
                            scoreElement.textContent = routeData.route.routeScore.score;
                        }
                        
                        if (scoreContainer) {
                            // Apply color based on score
                            if (routeData.route.routeScore.color === 'green') {
                                scoreContainer.className = 'absolute top-0 right-0 bg-green-600 rounded-bl-lg px-2 py-1';
                            } else if (routeData.route.routeScore.color === 'orange') {
                                scoreContainer.className = 'absolute top-0 right-0 bg-orange-500 rounded-bl-lg px-2 py-1';
                            } else {
                                scoreContainer.className = 'absolute top-0 right-0 bg-red-600 rounded-bl-lg px-2 py-1';
                            }
                        }
                    }
                    
                    console.log(` Restored assignment: ${routeData.route.assignedDriverName} to route ${routeNumber}`);
                }
            }
        }

        // Show no routes message
        function showNoRoutesMessage(error = null) {
            const routesContainer = document.getElementById('routes-container');
            if (routesContainer) {
                const message = error ? 
                    `<p class="text-red-400 text-center">Error loading routes: ${error.message || error}</p>` :
                    `<p class="text-gray-400 text-center">No routes found. Create routes in the Routes page first.</p>`;
                routesContainer.innerHTML = message;
            }
            
            // Hide all sections
            const authSection = document.getElementById('authorization-routes-section');
            const joblessSection = document.getElementById('jobless-drivers-section');
            const driverlessSection = document.getElementById('driverless-routes-section');
            
            if (authSection) authSection.classList.add('hidden');
            if (joblessSection) joblessSection.classList.add('hidden');
            if (driverlessSection) driverlessSection.classList.add('hidden');
        }
        
        // Display jobless drivers section
        function displayJoblessDrivers(joblessDrivers) {
            const joblessDriversSection = document.getElementById('jobless-drivers-section');
            const joblessDriversContainer = document.getElementById('jobless-drivers-container');
            
            if (!joblessDriversSection || !joblessDriversContainer) return;
            
            if (joblessDrivers.length > 0) {
                joblessDriversContainer.innerHTML = '';
                joblessDrivers.forEach(driver => {
                    const card = createJoblessDriverCard(driver);
                    joblessDriversContainer.appendChild(card);
                });
                joblessDriversSection.classList.remove('hidden');
            } else {
                joblessDriversSection.classList.add('hidden');
            }
        }
        
        // Display driverless routes section
        function displayDriverlessRoutes(driverlessRoutes) {
            const driverlessRoutesSection = document.getElementById('driverless-routes-section');
            const driverlessRoutesContainer = document.getElementById('driverless-routes-container');
            
            if (!driverlessRoutesSection || !driverlessRoutesContainer) return;
            
            if (driverlessRoutes.length > 0) {
                driverlessRoutesContainer.innerHTML = '';
                driverlessRoutes.forEach((route, index) => {
                    const card = createDriverlessRouteCard(route, index);
                    driverlessRoutesContainer.appendChild(card);
                });
                driverlessRoutesSection.classList.remove('hidden');
            } else {
                driverlessRoutesSection.classList.add('hidden');
            }
        }

        // Handle unmatched routes and drivers
        async function handleUnmatchedRoutesAndDrivers() {
            const assignedDriverIds = new Set();
            const assignedRouteIds = new Set();
            
            // Track which drivers and routes are assigned
            savedRoutes.forEach(route => {
                if (route.route.assignedDriver) {
                    assignedDriverIds.add(route.route.assignedDriver.uid || route.route.assignedDriver.id);
                    assignedRouteIds.add(route.route.id);
                }
            });
            
            // Find jobless drivers (drivers not assigned to any route)
            const joblessDrivers = drivers.filter(driver => {
                const driverId = driver.uid || driver.id;
                return !assignedDriverIds.has(driverId);
            });
            
            // Find driverless routes (routes without assigned drivers)
            const driverlessRoutes = savedRoutes.filter(route => !route.route.assignedDriver);
            
            // Display jobless drivers section
            if (joblessDrivers.length > 0) {
                displayJoblessDrivers(joblessDrivers);
            }
            
            // Display driverless routes section
            if (driverlessRoutes.length > 0) {
                displayDriverlessRoutes(driverlessRoutes);
            }
        }

        // Make functions globally available
        window.loadAndDisplayRoutes = loadAndDisplayRoutes;
        window.loadLastAssignedDrivers = loadLastAssignedDrivers;
        window.optimizeRoutes = optimizeRoutes;
        window.showNotifications = showNotifications;
        window.showAlterationsPopup = showAlterationsPopup;
        window.closeAlterationsPopup = closeAlterationsPopup;
        window.startOptimization = startOptimization;
        window.addCarryOverDriver = addCarryOverDriver;
        window.removeCarryOver = removeCarryOver;
        window.showOptimiseSettings = showOptimiseSettings;
        // Authorize a route - assign driver and mark for red car display
        async function authorizeRoute(routeIndex, driverIndex) {
            try {
                // Find the assignment in our stored assignments
                const assignment = window.currentAssignments.find(a => 
                    a.routeIndex === routeIndex && a.driverIndex === driverIndex
                );
                
                if (!assignment) {
                    console.error('Assignment not found');
                    return;
                }
                
                const route = assignment.routeData;
                const driver = assignment.driver;
                const routeNumber = route.route.routeNumber;
                
                // Mark this route as authorized (will show red car icon)
                route.requiresAuthorization = true;
                route.authorizationApproved = true;
                
                // Assign the driver to the route
                await updateRouteDistances(
                    routeNumber,
                    driver.homePostcode || driver.postcode,
                    route.jobs
                );
                
                // Remove from authorization section
                const authCard = document.getElementById(`auth-route-${routeIndex}`);
                if (authCard) {
                    authCard.remove();
                }
                
                // Check if authorization section is now empty
                const authContainer = document.getElementById('authorization-routes-container');
                const authSection = document.getElementById('authorization-routes-section');
                if (authContainer && authContainer.children.length === 0) {
                    authSection.classList.add('hidden');
                }
                
                // Find the route element in the assigned routes section
                const routeElement = document.getElementById(`firebase-route-${routeNumber}`);
                if (routeElement) {
                    // Scroll to the route
                    routeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Add a visual highlight temporarily
                    routeElement.classList.add('ring-2', 'ring-green-500');
                    setTimeout(() => {
                        routeElement.classList.remove('ring-2', 'ring-green-500');
                    }, 2000);
                }
                
                console.log(` Route ${routeNumber} authorized for driver ${driver.firstName} ${driver.lastName}`);
            } catch (error) {
                console.error('Error authorizing route:', error);
            }
        }
        
        window.closeOptimiseSettings = closeOptimiseSettings;
        window.startOptimisationWithSettings = startOptimisationWithSettings;
        window.selectOptimiseDay = selectOptimiseDay;
        window.toggleDriverOffStatus = toggleDriverOffStatus;
        window.removeDriverFromOff = removeDriverFromOff;
        window.toggleTravelDetails = toggleTravelDetails;
        window.authorizeRoute = authorizeRoute;

        // Wait for Firebase to be ready
        function waitForFirebase() {
            return new Promise((resolve) => {
                const checkFirebase = () => {
                    if (window.firestore && window.firebaseCollection) {
                        console.log('Firebase is ready!');
                        resolve(true);
                    } else {
                        console.log('Waiting for Firebase...');
                        setTimeout(checkFirebase, 100);
                    }
                };
                checkFirebase();
            });
        }

        // Initialize the page when it loads
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('Optimisation page loaded');
            
            // Check authentication first
            if (!(await checkAuthentication())) {
                return;
            }
            
            // Hide demo routes by default
            hideDemoRoutes();
            
            // Wait for Firebase to be ready, then load routes
            try {
                await waitForFirebase();
                
                // Load office logo after Firebase is ready
                try {
                    if (currentUser?.officeId) {
                        await loadOfficeLogo(currentUser.officeId);
                    }
                } catch (error) {
                    console.error('Error loading office logo on init:', error);
                }
                
                await displayRoutesFromFirebase();
                console.log('Initial routes loaded');
                
                // Initialize notification system
                await initializeNotifications();
                
            } catch (error) {
                console.error('Error initializing routes:', error);
                // Show a message to user
                const noRoutesMessage = document.getElementById('no-routes-message');
                if (noRoutesMessage) {
                    noRoutesMessage.innerHTML = `
                        <p class="text-lg mb-2">Loading routes...</p>
                        <p class="text-sm">Click "Load Routes" if routes don't appear automatically</p>
                    `;
                }
            }
        });

        // Profile dropdown functions
        function toggleProfileDropdown() {
            const dropdown = document.getElementById('profileDropdown');
            dropdown.classList.toggle('hidden');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('profileDropdown');
            const profileButton = event.target.closest('button[onclick="toggleProfileDropdown()"]');
            
            if (!profileButton && !dropdown.contains(event.target)) {
                dropdown.classList.add('hidden');
            }
        });

        function showChangePassword() {
            document.getElementById('changePasswordModal').classList.remove('hidden');
            document.getElementById('profileDropdown').classList.add('hidden');
        }

        function hideChangePassword() {
            document.getElementById('changePasswordModal').classList.add('hidden');
            document.getElementById('changePasswordForm').reset();
        }

        // View usage calendar
        function viewUsage() {
            const officeId = getCurrentOfficeId();
            if (!officeId) {
                console.warn('[OPTIMISATION] Unable to determine office for usage view.');
                return;
            }
            window.location.href = `/pages/office-calendar.html?officeId=${officeId}`;
        }

        // Handle password change
        async function handleChangePassword(event) {
            event.preventDefault();
            
            const currentPassword = document.getElementById('currentPassword').value;
            const newPassword = document.getElementById('newPassword').value;
            const confirmPassword = document.getElementById('confirmPassword').value;
            
            if (newPassword !== confirmPassword) {
                alert('New passwords do not match');
                return;
            }
            
            try {
                const user = window.auth.currentUser;
                if (!user) {
                    alert('No user logged in');
                    return;
                }
                
                // Re-authenticate user with current password
                const credential = window.EmailAuthProvider.credential(user.email, currentPassword);
                await window.reauthenticateWithCredential(user, credential);
                
                // Update password
                await window.updatePassword(user, newPassword);
                
                alert('Password changed successfully!');
                hideChangePassword();
                
            } catch (error) {
                console.error('Error changing password:', error);
                
                if (error.code === 'auth/wrong-password') {
                    alert('Current password is incorrect');
                } else if (error.code === 'auth/weak-password') {
                    alert('New password is too weak. Please choose a stronger password.');
                } else if (error.code === 'auth/requires-recent-login') {
                    alert('Please log out and log back in, then try changing your password again.');
                } else {
                    alert('Error changing password: ' + error.message);
                }
            }
        }

        // Make functions globally available
        window.toggleProfileDropdown = toggleProfileDropdown;
        window.showChangePassword = showChangePassword;
        window.hideChangePassword = hideChangePassword;
        window.viewUsage = viewUsage;
        window.handleChangePassword = handleChangePassword;

        // Add event listener for password form
        document.addEventListener('DOMContentLoaded', function() {
            const changePasswordForm = document.getElementById('changePasswordForm');
            if (changePasswordForm) {
                changePasswordForm.addEventListener('submit', handleChangePassword);
            }
        });
    </script>

    <!-- Change Password Modal -->
    <div id="changePasswordModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-[#1a1f24] border border-[#283039] rounded-lg p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">Change Password</h3>
                <button onclick="hideChangePassword()" class="text-gray-400 hover:text-white">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            
            <form id="changePasswordForm" class="space-y-4">
                <div>
                    <label for="currentPassword" class="block text-sm font-medium text-gray-300 mb-2">Current Password</label>
                    <input 
                        type="password" 
                        id="currentPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Enter current password"
                    >
                </div>
                
                <div>
                    <label for="newPassword" class="block text-sm font-medium text-gray-300 mb-2">New Password</label>
                    <input 
                        type="password" 
                        id="newPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Enter new password"
                    >
                </div>
                
                <div>
                    <label for="confirmPassword" class="block text-sm font-medium text-gray-300 mb-2">Confirm New Password</label>
                    <input 
                        type="password" 
                        id="confirmPassword" 
                        required 
                        class="w-full px-3 py-2 bg-[#283039] border border-gray-600 rounded-md text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                        placeholder="Confirm new password"
                    >
                </div>

                <button 
                    type="submit"
                    class="w-full bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors font-medium"
                >
                    Change Password
                </button>
            </form>
        </div>
    </div>
</body>
</html>
